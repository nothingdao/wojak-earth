<?xml version="1.0" encoding="UTF-8"?>
<bundle id="master-2025-05-29T04-25-21-857Z" created="2025-05-29T04:25:21.857Z" fileCount="41">
  
  <metadata>
    <projectName>project</projectName>
    <totalFiles>41</totalFiles>
    <bundleType>master</bundleType>
    <ignorePatterns>
      <pattern>node_modules</pattern>
      <pattern>.git</pattern>
      <pattern>dist</pattern>
      <pattern>build</pattern>
      <pattern>coverage</pattern>
      <pattern>.next</pattern>
      <pattern>.cache</pattern>
      <pattern>.netlify</pattern>
      <pattern>package-lock.json</pattern>
      <pattern>yarn.lock</pattern>
      <pattern>.DS_Store</pattern>
      <pattern>Thumbs.db</pattern>
      <pattern>*.mp3</pattern>
      <pattern>*.mp4</pattern>
      <pattern>*.wav</pattern>
      <pattern>*.ogg</pattern>
      <pattern>*.m4a</pattern>
      <pattern>*.flac</pattern>
      <pattern>*.jpg</pattern>
      <pattern>*.jpeg</pattern>
      <pattern>*.gif</pattern>
      <pattern>*.webp</pattern>
      <pattern>*.svg</pattern>
      <pattern>*.ico</pattern>
      <pattern>*.pxd</pattern>
      <pattern>*.pdf</pattern>
      <pattern>*.doc</pattern>
      <pattern>*.docx</pattern>
      <pattern>*.zip</pattern>
      <pattern>*.tar</pattern>
      <pattern>*.gz</pattern>
      <pattern>*.rar</pattern>
      <pattern>*.png</pattern>
    </ignorePatterns>
  </metadata>

  <directoryTree>
  <directory name="netlify" path="netlify">
    <directory name="functions" path="netlify/functions">
      <file name="buy-item.js" path="netlify/functions/buy-item.js" size="0" lastModified="2025-05-29T03:25:43.591Z">
        <tags></tags>
      </file>
      <file name="equip-item.js" path="netlify/functions/equip-item.js" size="0" lastModified="2025-05-29T00:03:21.365Z">
        <tags></tags>
      </file>
      <file name="get-character.js" path="netlify/functions/get-character.js" size="0" lastModified="2025-05-28T23:17:38.002Z">
        <tags></tags>
      </file>
      <file name="get-chat.js" path="netlify/functions/get-chat.js" size="0" lastModified="2025-05-28T23:51:59.175Z">
        <tags></tags>
      </file>
      <file name="get-locations.js" path="netlify/functions/get-locations.js" size="0" lastModified="2025-05-29T00:12:36.034Z">
        <tags></tags>
      </file>
      <file name="get-market.js" path="netlify/functions/get-market.js" size="0" lastModified="2025-05-29T03:47:50.500Z">
        <tags></tags>
      </file>
      <file name="get-players-at-location.js" path="netlify/functions/get-players-at-location.js" size="0" lastModified="2025-05-28T23:55:02.361Z">
        <tags></tags>
      </file>
      <file name="metadata.js" path="netlify/functions/metadata.js" size="0" lastModified="2025-05-29T02:46:06.495Z">
        <tags></tags>
      </file>
      <file name="mine-action.js" path="netlify/functions/mine-action.js" size="0" lastModified="2025-05-28T23:18:10.417Z">
        <tags></tags>
      </file>
      <file name="render-character.js" path="netlify/functions/render-character.js" size="0" lastModified="2025-05-29T02:46:20.676Z">
        <tags></tags>
      </file>
      <file name="send-message.js" path="netlify/functions/send-message.js" size="0" lastModified="2025-05-29T00:06:10.082Z">
        <tags></tags>
      </file>
      <file name="travel-action.js" path="netlify/functions/travel-action.js" size="0" lastModified="2025-05-28T23:30:33.914Z">
        <tags></tags>
      </file>
      <file name="use-item.js" path="netlify/functions/use-item.js" size="0" lastModified="2025-05-29T04:02:05.691Z">
        <tags></tags>
      </file>
    </directory>
  </directory>
  <directory name="prisma" path="prisma">
    <file name="schema.prisma" path="prisma/schema.prisma" size="0" lastModified="2025-05-28T22:31:59.236Z">
      <tags></tags>
    </file>
    <file name="seed.ts" path="prisma/seed.ts" size="0" lastModified="2025-05-28T23:49:37.575Z">
      <tags></tags>
    </file>
  </directory>
  <directory name="scripts" path="scripts">
    <file name="seed-markets.ts" path="scripts/seed-markets.ts" size="0" lastModified="2025-05-29T03:26:59.031Z">
      <tags></tags>
    </file>
  </directory>
  <directory name="src" path="src">
    <directory name="components" path="src/components">
      <directory name="ui" path="src/components/ui">
        <file name="button.tsx" path="src/components/ui/button.tsx" size="0" lastModified="2025-05-28T21:47:16.145Z">
          <tags></tags>
        </file>
        <file name="dropdown-menu.tsx" path="src/components/ui/dropdown-menu.tsx" size="0" lastModified="2025-05-29T00:35:27.082Z">
          <tags></tags>
        </file>
        <file name="sonner.tsx" path="src/components/ui/sonner.tsx" size="0" lastModified="2025-05-29T04:08:24.041Z">
          <tags></tags>
        </file>
      </directory>
      <file name="mode-toggle.tsx" path="src/components/mode-toggle.tsx" size="0" lastModified="2025-05-29T00:32:40.806Z">
        <tags></tags>
      </file>
      <file name="theme-provider.tsx" path="src/components/theme-provider.tsx" size="0" lastModified="2025-05-29T00:31:34.688Z">
        <tags></tags>
      </file>
    </directory>
    <directory name="lib" path="src/lib">
      <file name="layerResolver.ts" path="src/lib/layerResolver.ts" size="0" lastModified="2025-05-29T02:27:27.011Z">
        <tags></tags>
      </file>
      <file name="utils.ts" path="src/lib/utils.ts" size="0" lastModified="2025-05-28T21:46:49.754Z">
        <tags></tags>
      </file>
    </directory>
    <directory name="types" path="src/types">
      <file name="index.ts" path="src/types/index.ts" size="0" lastModified="2025-05-29T04:19:34.818Z">
        <tags></tags>
      </file>
    </directory>
    <file name="App.css" path="src/App.css" size="0" lastModified="2025-05-28T21:44:35.041Z">
      <tags></tags>
    </file>
    <file name="App.tsx" path="src/App.tsx" size="0" lastModified="2025-05-29T04:20:16.379Z">
      <tags></tags>
    </file>
    <file name="index.css" path="src/index.css" size="0" lastModified="2025-05-28T21:46:42.653Z">
      <tags></tags>
    </file>
    <file name="main.tsx" path="src/main.tsx" size="0" lastModified="2025-05-29T00:32:11.986Z">
      <tags></tags>
    </file>
    <file name="vite-env.d.ts" path="src/vite-env.d.ts" size="0" lastModified="2025-05-28T21:44:35.044Z">
      <tags></tags>
    </file>
  </directory>
  <file name=".env" path=".env" size="0" lastModified="2025-05-28T21:52:13.504Z">
    <tags></tags>
  </file>
  <file name=".gitignore" path=".gitignore" size="0" lastModified="2025-05-28T23:07:21.376Z">
    <tags></tags>
  </file>
  <file name="components.json" path="components.json" size="0" lastModified="2025-05-28T21:46:42.115Z">
    <tags></tags>
  </file>
  <file name="eslint.config.js" path="eslint.config.js" size="0" lastModified="2025-05-28T21:44:35.037Z">
    <tags></tags>
  </file>
  <file name="index.html" path="index.html" size="0" lastModified="2025-05-28T21:48:47.451Z">
    <tags></tags>
  </file>
  <file name="package.json" path="package.json" size="0" lastModified="2025-05-29T04:08:23.455Z">
    <tags></tags>
  </file>
  <file name="README.md" path="README.md" size="0" lastModified="2025-05-28T21:49:18.650Z">
    <tags></tags>
  </file>
  <file name="TODO.md" path="TODO.md" size="0" lastModified="2025-05-29T04:23:56.038Z">
    <tags></tags>
  </file>
  <file name="tsconfig.app.json" path="tsconfig.app.json" size="0" lastModified="2025-05-28T21:48:18.933Z">
    <tags></tags>
  </file>
  <file name="tsconfig.json" path="tsconfig.json" size="0" lastModified="2025-05-28T21:45:45.831Z">
    <tags></tags>
  </file>
  <file name="tsconfig.node.json" path="tsconfig.node.json" size="0" lastModified="2025-05-28T21:46:21.462Z">
    <tags></tags>
  </file>
  <file name="vite.config.ts" path="vite.config.ts" size="0" lastModified="2025-05-28T21:46:16.230Z">
    <tags></tags>
  </file>
</directoryTree>

  <asciiTree>
project/
├── netlify/
│   └── functions/
│       ├── buy-item.js
│       ├── equip-item.js
│       ├── get-character.js
│       ├── get-chat.js
│       ├── get-locations.js
│       ├── get-market.js
│       ├── get-players-at-location.js
│       ├── metadata.js
│       ├── mine-action.js
│       ├── render-character.js
│       ├── send-message.js
│       ├── travel-action.js
│       └── use-item.js
├── prisma/
│   ├── schema.prisma
│   └── seed.ts
├── scripts/
│   └── seed-markets.ts
├── src/
│   ├── components/
│   │   ├── ui/
│   │   │   ├── button.tsx
│   │   │   ├── dropdown-menu.tsx
│   │   │   └── sonner.tsx
│   │   ├── mode-toggle.tsx
│   │   └── theme-provider.tsx
│   ├── lib/
│   │   ├── layerResolver.ts
│   │   └── utils.ts
│   ├── types/
│   │   └── index.ts
│   ├── App.css
│   ├── App.tsx
│   ├── index.css
│   ├── main.tsx
│   └── vite-env.d.ts
├── .env
├── .gitignore
├── components.json
├── eslint.config.js
├── index.html
├── package.json
├── README.md
├── TODO.md
├── tsconfig.app.json
├── tsconfig.json
├── tsconfig.node.json
└── vite.config.ts

41 files, 9 directories
  </asciiTree>

  <documents>
    
    <document>
      <source>prisma/seed.ts</source>
      <tags></tags>
      <metadata>
        <size>21139</size>
        <lastModified>2025-05-28T23:49:37.575Z</lastModified>
        <extension>ts</extension>
        <directory>prisma</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

async function main() {
  console.log(&#39;🌱 Starting expanded database seed...&#39;)

  // Clean existing data (optional - remove in production)
  await prisma.chatMessage.deleteMany()
  await prisma.marketListing.deleteMany()
  await prisma.locationResource.deleteMany()
  await prisma.characterInventory.deleteMany()
  await prisma.characterImage.deleteMany()
  await prisma.transaction.deleteMany()
  await prisma.character.deleteMany()
  await prisma.location.deleteMany()
  await prisma.item.deleteMany()

  console.log(&#39;🧹 Cleaned existing data&#39;)

  // Create Items first (same as before)
  const items = await Promise.all([
    // Mining Materials
    prisma.item.create({
      data: {
        name: &#39;Dirty Coal&#39;,
        description: &#39;Basic fuel found in shallow mines&#39;,
        category: &#39;MATERIAL&#39;,
        rarity: &#39;COMMON&#39;,
        imageUrl: &#39;/items/dirty-coal.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Iron Scraps&#39;,
        description: &#39;Rusty metal pieces, still useful&#39;,
        category: &#39;MATERIAL&#39;,
        rarity: &#39;COMMON&#39;,
        imageUrl: &#39;/items/iron-scraps.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Ancient Coin&#39;,
        description: &#39;Currency from a forgotten civilization&#39;,
        category: &#39;MATERIAL&#39;,
        rarity: &#39;RARE&#39;,
        imageUrl: &#39;/items/ancient-coin.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Crystal Shard&#39;,
        description: &#39;Glowing fragment with mysterious properties&#39;,
        category: &#39;MATERIAL&#39;,
        rarity: &#39;EPIC&#39;,
        imageUrl: &#39;/items/crystal-shard.png&#39;,
      },
    }),

    // Equipment
    prisma.item.create({
      data: {
        name: &#39;Miners Hat&#39;,
        description: &#39;Worn leather hat with a dim headlamp&#39;,
        category: &#39;HAT&#39;,
        layerType: &#39;HAT&#39;,
        rarity: &#39;COMMON&#39;,
        durability: 100,
        energyEffect: 5,
        imageUrl: &#39;/items/miners-hat.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Work Gloves&#39;,
        description: &#39;Tough gloves for manual labor&#39;,
        category: &#39;CLOTHING&#39;,
        layerType: &#39;ACCESSORY&#39;,
        rarity: &#39;COMMON&#39;,
        durability: 80,
        imageUrl: &#39;/items/work-gloves.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Lucky Charm&#39;,
        description: &quot;A rabbit&#39;s foot that might bring fortune&quot;,
        category: &#39;ACCESSORY&#39;,
        layerType: &#39;ACCESSORY&#39;,
        rarity: &#39;UNCOMMON&#39;,
        imageUrl: &#39;/items/lucky-charm.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Cyber Jacket&#39;,
        description: &#39;High-tech jacket with built-in displays&#39;,
        category: &#39;CLOTHING&#39;,
        layerType: &#39;CLOTHING&#39;,
        rarity: &#39;RARE&#39;,
        energyEffect: 15,
        imageUrl: &#39;/items/cyber-jacket.png&#39;,
      },
    }),

    // Consumables
    prisma.item.create({
      data: {
        name: &#39;Energy Drink&#39;,
        description: &#39;Restores energy and keeps you alert&#39;,
        category: &#39;CONSUMABLE&#39;,
        rarity: &#39;COMMON&#39;,
        energyEffect: 25,
        imageUrl: &#39;/items/energy-drink.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Health Potion&#39;,
        description: &#39;Mysterious red liquid that heals wounds&#39;,
        category: &#39;CONSUMABLE&#39;,
        rarity: &#39;UNCOMMON&#39;,
        healthEffect: 30,
        imageUrl: &#39;/items/health-potion.png&#39;,
      },
    }),
  ])

  console.log(`✨ Created ${items.length} items`)

  // Create top-level locations (same as before)
  const miningPlains = await prisma.location.create({
    data: {
      name: &#39;Mining Plains&#39;,
      description: &#39;Rich in basic materials and perfect for newcomers&#39;,
      locationType: &#39;REGION&#39;,
      biome: &#39;plains&#39;,
      difficulty: 1,
      playerCount: 8, // Will be updated by actual characters
      lastActive: new Date(Date.now() - 2 * 60 * 1000),
      hasMarket: true,
      hasMining: true,
      hasChat: true,
      chatScope: &#39;REGIONAL&#39;,
      welcomeMessage: &#39;The wind carries the sound of pickaxes striking stone.&#39;,
      lore: &#39;Once a vast battlefield, these plains now serve as the primary mining grounds for new arrivals to Earth.&#39;,
      mapX: 100,
      mapY: 200,
    },
  })

  const desertOutpost = await prisma.location.create({
    data: {
      name: &#39;Desert Outpost&#39;,
      description: &#39;Harsh but rewarding terrain for experienced miners&#39;,
      locationType: &#39;REGION&#39;,
      biome: &#39;desert&#39;,
      difficulty: 3,
      playerCount: 3,
      lastActive: new Date(Date.now() - 12 * 60 * 1000),
      hasMarket: true,
      hasMining: true,
      hasChat: true,
      chatScope: &#39;REGIONAL&#39;,
      welcomeMessage: &#39;The scorching sun beats down mercilessly.&#39;,
      lore: &#39;A remote trading post built around an ancient oasis.&#39;,
      mapX: 400,
      mapY: 100,
    },
  })

  const cyberCity = await prisma.location.create({
    data: {
      name: &#39;Cyber City&#39;,
      description: &#39;The technological heart of wojak civilization&#39;,
      locationType: &#39;CITY&#39;,
      biome: &#39;urban&#39;,
      difficulty: 2,
      playerCount: 12,
      lastActive: new Date(Date.now() - 30 * 1000),
      hasMarket: true,
      hasMining: false,
      hasChat: true,
      chatScope: &#39;LOCAL&#39;,
      welcomeMessage: &#39;Neon lights flicker in the perpetual twilight.&#39;,
      lore: &#39;The beating heart of wojak civilization.&#39;,
      mapX: 300,
      mapY: 300,
    },
  })

  // Create sub-locations
  const rustyPickaxeInn = await prisma.location.create({
    data: {
      name: &#39;Rusty Pickaxe Inn&#39;,
      description: &#39;A cozy tavern where miners share stories and ale&#39;,
      locationType: &#39;BUILDING&#39;,
      parentLocationId: miningPlains.id,
      difficulty: 1,
      playerCount: 4,
      lastActive: new Date(Date.now() - 5 * 60 * 1000),
      hasMarket: true,
      hasMining: false,
      hasChat: true,
      chatScope: &#39;LOCAL&#39;,
      welcomeMessage: &#39;The smell of ale and roasted meat fills the air.&#39;,
    },
  })

  const crystalCaves = await prisma.location.create({
    data: {
      name: &#39;Crystal Caves&#39;,
      description: &#39;Deep underground shafts where rare crystals grow&#39;,
      locationType: &#39;BUILDING&#39;,
      parentLocationId: miningPlains.id,
      difficulty: 2,
      playerCount: 4,
      lastActive: new Date(Date.now() - 1 * 60 * 1000),
      hasMarket: false,
      hasMining: true,
      hasChat: true,
      chatScope: &#39;LOCAL&#39;,
      welcomeMessage: &#39;Crystalline formations sparkle in your torchlight.&#39;,
    },
  })

  const centralExchange = await prisma.location.create({
    data: {
      name: &#39;Central Exchange&#39;,
      description: &#39;The main financial district and trading hub&#39;,
      locationType: &#39;BUILDING&#39;,
      parentLocationId: cyberCity.id,
      difficulty: 2,
      playerCount: 8,
      lastActive: new Date(Date.now() - 2 * 60 * 1000),
      hasMarket: true,
      hasMining: false,
      hasChat: true,
      chatScope: &#39;LOCAL&#39;,
      welcomeMessage:
        &#39;Holographic displays show market prices from across the world.&#39;,
    },
  })

  const glitchClub = await prisma.location.create({
    data: {
      name: &#39;The Glitch Club&#39;,
      description: &#39;Underground social hub for hackers and rebels&#39;,
      locationType: &#39;BUILDING&#39;,
      parentLocationId: cyberCity.id,
      difficulty: 2,
      playerCount: 4,
      lastActive: new Date(Date.now() - 15 * 60 * 1000),
      hasMarket: false,
      hasMining: false,
      hasChat: true,
      chatScope: &#39;LOCAL&#39;,
      welcomeMessage: &#39;Bass-heavy music thumps through the smoky atmosphere.&#39;,
    },
  })

  console.log(&#39;🏘️ Created locations&#39;)

  // 🆕 CREATE DIVERSE CHARACTERS (Our Test Players)
  const characters = await Promise.all([
    // Our main test character
    prisma.character.create({
      data: {
        nftAddress: &#39;DemoNFT123456789&#39;,
        tokenId: &#39;1337&#39;,
        walletAddress: &#39;DemoWallet123456789&#39;,
        name: &#39;Wojak #1337&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: miningPlains.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak.png&#39;,
        energy: 85,
        health: 100,
      },
    }),

    // Mining Plains characters
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT420420420&#39;,
        tokenId: &#39;420&#39;,
        walletAddress: &#39;Wallet420&#39;,
        name: &#39;Wojak #420&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: miningPlains.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-420.png&#39;,
        energy: 95,
        health: 100,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT69696969&#39;,
        tokenId: &#39;69&#39;,
        walletAddress: &#39;Wallet69&#39;,
        name: &#39;Wojak #69&#39;,
        gender: &#39;FEMALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: rustyPickaxeInn.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-69.png&#39;,
        energy: 70,
        health: 100,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT888888&#39;,
        tokenId: &#39;888&#39;,
        walletAddress: &#39;Wallet888&#39;,
        name: &#39;Wojak #888&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: crystalCaves.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-888.png&#39;,
        energy: 45,
        health: 90,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT2077777&#39;,
        tokenId: &#39;2077&#39;,
        walletAddress: &#39;Wallet2077&#39;,
        name: &#39;Wojak #2077&#39;,
        gender: &#39;FEMALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: crystalCaves.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-2077.png&#39;,
        energy: 60,
        health: 85,
      },
    }),

    // Cyber City characters
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT1001001&#39;,
        tokenId: &#39;100&#39;,
        walletAddress: &#39;Wallet100&#39;,
        name: &#39;Wojak #100&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: centralExchange.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-100.png&#39;,
        energy: 80,
        health: 100,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT7777777&#39;,
        tokenId: &#39;777&#39;,
        walletAddress: &#39;Wallet777&#39;,
        name: &#39;Wojak #777&#39;,
        gender: &#39;FEMALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: centralExchange.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-777.png&#39;,
        energy: 90,
        health: 95,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT3333333&#39;,
        tokenId: &#39;333&#39;,
        walletAddress: &#39;Wallet333&#39;,
        name: &#39;Wojak #333&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: glitchClub.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-333.png&#39;,
        energy: 55,
        health: 80,
      },
    }),

    // Desert characters
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT5555555&#39;,
        tokenId: &#39;555&#39;,
        walletAddress: &#39;Wallet555&#39;,
        name: &#39;Wojak #555&#39;,
        gender: &#39;FEMALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: desertOutpost.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-555.png&#39;,
        energy: 40,
        health: 75,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT9999999&#39;,
        tokenId: &#39;999&#39;,
        walletAddress: &#39;Wallet999&#39;,
        name: &#39;Wojak #999&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;CREATURE&#39;,
        currentLocationId: desertOutpost.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-999.png&#39;,
        energy: 85,
        health: 100,
      },
    }),
  ])

  console.log(`👥 Created ${characters.length} characters`)

  // 🆕 CREATE REALISTIC CHAT MESSAGES
  const chatMessages = await Promise.all([
    // Mining Plains chat (regional - shows in main area and sub-locations)
    prisma.chatMessage.create({
      data: {
        locationId: miningPlains.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #420&#39;)!.id,
        message: &#39;Anyone know where the best iron deposits are?&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 3 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: miningPlains.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #1337&#39;)!.id,
        message:
          &#39;Try the eastern slopes, found some good scraps there yesterday&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 2 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: miningPlains.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #420&#39;)!.id,
        message: &#39;Thanks! Heading there now&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 90 * 1000),
      },
    }),

    // Rusty Pickaxe Inn chat (local - cozy tavern conversation)
    prisma.chatMessage.create({
      data: {
        locationId: rustyPickaxeInn.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #69&#39;)!.id,
        message: &#39;This ale tastes like it was brewed in a boot 😂&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 8 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: rustyPickaxeInn.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #420&#39;)!.id,
        message: &#39;Hey, at least it gets you drunk!&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 7 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: rustyPickaxeInn.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #69&#39;)!.id,
        message: &#39;True! Anyone up for some mining stories?&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 6 * 60 * 1000),
      },
    }),

    // Crystal Caves chat (focused on mining)
    prisma.chatMessage.create({
      data: {
        locationId: crystalCaves.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #888&#39;)!.id,
        message: &#39;Whoa! Just found a crystal shard in the deep tunnel!&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 5 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: crystalCaves.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #2077&#39;)!.id,
        message: &#39;Nice! What rarity?&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 4 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: crystalCaves.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #888&#39;)!.id,
        message: &quot;Epic! First one I&#39;ve ever seen&quot;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 3 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: crystalCaves.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #2077&#39;)!.id,
        message: &quot;Damn, I&#39;ve been mining here for weeks with no luck&quot;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 2 * 60 * 1000),
      },
    }),

    // Central Exchange chat (trading focused)
    prisma.chatMessage.create({
      data: {
        locationId: centralExchange.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #100&#39;)!.id,
        message: &#39;WTS: Cyber Jacket, rare quality. Looking for ancient coins&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 15 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: centralExchange.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #777&#39;)!.id,
        message: &#39;How many coins?&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 14 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: centralExchange.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #100&#39;)!.id,
        message: &#39;15 coins, firm price&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 13 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: centralExchange.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #777&#39;)!.id,
        message: &#39;Deal! Meet me at the trade terminal&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 12 * 60 * 1000),
      },
    }),

    // Glitch Club chat (underground vibe)
    prisma.chatMessage.create({
      data: {
        locationId: glitchClub.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #333&#39;)!.id,
        message: &#39;*nods to the beat* This track is fire 🔥&#39;,
        messageType: &#39;EMOTE&#39;,
        createdAt: new Date(Date.now() - 20 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: glitchClub.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #777&#39;)!.id,
        message: &#39;Anyone know who the DJ is tonight?&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 18 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: glitchClub.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #333&#39;)!.id,
        message: &#39;DJ CyberWojak, they drop the sickest beats in the city&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 16 * 60 * 1000),
      },
    }),

    // Desert Outpost chat (survival focused)
    prisma.chatMessage.create({
      data: {
        locationId: desertOutpost.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #555&#39;)!.id,
        message: &#39;Water supplies running low... need to find the oasis&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 25 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: desertOutpost.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #999&#39;)!.id,
        message: &#39;Follow the ancient stone markers, they lead to water&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 23 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: desertOutpost.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #555&#39;)!.id,
        message: &#39;Thanks creature-wojak, you know this desert well&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 22 * 60 * 1000),
      },
    }),

    // System messages
    prisma.chatMessage.create({
      data: {
        locationId: miningPlains.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #420&#39;)!.id,
        message: &#39;Wojak #420 found: Iron Scraps (COMMON)&#39;,
        messageType: &#39;SYSTEM&#39;,
        isSystem: true,
        createdAt: new Date(Date.now() - 10 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: crystalCaves.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #888&#39;)!.id,
        message: &#39;Wojak #888 found: Crystal Shard (EPIC)&#39;,
        messageType: &#39;SYSTEM&#39;,
        isSystem: true,
        createdAt: new Date(Date.now() - 4 * 60 * 1000),
      },
    }),
  ])

  console.log(`💬 Created ${chatMessages.length} chat messages`)

  // Create some sample inventory items
  await Promise.all([
    prisma.characterInventory.create({
      data: {
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #1337&#39;)!.id,
        itemId: items.find((i) =&gt; i.name === &#39;Dirty Coal&#39;)!.id,
        quantity: 3,
      },
    }),
    prisma.characterInventory.create({
      data: {
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #1337&#39;)!.id,
        itemId: items.find((i) =&gt; i.name === &#39;Miners Hat&#39;)!.id,
        quantity: 1,
        isEquipped: true,
      },
    }),
    prisma.characterInventory.create({
      data: {
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #888&#39;)!.id,
        itemId: items.find((i) =&gt; i.name === &#39;Crystal Shard&#39;)!.id,
        quantity: 1,
      },
    }),
  ])

  // Create some location resources
  await Promise.all([
    prisma.locationResource.create({
      data: {
        locationId: miningPlains.id,
        itemId: items.find((i) =&gt; i.name === &#39;Dirty Coal&#39;)!.id,
        spawnRate: 0.6,
        maxPerDay: 20,
        difficulty: 1,
      },
    }),
    prisma.locationResource.create({
      data: {
        locationId: crystalCaves.id,
        itemId: items.find((i) =&gt; i.name === &#39;Crystal Shard&#39;)!.id,
        spawnRate: 0.1,
        maxPerDay: 3,
        difficulty: 3,
      },
    }),
  ])

  console.log(&#39;🎉 Expanded database seed completed successfully!&#39;)
}

main()
  .catch((e) =&gt; {
    console.error(&#39;❌ Enhanced seed failed:&#39;, e)
    process.exit(1)
  })
  .finally(async () =&gt; {
    await prisma.$disconnect()
  })
</content>
    </document>

    <document>
      <source>prisma/schema.prisma</source>
      <tags></tags>
      <metadata>
        <size>7380</size>
        <lastModified>2025-05-28T22:31:59.236Z</lastModified>
        <extension>prisma</extension>
        <directory>prisma</directory>
      </metadata>
      <content>// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = &quot;prisma-client-js&quot;
}

datasource db {
  provider = &quot;postgresql&quot;
  url      = env(&quot;DATABASE_URL&quot;)
}

model Character {
  id            String @id @default(cuid())
  nftAddress    String @unique // Solana NFT address
  tokenId       String @unique // Token ID or mint address
  walletAddress String // Owner&#39;s wallet

  // Character basics
  name          String
  gender        Gender
  characterType CharacterType @default(HUMAN)

  // Current state
  currentLocationId String
  currentLocation   Location @relation(fields: [currentLocationId], references: [id])

  // NFT versioning
  currentVersion  Int     @default(1)
  currentImageUrl String?

  // Game stats
  energy Int @default(100)
  health Int @default(100)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  inventory      CharacterInventory[]
  imageHistory   CharacterImage[]
  transactions   Transaction[]
  marketListings MarketListing[]
  chatMessages   ChatMessage[]

  @@map(&quot;characters&quot;)
}

model Item {
  id          String       @id @default(cuid())
  name        String       @unique
  description String
  category    ItemCategory

  // Visual properties
  layerType LayerType? // which layer this item affects
  imageUrl  String? // item&#39;s image for layering

  // Game properties
  rarity     Rarity @default(COMMON)
  durability Int? // for equipment that degrades

  // Stats effects (optional for MVP)
  energyEffect Int?
  healthEffect Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  characterInventory CharacterInventory[]
  locationResources  LocationResource[]
  marketListings     MarketListing[]

  @@map(&quot;items&quot;)
}

model ChatMessage {
  id          String @id @default(cuid())
  locationId  String
  characterId String

  message     String
  messageType ChatMessageType @default(CHAT)

  // For system messages (player joined, found item, etc.)
  isSystem Boolean @default(false)

  location  Location  @relation(fields: [locationId], references: [id], onDelete: Cascade)
  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@map(&quot;chat_messages&quot;)
}

model Location {
  id          String  @id @default(cuid())
  name        String
  description String
  imageUrl    String?

  // Hierarchy support
  parentLocationId String?
  parentLocation   Location?  @relation(&quot;LocationHierarchy&quot;, fields: [parentLocationId], references: [id])
  subLocations     Location[] @relation(&quot;LocationHierarchy&quot;)

  // Location type
  locationType LocationType @default(REGION) // REGION, CITY, BUILDING, ROOM

  // Location properties
  biome      String? // only for top-level locations
  difficulty Int     @default(1)

  // Map positioning
  mapX Int? // X coordinate on map
  mapY Int? // Y coordinate on map

  // Location stats
  playerCount Int       @default(0) // cached count for performance
  lastActive  DateTime? // when someone last performed an action here

  // Location features
  hasMarket Boolean @default(true)
  hasMining Boolean @default(true)
  hasTravel Boolean @default(true)
  hasChat   Boolean @default(true) // enable chat in this location

  // Chat settings
  chatScope ChatScope @default(LOCAL) // LOCAL (this location only) or REGIONAL (includes parent)

  // Flavor text
  welcomeMessage String? // custom message when entering
  lore           String? // extended description/backstory

  // Entry requirements (optional)
  minLevel  Int? // minimum level to enter
  entryCost Int? // cost in coins to enter
  isPrivate Boolean @default(false) // requires invitation/ownership

  // Available resources for mining
  resources LocationResource[]

  // Characters currently here
  characters Character[]

  // Market items available here
  marketListings MarketListing[]

  // Chat messages in this location
  chatMessages ChatMessage[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, parentLocationId]) // location names must be unique within parent
  @@map(&quot;locations&quot;)
}

model CharacterInventory {
  id          String  @id @default(cuid())
  characterId String
  itemId      String
  quantity    Int     @default(1)
  isEquipped  Boolean @default(false)

  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  item      Item      @relation(fields: [itemId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([characterId, itemId])
  @@map(&quot;character_inventory&quot;)
}

model LocationResource {
  id         String @id @default(cuid())
  locationId String
  itemId     String

  // Mining properties
  spawnRate  Float @default(0.1) // chance per mining attempt
  maxPerDay  Int? // daily limit per character
  difficulty Int   @default(1)

  location Location @relation(fields: [locationId], references: [id], onDelete: Cascade)
  item     Item     @relation(fields: [itemId], references: [id])

  @@unique([locationId, itemId])
  @@map(&quot;location_resources&quot;)
}

model CharacterImage {
  id          String  @id @default(cuid())
  characterId String
  version     Int
  imageUrl    String
  description String? // what changed in this version

  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([characterId, version])
  @@map(&quot;character_images&quot;)
}

model MarketListing {
  id         String  @id @default(cuid())
  sellerId   String? // null for system items
  locationId String
  itemId     String

  price        Int // in game currency or SOL lamports
  quantity     Int     @default(1)
  isSystemItem Boolean @default(false) // true for NPC shop items

  seller   Character? @relation(fields: [sellerId], references: [id])
  location Location   @relation(fields: [locationId], references: [id])
  item     Item       @relation(fields: [itemId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map(&quot;market_listings&quot;)
}

model Transaction {
  id          String          @id @default(cuid())
  characterId String
  type        TransactionType
  itemId      String?
  quantity    Int?
  description String

  character Character @relation(fields: [characterId], references: [id])

  createdAt DateTime @default(now())

  @@map(&quot;transactions&quot;)
}

// Enums
enum Gender {
  MALE
  FEMALE
}

enum CharacterType {
  HUMAN
  CREATURE
}

enum LocationType {
  REGION // Continents, large areas
  CITY // Towns, cities
  BUILDING // Inns, shops, temples
  ROOM // Specific rooms within buildings
}

enum ChatScope {
  LOCAL // Only this specific location
  REGIONAL // This location + parent location
  GLOBAL // Entire game (for special locations)
}

enum ChatMessageType {
  CHAT // Regular player chat
  EMOTE // Player actions (/me waves)
  SYSTEM // System announcements
  WHISPER // Private messages
}

enum ItemCategory {
  CLOTHING
  HAT
  ACCESSORY
  TOOL
  CONSUMABLE
  MATERIAL
}

enum LayerType {
  BACKGROUND
  BASE
  CLOTHING
  HAT
  FACE_COVERING
  ACCESSORY
}

enum Rarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
}

enum TransactionType {
  MINT
  MINE
  BUY
  SELL
  TRAVEL
  EQUIP
  UNEQUIP
}
</content>
    </document>

    <document>
      <source>netlify/functions/render-character.js</source>
      <tags></tags>
      <metadata>
        <size>4859</size>
        <lastModified>2025-05-29T02:46:20.676Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>// netlify/functions/render-character.js
import { PrismaClient } from &#39;@prisma/client&#39;

// For now, let&#39;s create a simple version without Sharp since it might be causing issues
const prisma = new PrismaClient()

// Configuration
const ASSET_BASE_URL = process.env.NODE_ENV === &#39;production&#39;
  ? &#39;https://earth.ndao.computer&#39;
  : process.env.URL || &#39;http://localhost:8888&#39;

/**
 * Generate character layers from database data
 */
function generateCharacterLayers(character) {
  const layers = []

  // Background layer
  const backgroundName = character.currentLocation?.biome || &#39;mining-plains&#39;
  layers.push({
    type: &#39;backgrounds&#39;,
    name: backgroundName,
    url: `${ASSET_BASE_URL}/layers/backgrounds/${backgroundName}.png`,
    visible: true,
    zIndex: 0
  })

  // Base layer
  const baseName = character.gender?.toLowerCase() || &#39;male&#39;
  layers.push({
    type: &#39;bases&#39;,
    name: baseName,
    url: `${ASSET_BASE_URL}/layers/bases/${baseName}.png`,
    visible: true,
    zIndex: 1
  })

  // Equipment layers from inventory
  if (character.inventory) {
    character.inventory
      .filter(inv =&gt; inv.isEquipped)
      .forEach(inv =&gt; {
        const item = inv.item
        let layerType, layerName

        // Map items to layers
        switch (item.category) {
          case &#39;HAT&#39;:
            if (item.name === &#39;Miners Hat&#39;) {
              layerType = &#39;accessories&#39;
              layerName = &#39;miners-hat&#39;
            }
            break
          case &#39;CLOTHING&#39;:
            if (item.name === &#39;Cyber Jacket&#39;) {
              layerType = &#39;clothing&#39;
              layerName = &#39;cyber-jacket&#39;
            } else if (item.name === &#39;Work Gloves&#39;) {
              layerType = &#39;accessories&#39;
              layerName = &#39;work-gloves&#39;
            }
            break
          case &#39;ACCESSORY&#39;:
            if (item.name === &#39;Lucky Charm&#39;) {
              layerType = &#39;accessories&#39;
              layerName = &#39;lucky-charm&#39;
            }
            break
        }

        if (layerType &amp;&amp; layerName) {
          layers.push({
            type: layerType,
            name: layerName,
            url: `${ASSET_BASE_URL}/layers/${layerType}/${layerName}.png`,
            visible: true,
            zIndex: layerType === &#39;clothing&#39; ? 2 : 3
          })
        }
      })
  }

  // Sort by z-index
  return layers.sort((a, b) =&gt; a.zIndex - b.zIndex)
}

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;,
    &#39;Cache-Control&#39;: &#39;public, max-age=3600&#39; // Cache for 1 hour
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    // Extract character ID from path
    const pathParts = event.path.split(&#39;/&#39;)
    const characterParam = pathParts[pathParts.length - 1]
    const characterId = characterParam.replace(&#39;.png&#39;, &#39;&#39;)

    if (!characterId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Character ID required&#39; })
      }
    }

    // Get character data
    let character

    if (characterId === &#39;demo&#39; || characterId === &#39;1337&#39;) {
      // Demo character
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; },
        include: {
          currentLocation: true,
          inventory: {
            where: { isEquipped: true },
            include: { item: true }
          }
        }
      })
    } else {
      // Real character by ID
      character = await prisma.character.findUnique({
        where: { id: characterId },
        include: {
          currentLocation: true,
          inventory: {
            where: { isEquipped: true },
            include: { item: true }
          }
        }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // For now, just return the layer information as JSON until we get Sharp working
    // Generate layers
    const layers = generateCharacterLayers(character)

    return {
      statusCode: 200,
      headers: {
        ...headers,
        &#39;Content-Type&#39;: &#39;application/json&#39;
      },
      body: JSON.stringify({
        character: {
          id: character.id,
          name: character.name,
          location: character.currentLocation?.name
        },
        layers: layers,
        message: &#39;Layer composition ready - PNG rendering coming soon!&#39;
      })
    }

  } catch (error) {
    console.error(&#39;Error rendering character:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Rendering failed&#39;,
        message: error.message
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/get-chat.js</source>
      <tags></tags>
      <metadata>
        <size>4454</size>
        <lastModified>2025-05-28T23:51:59.175Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    const locationId = event.queryStringParameters?.locationId
    const limit = parseInt(event.queryStringParameters?.limit || &#39;50&#39;)

    if (!locationId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Location ID is required&#39; })
      }
    }

    // Get the location to understand chat scope
    const location = await prisma.location.findUnique({
      where: { id: locationId },
      include: {
        parentLocation: true,
        subLocations: true
      }
    })

    if (!location) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Location not found&#39; })
      }
    }

    let chatLocationIds = [locationId]

    // Handle chat scope - REGIONAL chat includes parent and sub-locations
    if (location.chatScope === &#39;REGIONAL&#39;) {
      // If this is a parent location, include all sub-locations
      if (location.subLocations?.length &gt; 0) {
        chatLocationIds.push(...location.subLocations.map(sub =&gt; sub.id))
      }
      // If this is a sub-location, include the parent
      if (location.parentLocationId) {
        chatLocationIds.push(location.parentLocationId)
        // Also include sibling sub-locations
        const siblings = await prisma.location.findMany({
          where: {
            parentLocationId: location.parentLocationId,
            id: { not: locationId }
          }
        })
        chatLocationIds.push(...siblings.map(sib =&gt; sib.id))
      }
    }

    // Get chat messages for the relevant locations
    const messages = await prisma.chatMessage.findMany({
      where: {
        locationId: { in: chatLocationIds }
      },
      include: {
        character: {
          select: {
            id: true,
            name: true,
            characterType: true,
            currentImageUrl: true
          }
        },
        location: {
          select: {
            id: true,
            name: true,
            locationType: true
          }
        }
      },
      orderBy: {
        createdAt: &#39;desc&#39;
      },
      take: limit
    })

    // Transform messages for frontend
    const transformedMessages = messages.reverse().map(msg =&gt; {
      // Calculate time ago
      const timeAgo = getTimeAgo(msg.createdAt)

      return {
        id: msg.id,
        message: msg.message,
        messageType: msg.messageType,
        isSystem: msg.isSystem,
        timeAgo: timeAgo,
        createdAt: msg.createdAt,
        character: msg.isSystem ? null : {
          id: msg.character.id,
          name: msg.character.name,
          characterType: msg.character.characterType,
          imageUrl: msg.character.currentImageUrl
        },
        location: {
          id: msg.location.id,
          name: msg.location.name,
          locationType: msg.location.locationType
        }
      }
    })

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        messages: transformedMessages,
        totalCount: transformedMessages.length,
        locationId: locationId,
        chatScope: location.chatScope,
        locationName: location.name,
        timestamp: new Date().toISOString()
      })
    }

  } catch (error) {
    console.error(&#39;Error fetching chat messages:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to fetch chat messages&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}

// Helper function to calculate time ago
function getTimeAgo(date) {
  const now = new Date()
  const diffInSeconds = Math.floor((now - date) / 1000)

  if (diffInSeconds &lt; 60) {
    return `${diffInSeconds}s ago`
  } else if (diffInSeconds &lt; 3600) {
    const minutes = Math.floor(diffInSeconds / 60)
    return `${minutes}m ago`
  } else if (diffInSeconds &lt; 86400) {
    const hours = Math.floor(diffInSeconds / 3600)
    return `${hours}h ago`
  } else {
    const days = Math.floor(diffInSeconds / 86400)
    return `${days}d ago`
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/get-players-at-location.js</source>
      <tags></tags>
      <metadata>
        <size>2971</size>
        <lastModified>2025-05-28T23:55:02.361Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;,
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return {
      statusCode: 200,
      headers,
      body: &#39;&#39;
    }
  }

  try {
    const locationId = event.queryStringParameters?.locationId

    if (!locationId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Location ID is required&#39; })
      }
    }

    const players = await prisma.character.findMany({
      where: {
        currentLocationId: locationId
      },
      select: {
        id: true,
        name: true,
        gender: true,
        characterType: true,
        energy: true,
        health: true,
        currentImageUrl: true,
        createdAt: true,
        inventory: {
          where: { isEquipped: true },
          include: { item: true }
        }
      },
      orderBy: {
        name: &#39;asc&#39;
      }
    })

    const playersWithStatus = players.map(player =&gt; {
      let status = &#39;Idle&#39;

      if (player.energy &lt; 20) {
        status = &#39;Resting&#39;
      } else if (player.energy &gt; 90) {
        status = &#39;Energetic&#39;
      } else if (player.inventory.some(inv =&gt; inv.item.category === &#39;HAT&#39;)) {
        status = &#39;Mining&#39;
      } else if (player.energy &lt; 50) {
        status = &#39;Tired&#39;
      } else {
        const activities = [&#39;Mining&#39;, &#39;Exploring&#39;, &#39;Trading&#39;, &#39;Chatting&#39;, &#39;Just Arrived&#39;]
        status = activities[Math.floor(Math.random() * activities.length)]
      }

      const daysSinceCreation = Math.floor((Date.now() - player.createdAt.getTime()) / (1000 * 60 * 60 * 24))
      const level = Math.max(1, Math.floor(daysSinceCreation / 7) + Math.floor(Math.random() * 20) + 1)

      return {
        id: player.id,
        name: player.name,
        gender: player.gender,
        characterType: player.characterType,
        level: level,
        energy: player.energy,
        health: player.health,
        status: status,
        currentImageUrl: player.currentImageUrl,
        equippedItems: player.inventory.map(inv =&gt; ({
          name: inv.item.name,
          category: inv.item.category,
          rarity: inv.item.rarity
        }))
      }
    })

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        players: playersWithStatus,
        totalCount: playersWithStatus.length,
        locationId: locationId,
        timestamp: new Date().toISOString()
      })
    }

  } catch (error) {
    console.error(&#39;Error fetching players:&#39;, error)
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to fetch players at location&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/buy-item.js</source>
      <tags></tags>
      <metadata>
        <size>6043</size>
        <lastModified>2025-05-29T03:25:43.591Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const { characterId = &#39;hardcoded-demo&#39;, marketListingId, quantity = 1 } = JSON.parse(event.body || &#39;{}&#39;)

    if (!marketListingId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Market listing ID is required&#39; })
      }
    }

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Get market listing with item details
    const marketListing = await prisma.marketListing.findUnique({
      where: { id: marketListingId },
      include: {
        item: true,
        seller: true,
        location: true
      }
    })

    if (!marketListing) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Market listing not found&#39; })
      }
    }

    // Check if enough quantity available
    if (quantity &gt; marketListing.quantity) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Insufficient quantity&#39;,
          message: `Only ${marketListing.quantity} available, you requested ${quantity}`
        })
      }
    }

    // Calculate total cost
    const totalCost = marketListing.price * quantity

    // For MVP: Skip currency check (assume player has enough)
    // TODO: Implement currency system
    // if (character.coins &lt; totalCost) {
    //   return {
    //     statusCode: 400,
    //     headers,
    //     body: JSON.stringify({
    //       error: &#39;Insufficient funds&#39;,
    //       message: `Item costs ${totalCost} coins, you have ${character.coins}`
    //     })
    //   }
    // }

    // Perform transaction
    const result = await prisma.$transaction(async (tx) =&gt; {
      // Add item to character inventory
      const existingInventory = await tx.characterInventory.findUnique({
        where: {
          characterId_itemId: {
            characterId: character.id,
            itemId: marketListing.itemId
          }
        }
      })

      let inventoryItem
      if (existingInventory) {
        // Update existing inventory
        inventoryItem = await tx.characterInventory.update({
          where: { id: existingInventory.id },
          data: { quantity: existingInventory.quantity + quantity },
          include: { item: true }
        })
      } else {
        // Create new inventory entry
        inventoryItem = await tx.characterInventory.create({
          data: {
            characterId: character.id,
            itemId: marketListing.itemId,
            quantity: quantity
          },
          include: { item: true }
        })
      }

      // Update or remove market listing
      if (marketListing.quantity === quantity &amp;&amp; !marketListing.isSystemItem) {
        // Only remove player listings when sold out
        await tx.marketListing.delete({
          where: { id: marketListingId }
        })
      } else {
        // Reduce quantity (system items can go to 0 but stay in DB)
        await tx.marketListing.update({
          where: { id: marketListingId },
          data: { quantity: marketListing.quantity - quantity }
        })
      }

      // TODO: Handle currency transfer
      // if (!marketListing.isSystemItem &amp;&amp; marketListing.seller) {
      //   // Transfer coins to seller
      //   await tx.character.update({
      //     where: { id: marketListing.sellerId },
      //     data: { coins: { increment: totalCost } }
      //   })
      // }
      // 
      // // Deduct coins from buyer
      // await tx.character.update({
      //   where: { id: character.id },
      //   data: { coins: { decrement: totalCost } }
      // })

      // Log the transaction
      const transaction = await tx.transaction.create({
        data: {
          characterId: character.id,
          type: &#39;BUY&#39;,
          itemId: marketListing.itemId,
          quantity: quantity,
          description: `Bought ${quantity}x ${marketListing.item.name} for ${totalCost} coins from ${marketListing.location.name} market`
        }
      })

      return {
        inventoryItem,
        transaction,
        totalCost,
        remainingQuantity: marketListing.quantity - quantity
      }
    })

    // Prepare response
    const responseData = {
      success: true,
      message: `Successfully purchased ${quantity}x ${marketListing.item.name}!`,
      purchase: {
        itemName: marketListing.item.name,
        itemRarity: marketListing.item.rarity,
        quantity: quantity,
        totalCost: totalCost,
        newInventoryQuantity: result.inventoryItem.quantity
      },
      marketListing: {
        id: marketListingId,
        remainingQuantity: result.remainingQuantity,
        wasRemoved: result.remainingQuantity === 0
      }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error purchasing item:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Purchase failed&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/get-locations.js</source>
      <tags></tags>
      <metadata>
        <size>3256</size>
        <lastModified>2025-05-29T00:12:36.034Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    // Fetch all top-level locations (no parent) with their sub-locations
    const locations = await prisma.location.findMany({
      where: {
        parentLocationId: null // Only top-level locations
      },
      include: {
        subLocations: {
          include: {
            _count: {
              select: {
                characters: true // Count characters in each sub-location
              }
            }
          },
          orderBy: {
            name: &#39;asc&#39;
          }
        },
        _count: {
          select: {
            characters: true // Count characters directly in parent location
          }
        }
      },
      orderBy: {
        difficulty: &#39;asc&#39; // Easier locations first
      }
    })

    // Transform data for frontend with aggregated player counts
    const responseData = locations.map(location =&gt; {
      // Calculate total players: direct + all sub-locations
      const directPlayerCount = location._count.characters
      const subLocationPlayerCount = location.subLocations.reduce((total, subLoc) =&gt; {
        return total + subLoc._count.characters
      }, 0)
      const totalPlayerCount = directPlayerCount + subLocationPlayerCount

      return {
        id: location.id,
        name: location.name,
        description: location.description,
        locationType: location.locationType,
        biome: location.biome,
        difficulty: location.difficulty,
        playerCount: totalPlayerCount, // Aggregated count
        directPlayerCount: directPlayerCount, // Players directly at this location
        lastActive: location.lastActive,
        hasMarket: location.hasMarket,
        hasMining: location.hasMining,
        hasChat: location.hasChat,
        welcomeMessage: location.welcomeMessage,
        lore: location.lore,

        subLocations: location.subLocations.map(subLoc =&gt; ({
          id: subLoc.id,
          name: subLoc.name,
          description: subLoc.description,
          locationType: subLoc.locationType,
          difficulty: subLoc.difficulty,
          playerCount: subLoc._count.characters, // Real player count for sub-location
          hasMarket: subLoc.hasMarket,
          hasMining: subLoc.hasMining,
          hasChat: subLoc.hasChat,
          welcomeMessage: subLoc.welcomeMessage,
          parentLocationId: subLoc.parentLocationId
        }))
      }
    })

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        locations: responseData,
        timestamp: new Date().toISOString()
      })
    }

  } catch (error) {
    console.error(&#39;Error fetching locations:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to fetch locations&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/equip-item.js</source>
      <tags></tags>
      <metadata>
        <size>5153</size>
        <lastModified>2025-05-29T00:03:21.365Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const { characterId = &#39;hardcoded-demo&#39;, inventoryId, equip = true } = JSON.parse(event.body || &#39;{}&#39;)

    if (!inventoryId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Inventory ID is required&#39; })
      }
    }

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Get inventory item with details
    const inventoryItem = await prisma.characterInventory.findUnique({
      where: { id: inventoryId },
      include: { item: true }
    })

    if (!inventoryItem) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Inventory item not found&#39; })
      }
    }

    // Verify ownership
    if (inventoryItem.characterId !== character.id) {
      return {
        statusCode: 403,
        headers,
        body: JSON.stringify({ error: &#39;Item does not belong to this character&#39; })
      }
    }

    // Check if item is equippable
    const equipableCategories = [&#39;HAT&#39;, &#39;CLOTHING&#39;, &#39;ACCESSORY&#39;, &#39;TOOL&#39;]
    if (!equipableCategories.includes(inventoryItem.item.category)) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Item not equippable&#39;,
          message: `${inventoryItem.item.category} items cannot be equipped`
        })
      }
    }

    // Perform equipment action within transaction
    const result = await prisma.$transaction(async (tx) =&gt; {
      if (equip) {
        // If equipping, first unequip any other items of the same layer type
        if (inventoryItem.item.layerType) {
          await tx.characterInventory.updateMany({
            where: {
              characterId: character.id,
              isEquipped: true,
              item: {
                layerType: inventoryItem.item.layerType
              }
            },
            data: { isEquipped: false }
          })
        }

        // Equip the item
        const updatedItem = await tx.characterInventory.update({
          where: { id: inventoryId },
          data: { isEquipped: true },
          include: { item: true }
        })

        // Log the transaction
        await tx.transaction.create({
          data: {
            characterId: character.id,
            type: &#39;EQUIP&#39;,
            itemId: inventoryItem.itemId,
            description: `Equipped ${inventoryItem.item.name}`
          }
        })

        return { action: &#39;equipped&#39;, item: updatedItem }

      } else {
        // Unequip the item
        const updatedItem = await tx.characterInventory.update({
          where: { id: inventoryId },
          data: { isEquipped: false },
          include: { item: true }
        })

        // Log the transaction
        await tx.transaction.create({
          data: {
            characterId: character.id,
            type: &#39;UNEQUIP&#39;,
            itemId: inventoryItem.itemId,
            description: `Unequipped ${inventoryItem.item.name}`
          }
        })

        return { action: &#39;unequipped&#39;, item: updatedItem }
      }
    })

    // Calculate stat effects (for future implementation)
    const statEffects = {
      energy: inventoryItem.item.energyEffect || 0,
      health: inventoryItem.item.healthEffect || 0
    }

    // Prepare response
    const responseData = {
      success: true,
      message: `${inventoryItem.item.name} ${result.action} successfully!`,
      item: {
        id: result.item.id,
        name: result.item.item.name,
        category: result.item.item.category,
        rarity: result.item.item.rarity,
        isEquipped: result.item.isEquipped,
        layerType: result.item.item.layerType
      },
      action: result.action,
      statEffects: equip ? statEffects : { energy: -statEffects.energy, health: -statEffects.health }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error equipping/unequipping item:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Equipment action failed&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/mine-action.js</source>
      <tags></tags>
      <metadata>
        <size>6197</size>
        <lastModified>2025-05-28T23:18:10.417Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const { characterId = &#39;hardcoded-demo&#39;, locationId } = JSON.parse(event.body || &#39;{}&#39;)

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; },
        include: { currentLocation: true }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId },
        include: { currentLocation: true }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Use current location if none specified
    const targetLocationId = locationId || character.currentLocationId

    // Check if character has enough energy
    const ENERGY_COST = 10
    if (character.energy &lt; ENERGY_COST) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Not enough energy&#39;,
          message: `Mining requires ${ENERGY_COST} energy. You have ${character.energy}.`,
          currentEnergy: character.energy,
          required: ENERGY_COST
        })
      }
    }

    // Get location and its available resources
    const location = await prisma.location.findUnique({
      where: { id: targetLocationId },
      include: {
        resources: {
          include: {
            item: true
          }
        }
      }
    })

    if (!location || !location.hasMining) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Cannot mine here&#39;,
          message: &#39;This location does not support mining&#39;
        })
      }
    }

    if (location.resources.length === 0) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;No resources available&#39;,
          message: &#39;This location has no mineable resources&#39;
        })
      }
    }

    // Mining logic - check each resource by spawn rate
    const roll = Math.random()
    let foundResource = null

    // Sort by spawn rate (highest first) for better user experience
    const sortedResources = location.resources.sort((a, b) =&gt; b.spawnRate - a.spawnRate)

    for (const resource of sortedResources) {
      if (roll &lt; resource.spawnRate) {
        foundResource = resource
        break
      }
    }

    // Start transaction to update character and add item
    const result = await prisma.$transaction(async (tx) =&gt; {
      // Reduce character energy
      const updatedCharacter = await tx.character.update({
        where: { id: character.id },
        data: {
          energy: character.energy - ENERGY_COST
        }
      })

      let addedItem = null
      let transaction = null

      if (foundResource) {
        // Check if character already has this item in inventory
        const existingInventory = await tx.characterInventory.findUnique({
          where: {
            characterId_itemId: {
              characterId: character.id,
              itemId: foundResource.itemId
            }
          }
        })

        if (existingInventory) {
          // Update quantity
          addedItem = await tx.characterInventory.update({
            where: { id: existingInventory.id },
            data: { quantity: existingInventory.quantity + 1 },
            include: { item: true }
          })
        } else {
          // Create new inventory entry
          addedItem = await tx.characterInventory.create({
            data: {
              characterId: character.id,
              itemId: foundResource.itemId,
              quantity: 1
            },
            include: { item: true }
          })
        }

        // Log the transaction
        transaction = await tx.transaction.create({
          data: {
            characterId: character.id,
            type: &#39;MINE&#39;,
            itemId: foundResource.itemId,
            quantity: 1,
            description: `Found ${foundResource.item.name} while mining in ${location.name}`
          }
        })
      } else {
        // Log failed mining attempt
        transaction = await tx.transaction.create({
          data: {
            characterId: character.id,
            type: &#39;MINE&#39;,
            description: `Mining attempt in ${location.name} - nothing found`
          }
        })
      }

      return {
        character: updatedCharacter,
        foundItem: addedItem,
        transaction
      }
    })

    // Prepare response
    const responseData = {
      success: true,
      energyUsed: ENERGY_COST,
      newEnergyLevel: result.character.energy,
      location: {
        id: location.id,
        name: location.name
      }
    }

    if (result.foundItem) {
      responseData.foundItem = {
        name: result.foundItem.item.name,
        description: result.foundItem.item.description,
        rarity: result.foundItem.item.rarity,
        imageUrl: result.foundItem.item.imageUrl,
        newQuantity: result.foundItem.quantity
      }
      responseData.message = `You found: ${result.foundItem.item.name} (${result.foundItem.item.rarity})!`
    } else {
      responseData.message = &quot;You dig around but find nothing useful...&quot;
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error during mining:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Mining operation failed&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/use-item.js</source>
      <tags></tags>
      <metadata>
        <size>5806</size>
        <lastModified>2025-05-29T04:02:05.691Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>// netlify/functions/use-item.js
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const { characterId = &#39;hardcoded-demo&#39;, inventoryId } = JSON.parse(event.body || &#39;{}&#39;)

    if (!inventoryId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Inventory ID is required&#39; })
      }
    }

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Get inventory item with details
    const inventoryItem = await prisma.characterInventory.findUnique({
      where: { id: inventoryId },
      include: { item: true }
    })

    if (!inventoryItem) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Inventory item not found&#39; })
      }
    }

    // Verify ownership
    if (inventoryItem.characterId !== character.id) {
      return {
        statusCode: 403,
        headers,
        body: JSON.stringify({ error: &#39;Item does not belong to this character&#39; })
      }
    }

    // Check if item is consumable
    if (inventoryItem.item.category !== &#39;CONSUMABLE&#39;) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Item not consumable&#39;,
          message: `${inventoryItem.item.name} cannot be consumed`
        })
      }
    }

    // Check if there&#39;s quantity to consume
    if (inventoryItem.quantity &lt;= 0) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;No items to use&#39;,
          message: `You don&#39;t have any ${inventoryItem.item.name} to use`
        })
      }
    }

    // Calculate effects (capped at 100)
    const energyEffect = inventoryItem.item.energyEffect || 0
    const healthEffect = inventoryItem.item.healthEffect || 0

    const newEnergy = Math.min(100, character.energy + energyEffect)
    const newHealth = Math.min(100, character.health + healthEffect)

    const actualEnergyGain = newEnergy - character.energy
    const actualHealthGain = newHealth - character.health

    // Check if effects would be wasted
    if (actualEnergyGain === 0 &amp;&amp; actualHealthGain === 0) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;No effect&#39;,
          message: `Using ${inventoryItem.item.name} would have no effect - you&#39;re already at full health and energy`
        })
      }
    }

    // Perform consumption within transaction
    const result = await prisma.$transaction(async (tx) =&gt; {
      // Update character stats
      const updatedCharacter = await tx.character.update({
        where: { id: character.id },
        data: {
          energy: newEnergy,
          health: newHealth
        }
      })

      // Reduce inventory quantity or remove item
      let updatedInventory
      if (inventoryItem.quantity === 1) {
        // Remove item completely
        await tx.characterInventory.delete({
          where: { id: inventoryId }
        })
        updatedInventory = null
      } else {
        // Reduce quantity
        updatedInventory = await tx.characterInventory.update({
          where: { id: inventoryId },
          data: { quantity: inventoryItem.quantity - 1 },
          include: { item: true }
        })
      }

      // Log the transaction
      const transaction = await tx.transaction.create({
        data: {
          characterId: character.id,
          type: &#39;MINE&#39;, // We can add &#39;USE&#39; to the enum later, using MINE for now
          itemId: inventoryItem.itemId,
          quantity: 1,
          description: `Used ${inventoryItem.item.name}${actualEnergyGain &gt; 0 || actualHealthGain &gt; 0 ?
            ` (${[
              actualEnergyGain &gt; 0 ? `+${actualEnergyGain} energy` : null,
              actualHealthGain &gt; 0 ? `+${actualHealthGain} health` : null
            ].filter(Boolean).join(&#39;, &#39;)})` : &#39;&#39;
            }`
        }
      })

      return {
        character: updatedCharacter,
        inventory: updatedInventory,
        transaction,
        effects: {
          energy: actualEnergyGain,
          health: actualHealthGain
        }
      }
    })

    // Prepare response
    const responseData = {
      success: true,
      message: `Used ${inventoryItem.item.name}!`,
      effects: result.effects,
      newStats: {
        energy: result.character.energy,
        health: result.character.health
      },
      inventory: {
        remainingQuantity: result.inventory?.quantity || 0,
        wasRemoved: !result.inventory
      }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error using item:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to use item&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/send-message.js</source>
      <tags></tags>
      <metadata>
        <size>6576</size>
        <lastModified>2025-05-29T00:06:10.082Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const {
      characterId = &#39;hardcoded-demo&#39;,
      locationId,
      message,
      messageType = &#39;CHAT&#39;
    } = JSON.parse(event.body || &#39;{}&#39;)

    if (!locationId || !message?.trim()) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Missing required fields&#39;,
          message: &#39;Location ID and message content are required&#39;
        })
      }
    }

    // Validate message length
    if (message.length &gt; 500) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Message too long&#39;,
          message: &#39;Messages must be 500 characters or less&#39;
        })
      }
    }

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Get location to verify it exists and has chat enabled
    const location = await prisma.location.findUnique({
      where: { id: locationId }
    })

    if (!location) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Location not found&#39; })
      }
    }

    if (!location.hasChat) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Chat not available&#39;,
          message: &#39;This location does not support chat&#39;
        })
      }
    }

    // Verify character is at this location or a related location (for regional chat)
    let canChat = false

    if (character.currentLocationId === locationId) {
      canChat = true
    } else if (location.chatScope === &#39;REGIONAL&#39;) {
      // Check if character is in a sub-location or parent location
      const characterLocation = await prisma.location.findUnique({
        where: { id: character.currentLocationId }
      })

      if (characterLocation) {
        // Check if character&#39;s location is a parent of the chat location
        if (characterLocation.id === location.parentLocationId) {
          canChat = true
        }
        // Check if character&#39;s location has the same parent as chat location
        else if (characterLocation.parentLocationId === location.parentLocationId &amp;&amp; location.parentLocationId) {
          canChat = true
        }
        // Check if chat location is a sub-location of character&#39;s location
        else if (location.parentLocationId === characterLocation.id) {
          canChat = true
        }
      }
    }

    if (!canChat) {
      return {
        statusCode: 403,
        headers,
        body: JSON.stringify({
          error: &#39;Cannot chat here&#39;,
          message: &#39;You must be at this location to participate in chat&#39;
        })
      }
    }

    // Basic content filtering (expand as needed)
    const bannedWords = [&#39;spam&#39;, &#39;scam&#39;, &#39;hack&#39;] // Add more as needed
    const lowercaseMessage = message.toLowerCase()
    const hasBannedWords = bannedWords.some(word =&gt; lowercaseMessage.includes(word))

    if (hasBannedWords) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Message blocked&#39;,
          message: &#39;Your message contains prohibited content&#39;
        })
      }
    }

    // Rate limiting check (simple version)
    const recentMessages = await prisma.chatMessage.findMany({
      where: {
        characterId: character.id,
        createdAt: {
          gte: new Date(Date.now() - 60000) // Last minute
        }
      }
    })

    if (recentMessages.length &gt;= 10) {
      return {
        statusCode: 429,
        headers,
        body: JSON.stringify({
          error: &#39;Rate limited&#39;,
          message: &#39;Please wait before sending another message&#39;
        })
      }
    }

    // Create chat message
    const chatMessage = await prisma.chatMessage.create({
      data: {
        locationId: locationId,
        characterId: character.id,
        message: message.trim(),
        messageType: messageType,
        isSystem: false
      },
      include: {
        character: {
          select: {
            id: true,
            name: true,
            characterType: true,
            currentImageUrl: true
          }
        },
        location: {
          select: {
            id: true,
            name: true,
            locationType: true
          }
        }
      }
    })

    // Update location last active timestamp
    await prisma.location.update({
      where: { id: locationId },
      data: { lastActive: new Date() }
    })

    // Transform message for response
    const transformedMessage = {
      id: chatMessage.id,
      message: chatMessage.message,
      messageType: chatMessage.messageType,
      isSystem: chatMessage.isSystem,
      timeAgo: &#39;now&#39;,
      createdAt: chatMessage.createdAt,
      character: {
        id: chatMessage.character.id,
        name: chatMessage.character.name,
        characterType: chatMessage.character.characterType,
        imageUrl: chatMessage.character.currentImageUrl
      },
      location: {
        id: chatMessage.location.id,
        name: chatMessage.location.name,
        locationType: chatMessage.location.locationType
      }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        success: true,
        message: &#39;Message sent successfully&#39;,
        chatMessage: transformedMessage,
        timestamp: new Date().toISOString()
      })
    }

  } catch (error) {
    console.error(&#39;Error sending message:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to send message&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/travel-action.js</source>
      <tags></tags>
      <metadata>
        <size>5685</size>
        <lastModified>2025-05-28T23:30:33.914Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const { characterId = &#39;hardcoded-demo&#39;, destinationId } = JSON.parse(event.body || &#39;{}&#39;)

    if (!destinationId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Destination ID is required&#39; })
      }
    }

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; },
        include: { currentLocation: true }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId },
        include: { currentLocation: true }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Get destination location
    const destination = await prisma.location.findUnique({
      where: { id: destinationId },
      include: {
        subLocations: true,
        parentLocation: true
      }
    })

    if (!destination) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Destination not found&#39; })
      }
    }

    // Check if already at destination
    if (character.currentLocationId === destinationId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Already at destination&#39;,
          message: `You are already in ${destination.name}`
        })
      }
    }

    // TODO: Future travel requirements check
    // const requirements = getTravelRequirements(character.currentLocation, destination)
    // const canTravel = checkTravelRequirements(character, requirements)
    // if (!canTravel.allowed) {
    //   return { statusCode: 400, body: JSON.stringify({ error: canTravel.reason }) }
    // }

    // For MVP: Instant travel with no cost
    const result = await prisma.$transaction(async (tx) =&gt; {
      // Update character location
      const updatedCharacter = await tx.character.update({
        where: { id: character.id },
        data: {
          currentLocationId: destinationId
        },
        include: {
          currentLocation: true
        }
      })

      // Log the travel transaction
      const transaction = await tx.transaction.create({
        data: {
          characterId: character.id,
          type: &#39;TRAVEL&#39;,
          description: `Traveled from ${character.currentLocation.name} to ${destination.name}`
        }
      })

      // Update player counts (decrement old location, increment new location)
      await tx.location.update({
        where: { id: character.currentLocationId },
        data: {
          playerCount: { decrement: 1 }
        }
      })

      await tx.location.update({
        where: { id: destinationId },
        data: {
          playerCount: { increment: 1 },
          lastActive: new Date()
        }
      })

      return {
        character: updatedCharacter,
        transaction
      }
    })

    // Prepare response
    const responseData = {
      success: true,
      message: `Welcome to ${destination.name}!`,
      newLocation: {
        id: destination.id,
        name: destination.name,
        description: destination.description,
        locationType: destination.locationType,
        biome: destination.biome,
        welcomeMessage: destination.welcomeMessage,
        lore: destination.lore,
        hasMarket: destination.hasMarket,
        hasMining: destination.hasMining,
        hasChat: destination.hasChat
      },
      previousLocation: {
        id: character.currentLocation.id,
        name: character.currentLocation.name
      },
      // Future: costs incurred
      costs: {
        time: 0,      // minutes
        energy: 0,    // energy points
        money: 0,     // SOL
        status: []    // required items used
      }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error during travel:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Travel failed&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}

// Future: Travel requirements calculation
function getTravelRequirements(origin, destination) {
  // Calculate based on:
  // - Distance (map coordinates)
  // - Difficulty difference
  // - Location type (REGION vs BUILDING vs ROOM)
  // - Special requirements per location

  return {
    time: 0,        // Will calculate based on distance/difficulty
    energy: 0,      // Will calculate based on terrain/difficulty  
    money: 0,       // Will be location-specific
    status: []      // Will check location.minLevel, required items, etc.
  }
}

function checkTravelRequirements(character, requirements) {
  // Check if character meets all requirements
  // - Has enough energy
  // - Can afford SOL cost
  // - Has required status items in inventory
  // - Meets level requirements

  return {
    allowed: true,
    reason: null
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/get-market.js</source>
      <tags></tags>
      <metadata>
        <size>6022</size>
        <lastModified>2025-05-29T03:47:50.500Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>// netlify/functions/get-market.js - Updated version
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    const locationId = event.queryStringParameters?.locationId
    const limit = parseInt(event.queryStringParameters?.limit || &#39;20&#39;)

    if (!locationId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Location ID is required&#39; })
      }
    }

    // Get location with parent info
    const location = await prisma.location.findUnique({
      where: { id: locationId },
      include: {
        parentLocation: true
      }
    })

    if (!location) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Location not found&#39; })
      }
    }

    if (!location.hasMarket) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;No market available&#39;,
          message: &#39;This location does not have a market&#39;
        })
      }
    }

    let allMarketListings = []

    // Get local market listings (items specifically at this location)
    const localListings = await prisma.marketListing.findMany({
      where: {
        locationId: locationId
      },
      include: {
        item: true,
        seller: {
          select: {
            id: true,
            name: true,
            characterType: true
          }
        }
      }
    })

    // If this is a child location, also get parent location&#39;s items (global market)
    let globalListings = []
    if (location.parentLocationId) {
      globalListings = await prisma.marketListing.findMany({
        where: {
          locationId: location.parentLocationId
        },
        include: {
          item: true,
          seller: {
            select: {
              id: true,
              name: true,
              characterType: true
            }
          }
        }
      })
    }

    // Combine and mark items appropriately
    const combinedListings = [
      ...localListings.map(listing =&gt; ({ ...listing, isLocalSpecialty: true })),
      ...globalListings.map(listing =&gt; ({ ...listing, isLocalSpecialty: false }))
    ]

    // If no listings exist at all, create some default items
    if (combinedListings.length === 0) {
      // Get some items to create system listings for
      const availableItems = await prisma.item.findMany({
        where: {
          category: {
            in: [&#39;HAT&#39;, &#39;CLOTHING&#39;, &#39;ACCESSORY&#39;, &#39;CONSUMABLE&#39;]
          }
        },
        take: 6
      })

      // Create system market listings
      const systemListings = await Promise.all(
        availableItems.map(item =&gt; {
          // Price based on rarity
          let price = 10
          switch (item.rarity) {
            case &#39;UNCOMMON&#39;: price = 25; break
            case &#39;RARE&#39;: price = 50; break
            case &#39;EPIC&#39;: price = 100; break
            case &#39;LEGENDARY&#39;: price = 250; break
          }

          return prisma.marketListing.create({
            data: {
              locationId: locationId,
              itemId: item.id,
              price: price,
              quantity: item.category === &#39;CONSUMABLE&#39; ? 5 : 1,
              isSystemItem: true
            },
            include: {
              item: true,
              seller: {
                select: {
                  id: true,
                  name: true,
                  characterType: true
                }
              }
            }
          })
        })
      )

      // Use the newly created listings
      allMarketListings = systemListings.map(listing =&gt; ({ ...listing, isLocalSpecialty: true }))
    } else {
      allMarketListings = combinedListings
    }

    // Transform listings for frontend
    const transformedListings = allMarketListings
      .sort((a, b) =&gt; {
        // Sort: local specialties first, then by creation date
        if (a.isLocalSpecialty &amp;&amp; !b.isLocalSpecialty) return -1
        if (!a.isLocalSpecialty &amp;&amp; b.isLocalSpecialty) return 1
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      })
      .slice(0, limit)
      .map(listing =&gt; ({
        id: listing.id,
        price: listing.price,
        quantity: listing.quantity,
        isSystemItem: listing.isSystemItem,
        isLocalSpecialty: listing.isLocalSpecialty,
        seller: listing.seller ? {
          id: listing.seller.id,
          name: listing.seller.name,
          characterType: listing.seller.characterType
        } : null,
        item: {
          id: listing.item.id,
          name: listing.item.name,
          description: listing.item.description,
          category: listing.item.category,
          rarity: listing.item.rarity,
          imageUrl: listing.item.imageUrl,
          layerType: listing.item.layerType,
          energyEffect: listing.item.energyEffect,
          healthEffect: listing.item.healthEffect
        },
        createdAt: listing.createdAt
      }))

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        items: transformedListings,
        totalCount: transformedListings.length,
        locationId: locationId,
        locationName: location.name,
        isChildLocation: !!location.parentLocationId,
        parentLocationName: location.parentLocation?.name,
        timestamp: new Date().toISOString()
      })
    }

  } catch (error) {
    console.error(&#39;Error fetching market items:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to fetch market items&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/get-character.js</source>
      <tags></tags>
      <metadata>
        <size>4642</size>
        <lastModified>2025-05-28T23:17:38.002Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    // For MVP, we&#39;ll use hardcoded character ID
    const characterId = event.queryStringParameters?.characterId || &#39;hardcoded-demo&#39;

    let character

    if (characterId === &#39;hardcoded-demo&#39;) {
      // Return our seeded test character
      character = await prisma.character.findFirst({
        where: {
          name: &quot;Wojak #1337&quot;
        },
        include: {
          currentLocation: true,
          inventory: {
            include: {
              item: true
            }
          },
          imageHistory: {
            orderBy: {
              version: &#39;desc&#39;
            },
            take: 5
          },
          transactions: {
            orderBy: {
              createdAt: &#39;desc&#39;
            },
            take: 10
            // Remove the item include since Transaction doesn&#39;t have a direct relation
          }
        }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId },
        include: {
          currentLocation: true,
          inventory: {
            include: {
              item: true
            }
          },
          imageHistory: {
            orderBy: {
              version: &#39;desc&#39;
            },
            take: 5
          },
          transactions: {
            orderBy: {
              createdAt: &#39;desc&#39;
            },
            take: 10
          }
        }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({
          error: &#39;Character not found&#39;,
          message: &#39;No character exists with the provided ID&#39;
        })
      }
    }

    // For transactions with itemId, we&#39;ll fetch the item separately if needed
    const transactionsWithItems = []
    for (const tx of character.transactions) {
      if (tx.itemId) {
        const item = await prisma.item.findUnique({
          where: { id: tx.itemId }
        })
        transactionsWithItems.push({
          ...tx,
          item: item ? { name: item.name, rarity: item.rarity } : null
        })
      } else {
        transactionsWithItems.push({ ...tx, item: null })
      }
    }

    // Transform the data for frontend consumption
    const responseData = {
      id: character.id,
      name: character.name,
      gender: character.gender,
      characterType: character.characterType,
      energy: character.energy,
      health: character.health,
      currentImageUrl: character.currentImageUrl,
      currentVersion: character.currentVersion,
      nftAddress: character.nftAddress,
      tokenId: character.tokenId,

      currentLocation: {
        id: character.currentLocation.id,
        name: character.currentLocation.name,
        description: character.currentLocation.description,
        locationType: character.currentLocation.locationType,
        biome: character.currentLocation.biome,
        welcomeMessage: character.currentLocation.welcomeMessage
      },

      inventory: character.inventory.map(inv =&gt; ({
        id: inv.id,
        quantity: inv.quantity,
        isEquipped: inv.isEquipped,
        item: {
          id: inv.item.id,
          name: inv.item.name,
          description: inv.item.description,
          category: inv.item.category,
          rarity: inv.item.rarity,
          imageUrl: inv.item.imageUrl,
          layerType: inv.item.layerType
        }
      })),

      imageHistory: character.imageHistory.map(img =&gt; ({
        version: img.version,
        imageUrl: img.imageUrl,
        description: img.description,
        createdAt: img.createdAt
      })),

      recentActivity: transactionsWithItems.map(tx =&gt; ({
        id: tx.id,
        type: tx.type,
        description: tx.description,
        quantity: tx.quantity,
        createdAt: tx.createdAt,
        item: tx.item
      }))
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error fetching character:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to fetch character data&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/metadata.js</source>
      <tags></tags>
      <metadata>
        <size>6861</size>
        <lastModified>2025-05-29T02:46:06.495Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>// netlify/functions/metadata.js
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// Configuration
const ASSET_BASE_URL = process.env.NODE_ENV === &#39;production&#39;
  ? &#39;https://earth.ndao.computer&#39;
  : process.env.URL || &#39;http://localhost:8888&#39;

/**
 * Generate trait attributes from character data
 */
function generateAttributes(character) {
  const attributes = []

  // Basic character traits
  attributes.push({
    trait_type: &quot;Gender&quot;,
    value: character.gender
  })

  attributes.push({
    trait_type: &quot;Character Type&quot;,
    value: character.characterType
  })

  // Location-based traits
  if (character.currentLocation) {
    attributes.push({
      trait_type: &quot;Current Location&quot;,
      value: character.currentLocation.name
    })

    if (character.currentLocation.biome) {
      attributes.push({
        trait_type: &quot;Biome&quot;,
        value: character.currentLocation.biome.charAt(0).toUpperCase() +
          character.currentLocation.biome.slice(1)
      })
    }
  }

  // Equipment traits
  if (character.inventory) {
    const equippedItems = character.inventory.filter(inv =&gt; inv.isEquipped)

    equippedItems.forEach(inv =&gt; {
      const item = inv.item
      attributes.push({
        trait_type: item.category.charAt(0).toUpperCase() +
          item.category.slice(1).toLowerCase(),
        value: item.name
      })
    })

    // Equipment count
    attributes.push({
      trait_type: &quot;Equipped Items&quot;,
      value: equippedItems.length,
      display_type: &quot;number&quot;
    })
  }

  // Stats
  attributes.push({
    trait_type: &quot;Energy&quot;,
    value: character.energy,
    max_value: 100,
    display_type: &quot;boost_percentage&quot;
  })

  attributes.push({
    trait_type: &quot;Health&quot;,
    value: character.health,
    max_value: 100,
    display_type: &quot;boost_percentage&quot;
  })

  // Game progression (could be calculated)
  const daysSinceCreation = Math.floor(
    (Date.now() - new Date(character.createdAt).getTime()) / (1000 * 60 * 60 * 24)
  )

  attributes.push({
    trait_type: &quot;Days Active&quot;,
    value: daysSinceCreation,
    display_type: &quot;number&quot;
  })

  return attributes
}

/**
 * Generate visible layers data
 */
function generateLayerData(character) {
  const layers = []

  // Background
  const backgroundName = character.currentLocation?.biome || &#39;mining-plains&#39;
  layers.push(`${ASSET_BASE_URL}/layers/backgrounds/${backgroundName}.png`)

  // Base
  const baseName = character.gender?.toLowerCase() || &#39;male&#39;
  layers.push(`${ASSET_BASE_URL}/layers/bases/${baseName}.png`)

  // Equipment layers
  if (character.inventory) {
    character.inventory
      .filter(inv =&gt; inv.isEquipped)
      .forEach(inv =&gt; {
        const item = inv.item
        let layerPath

        // Map items to layer paths
        switch (item.name) {
          case &#39;Miners Hat&#39;:
            layerPath = &#39;accessories/miners-hat.png&#39;
            break
          case &#39;Cyber Jacket&#39;:
            layerPath = &#39;clothing/cyber-jacket.png&#39;
            break
          case &#39;Work Gloves&#39;:
            layerPath = &#39;accessories/work-gloves.png&#39;
            break
          case &#39;Lucky Charm&#39;:
            layerPath = &#39;accessories/lucky-charm.png&#39;
            break
          // Add more mappings as needed
        }

        if (layerPath) {
          layers.push(`${ASSET_BASE_URL}/layers/${layerPath}`)
        }
      })
  }

  return layers
}

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;,
    &#39;Content-Type&#39;: &#39;application/json&#39;,
    &#39;Cache-Control&#39;: &#39;public, max-age=1800&#39; // Cache for 30 minutes
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    // Extract token ID from path
    const pathParts = event.path.split(&#39;/&#39;)
    const tokenId = pathParts[pathParts.length - 1]

    if (!tokenId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Token ID required&#39; })
      }
    }

    // Get character data
    let character

    if (tokenId === &#39;demo&#39; || tokenId === &#39;1337&#39;) {
      // Demo character
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; },
        include: {
          currentLocation: true,
          inventory: {
            where: { isEquipped: true },
            include: { item: true }
          }
        }
      })
    } else {
      // Try to find by tokenId first, then by ID
      character = await prisma.character.findFirst({
        where: {
          OR: [
            { tokenId: tokenId },
            { id: tokenId }
          ]
        },
        include: {
          currentLocation: true,
          inventory: {
            where: { isEquipped: true },
            include: { item: true }
          }
        }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Generate metadata
    const metadata = {
      name: character.name,
      description: `${character.name} is a ${character.characterType.toLowerCase()} explorer currently in ${character.currentLocation?.name || &#39;Unknown Location&#39;}. Energy: ${character.energy}/100, Health: ${character.health}/100.`,
      image: `${ASSET_BASE_URL}/.netlify/functions/render-character/${character.tokenId || character.id}.png`,
      external_url: `${ASSET_BASE_URL}/character/${character.tokenId || character.id}`,

      // Standard NFT metadata
      attributes: generateAttributes(character),

      // Wojak Earth specific data
      wojak_earth: {
        character_id: character.id,
        token_id: character.tokenId,
        nft_address: character.nftAddress,
        current_location: {
          id: character.currentLocation?.id,
          name: character.currentLocation?.name,
          type: character.currentLocation?.locationType,
          biome: character.currentLocation?.biome
        },
        stats: {
          energy: character.energy,
          health: character.health,
          level: Math.floor((Date.now() - new Date(character.createdAt).getTime()) / (1000 * 60 * 60 * 24 * 7)) + 1 // Rough level calculation
        },
        assets: {
          layers: generateLayerData(character),
          last_updated: new Date().toISOString()
        }
      }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(metadata, null, 2)
    }

  } catch (error) {
    console.error(&#39;Error generating metadata:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Metadata generation failed&#39;,
        message: error.message
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>scripts/seed-markets.ts</source>
      <tags></tags>
      <metadata>
        <size>5138</size>
        <lastModified>2025-05-29T03:26:59.031Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/seed-markets.ts
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// Market configurations per location
const MARKET_CONFIGS = {
  &#39;Mining Plains&#39;: {
    items: [
      { name: &#39;Miners Hat&#39;, quantity: 10, price: 15 },
      { name: &#39;Work Gloves&#39;, quantity: 8, price: 12 },
      { name: &#39;Energy Drink&#39;, quantity: 20, price: 8 },
      { name: &#39;Dirty Coal&#39;, quantity: 50, price: 2 },
      { name: &#39;Iron Scraps&#39;, quantity: 25, price: 5 },
    ],
  },
  &#39;Central Exchange&#39;: {
    items: [
      { name: &#39;Cyber Jacket&#39;, quantity: 3, price: 75 },
      { name: &#39;Lucky Charm&#39;, quantity: 5, price: 30 },
      { name: &#39;Health Potion&#39;, quantity: 15, price: 25 },
      { name: &#39;Energy Drink&#39;, quantity: 25, price: 10 },
      { name: &#39;Ancient Coin&#39;, quantity: 8, price: 100 },
    ],
  },
  &#39;Desert Outpost&#39;: {
    items: [
      { name: &#39;Work Gloves&#39;, quantity: 6, price: 18 },
      { name: &#39;Energy Drink&#39;, quantity: 12, price: 15 }, // Higher prices in remote areas
      { name: &#39;Health Potion&#39;, quantity: 8, price: 35 },
      { name: &#39;Crystal Shard&#39;, quantity: 2, price: 200 },
    ],
  },
}

async function seedMarkets() {
  console.log(&#39;🏪 Starting market seed...&#39;)

  try {
    // Get all locations and items for reference
    const locations = await prisma.location.findMany({
      where: { hasMarket: true },
    })

    const items = await prisma.item.findMany()
    const itemMap = new Map(items.map((item) =&gt; [item.name, item]))

    for (const location of locations) {
      const config =
        MARKET_CONFIGS[location.name as keyof typeof MARKET_CONFIGS]

      if (!config) {
        console.log(`⚠️  No market config for ${location.name}, skipping...`)
        continue
      }

      console.log(`\n🏪 Restocking ${location.name}...`)

      for (const itemConfig of config.items) {
        const item = itemMap.get(itemConfig.name)

        if (!item) {
          console.log(`  ❌ Item &#39;${itemConfig.name}&#39; not found in database`)
          continue
        }

        // Check if listing already exists
        const existingListing = await prisma.marketListing.findFirst({
          where: {
            locationId: location.id,
            itemId: item.id,
            isSystemItem: true,
          },
        })

        if (existingListing) {
          // Update existing listing
          await prisma.marketListing.update({
            where: { id: existingListing.id },
            data: {
              quantity: itemConfig.quantity,
              price: itemConfig.price,
            },
          })
          console.log(
            `  🔄 Updated ${itemConfig.name}: ${itemConfig.quantity} @ ${itemConfig.price} coins`
          )
        } else {
          // Create new listing
          await prisma.marketListing.create({
            data: {
              locationId: location.id,
              itemId: item.id,
              quantity: itemConfig.quantity,
              price: itemConfig.price,
              isSystemItem: true,
            },
          })
          console.log(
            `  ✨ Added ${itemConfig.name}: ${itemConfig.quantity} @ ${itemConfig.price} coins`
          )
        }
      }
    }

    console.log(&#39;\n🎉 Market seed completed successfully!&#39;)

    // Show summary
    const totalListings = await prisma.marketListing.count({
      where: { isSystemItem: true },
    })
    console.log(`📊 Total system market listings: ${totalListings}`)
  } catch (error) {
    console.error(&#39;❌ Market seed failed:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

// Command line options
const args = process.argv.slice(2)

if (args.includes(&#39;--help&#39;) || args.includes(&#39;-h&#39;)) {
  console.log(`
🏪 Market Listing Seed Script

Usage:
  npm run seed:markets              # Restock all markets
  npm run seed:markets --clear      # Clear all system listings first
  npm run seed:markets --location &quot;Central Exchange&quot;  # Restock specific location

Options:
  --clear                           Clear all system listings before restocking
  --location &lt;name&gt;                 Only restock specific location
  --help, -h                        Show this help message
`)
  process.exit(0)
}

// Handle clear option
if (args.includes(&#39;--clear&#39;)) {
  console.log(&#39;🧹 Clearing existing system market listings...&#39;)
  await prisma.marketListing.deleteMany({
    where: { isSystemItem: true },
  })
  console.log(&#39;✅ Cleared all system listings&#39;)
}

// Handle specific location
const locationArg = args.indexOf(&#39;--location&#39;)
if (locationArg !== -1 &amp;&amp; args[locationArg + 1]) {
  const targetLocation = args[locationArg + 1]
  console.log(`🎯 Targeting specific location: ${targetLocation}`)

  // Filter MARKET_CONFIGS to only include the target location
  const filteredConfig = {
    [targetLocation]:
      MARKET_CONFIGS[targetLocation as keyof typeof MARKET_CONFIGS],
  }
  Object.assign(MARKET_CONFIGS, filteredConfig)

  // Clear all other configs
  for (const key in MARKET_CONFIGS) {
    if (key !== targetLocation) {
      delete MARKET_CONFIGS[key as keyof typeof MARKET_CONFIGS]
    }
  }
}

// Run the seed
seedMarkets()
</content>
    </document>

    <document>
      <source>src/types/index.ts</source>
      <tags></tags>
      <metadata>
        <size>2110</size>
        <lastModified>2025-05-29T04:19:34.818Z</lastModified>
        <extension>ts</extension>
        <directory>src/types</directory>
      </metadata>
      <content>// src/types/index.ts
export type GameView =
  | &#39;main&#39;
  | &#39;map&#39;
  | &#39;location&#39;
  | &#39;mine&#39;
  | &#39;market&#39;
  | &#39;inventory&#39;
  | &#39;chat&#39;

export interface Character {
  id: string
  name: string
  gender: string
  energy: number
  health: number
  currentImageUrl: string
  currentLocation: {
    id: string
    name: string
    description: string
    locationType: string
    biome?: string
    welcomeMessage?: string
  }
  inventory: Array&lt;{
    id: string
    quantity: number
    isEquipped: boolean
    item: {
      id: string
      name: string
      description: string
      category: string
      rarity: string
      imageUrl?: string
      energyEffect?: number
      healthEffect?: number
    }
  }&gt;
  recentActivity: Array&lt;{
    id: string
    type: string
    description: string
    item?: {
      name: string
      rarity: string
    }
  }&gt;
}

export interface Location {
  id: string
  name: string
  description: string
  locationType: string
  biome?: string
  difficulty: number
  playerCount: number
  lastActive?: string
  hasMarket: boolean
  hasMining: boolean
  hasChat: boolean
  welcomeMessage?: string
  lore?: string
  subLocations?: Location[]
}

export interface MarketItem {
  id: string
  price: number
  quantity: number
  isSystemItem: boolean
  isLocalSpecialty?: boolean
  seller?: {
    id: string
    name: string
  }
  item: {
    id: string
    name: string
    description: string
    category: string
    rarity: string
    imageUrl?: string
  }
}

export interface ChatMessage {
  id: string
  message: string
  messageType: &#39;CHAT&#39; | &#39;EMOTE&#39; | &#39;SYSTEM&#39;
  isSystem: boolean
  timeAgo: string
  createdAt: string
  character?: {
    id: string
    name: string
    characterType: string
    imageUrl?: string
  }
  location: {
    id: string
    name: string
    locationType: string
  }
}

export interface Player {
  id: string
  name: string
  gender: string
  characterType: string
  level: number
  energy: number
  health: number
  status: string
  currentImageUrl?: string
  equippedItems: Array&lt;{
    name: string
    category: string
    rarity: string
  }&gt;
}
</content>
    </document>

    <document>
      <source>src/components/ui/sonner.tsx</source>
      <tags></tags>
      <metadata>
        <size>550</size>
        <lastModified>2025-05-29T04:08:24.041Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import { useTheme } from &quot;next-themes&quot;
import { Toaster as Sonner, ToasterProps } from &quot;sonner&quot;

const Toaster = ({ ...props }: ToasterProps) =&gt; {
  const { theme = &quot;system&quot; } = useTheme()

  return (
    &lt;Sonner
      theme={theme as ToasterProps[&quot;theme&quot;]}
      className=&quot;toaster group&quot;
      style={
        {
          &quot;--normal-bg&quot;: &quot;var(--popover)&quot;,
          &quot;--normal-text&quot;: &quot;var(--popover-foreground)&quot;,
          &quot;--normal-border&quot;: &quot;var(--border)&quot;,
        } as React.CSSProperties
      }
      {...props}
    /&gt;
  )
}

export { Toaster }
</content>
    </document>

    <document>
      <source>src/components/ui/dropdown-menu.tsx</source>
      <tags></tags>
      <metadata>
        <size>8270</size>
        <lastModified>2025-05-29T00:35:27.082Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as DropdownMenuPrimitive from &quot;@radix-ui/react-dropdown-menu&quot;
import { CheckIcon, ChevronRightIcon, CircleIcon } from &quot;lucide-react&quot;

import { cn } from &quot;@/lib/utils&quot;

function DropdownMenu({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Root&gt;) {
  return &lt;DropdownMenuPrimitive.Root data-slot=&quot;dropdown-menu&quot; {...props} /&gt;
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Portal&gt;) {
  return (
    &lt;DropdownMenuPrimitive.Portal data-slot=&quot;dropdown-menu-portal&quot; {...props} /&gt;
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Trigger&gt;) {
  return (
    &lt;DropdownMenuPrimitive.Trigger
      data-slot=&quot;dropdown-menu-trigger&quot;
      {...props}
    /&gt;
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Content&gt;) {
  return (
    &lt;DropdownMenuPrimitive.Portal&gt;
      &lt;DropdownMenuPrimitive.Content
        data-slot=&quot;dropdown-menu-content&quot;
        sideOffset={sideOffset}
        className={cn(
          &quot;bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md&quot;,
          className
        )}
        {...props}
      /&gt;
    &lt;/DropdownMenuPrimitive.Portal&gt;
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Group&gt;) {
  return (
    &lt;DropdownMenuPrimitive.Group data-slot=&quot;dropdown-menu-group&quot; {...props} /&gt;
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = &quot;default&quot;,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Item&gt; &amp; {
  inset?: boolean
  variant?: &quot;default&quot; | &quot;destructive&quot;
}) {
  return (
    &lt;DropdownMenuPrimitive.Item
      data-slot=&quot;dropdown-menu-item&quot;
      data-inset={inset}
      data-variant={variant}
      className={cn(
        &quot;focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&amp;_svg:not([class*=&#39;text-&#39;])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.CheckboxItem&gt;) {
  return (
    &lt;DropdownMenuPrimitive.CheckboxItem
      data-slot=&quot;dropdown-menu-checkbox-item&quot;
      className={cn(
        &quot;focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4&quot;,
        className
      )}
      checked={checked}
      {...props}
    &gt;
      &lt;span className=&quot;pointer-events-none absolute left-2 flex size-3.5 items-center justify-center&quot;&gt;
        &lt;DropdownMenuPrimitive.ItemIndicator&gt;
          &lt;CheckIcon className=&quot;size-4&quot; /&gt;
        &lt;/DropdownMenuPrimitive.ItemIndicator&gt;
      &lt;/span&gt;
      {children}
    &lt;/DropdownMenuPrimitive.CheckboxItem&gt;
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.RadioGroup&gt;) {
  return (
    &lt;DropdownMenuPrimitive.RadioGroup
      data-slot=&quot;dropdown-menu-radio-group&quot;
      {...props}
    /&gt;
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.RadioItem&gt;) {
  return (
    &lt;DropdownMenuPrimitive.RadioItem
      data-slot=&quot;dropdown-menu-radio-item&quot;
      className={cn(
        &quot;focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4&quot;,
        className
      )}
      {...props}
    &gt;
      &lt;span className=&quot;pointer-events-none absolute left-2 flex size-3.5 items-center justify-center&quot;&gt;
        &lt;DropdownMenuPrimitive.ItemIndicator&gt;
          &lt;CircleIcon className=&quot;size-2 fill-current&quot; /&gt;
        &lt;/DropdownMenuPrimitive.ItemIndicator&gt;
      &lt;/span&gt;
      {children}
    &lt;/DropdownMenuPrimitive.RadioItem&gt;
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Label&gt; &amp; {
  inset?: boolean
}) {
  return (
    &lt;DropdownMenuPrimitive.Label
      data-slot=&quot;dropdown-menu-label&quot;
      data-inset={inset}
      className={cn(
        &quot;px-2 py-1.5 text-sm font-medium data-[inset]:pl-8&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Separator&gt;) {
  return (
    &lt;DropdownMenuPrimitive.Separator
      data-slot=&quot;dropdown-menu-separator&quot;
      className={cn(&quot;bg-border -mx-1 my-1 h-px&quot;, className)}
      {...props}
    /&gt;
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps&lt;&quot;span&quot;&gt;) {
  return (
    &lt;span
      data-slot=&quot;dropdown-menu-shortcut&quot;
      className={cn(
        &quot;text-muted-foreground ml-auto text-xs tracking-widest&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Sub&gt;) {
  return &lt;DropdownMenuPrimitive.Sub data-slot=&quot;dropdown-menu-sub&quot; {...props} /&gt;
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.SubTrigger&gt; &amp; {
  inset?: boolean
}) {
  return (
    &lt;DropdownMenuPrimitive.SubTrigger
      data-slot=&quot;dropdown-menu-sub-trigger&quot;
      data-inset={inset}
      className={cn(
        &quot;focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8&quot;,
        className
      )}
      {...props}
    &gt;
      {children}
      &lt;ChevronRightIcon className=&quot;ml-auto size-4&quot; /&gt;
    &lt;/DropdownMenuPrimitive.SubTrigger&gt;
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.SubContent&gt;) {
  return (
    &lt;DropdownMenuPrimitive.SubContent
      data-slot=&quot;dropdown-menu-sub-content&quot;
      className={cn(
        &quot;bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</content>
    </document>

    <document>
      <source>src/components/ui/button.tsx</source>
      <tags></tags>
      <metadata>
        <size>2123</size>
        <lastModified>2025-05-28T21:47:16.145Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import { Slot } from &quot;@radix-ui/react-slot&quot;
import { cva, type VariantProps } from &quot;class-variance-authority&quot;

import { cn } from &quot;@/lib/utils&quot;

const buttonVariants = cva(
  &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive&quot;,
  {
    variants: {
      variant: {
        default:
          &quot;bg-primary text-primary-foreground shadow-xs hover:bg-primary/90&quot;,
        destructive:
          &quot;bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60&quot;,
        outline:
          &quot;border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50&quot;,
        secondary:
          &quot;bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80&quot;,
        ghost:
          &quot;hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50&quot;,
        link: &quot;text-primary underline-offset-4 hover:underline&quot;,
      },
      size: {
        default: &quot;h-9 px-4 py-2 has-[&gt;svg]:px-3&quot;,
        sm: &quot;h-8 rounded-md gap-1.5 px-3 has-[&gt;svg]:px-2.5&quot;,
        lg: &quot;h-10 rounded-md px-6 has-[&gt;svg]:px-4&quot;,
        icon: &quot;size-9&quot;,
      },
    },
    defaultVariants: {
      variant: &quot;default&quot;,
      size: &quot;default&quot;,
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps&lt;&quot;button&quot;&gt; &amp;
  VariantProps&lt;typeof buttonVariants&gt; &amp; {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : &quot;button&quot;

  return (
    &lt;Comp
      data-slot=&quot;button&quot;
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    /&gt;
  )
}

export { Button, buttonVariants }
</content>
    </document>

    <document>
      <source>src/components/theme-provider.tsx</source>
      <tags></tags>
      <metadata>
        <size>1578</size>
        <lastModified>2025-05-29T00:31:34.688Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>import { createContext, useContext, useEffect, useState } from &quot;react&quot;

type Theme = &quot;dark&quot; | &quot;light&quot; | &quot;system&quot;

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  storageKey?: string
}

type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) =&gt; void
}

const initialState: ThemeProviderState = {
  theme: &quot;system&quot;,
  setTheme: () =&gt; null,
}

const ThemeProviderContext = createContext&lt;ThemeProviderState&gt;(initialState)

export function ThemeProvider({
  children,
  defaultTheme = &quot;system&quot;,
  storageKey = &quot;vite-ui-theme&quot;,
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState&lt;Theme&gt;(
    () =&gt; (localStorage.getItem(storageKey) as Theme) || defaultTheme
  )

  useEffect(() =&gt; {
    const root = window.document.documentElement

    root.classList.remove(&quot;light&quot;, &quot;dark&quot;)

    if (theme === &quot;system&quot;) {
      const systemTheme = window.matchMedia(&quot;(prefers-color-scheme: dark)&quot;)
        .matches
        ? &quot;dark&quot;
        : &quot;light&quot;

      root.classList.add(systemTheme)
      return
    }

    root.classList.add(theme)
  }, [theme])

  const value = {
    theme,
    setTheme: (theme: Theme) =&gt; {
      localStorage.setItem(storageKey, theme)
      setTheme(theme)
    },
  }

  return (
    &lt;ThemeProviderContext.Provider {...props} value={value}&gt;
      {children}
    &lt;/ThemeProviderContext.Provider&gt;
  )
}

export const useTheme = () =&gt; {
  const context = useContext(ThemeProviderContext)

  if (context === undefined)
    throw new Error(&quot;useTheme must be used within a ThemeProvider&quot;)

  return context
}
</content>
    </document>

    <document>
      <source>src/components/mode-toggle.tsx</source>
      <tags></tags>
      <metadata>
        <size>1207</size>
        <lastModified>2025-05-29T00:32:40.806Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>import { Moon, Sun } from &quot;lucide-react&quot;

import { Button } from &quot;@/components/ui/button&quot;
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from &quot;@/components/ui/dropdown-menu&quot;
import { useTheme } from &quot;@/components/theme-provider&quot;

export function ModeToggle() {
  const { setTheme } = useTheme()

  return (
    &lt;DropdownMenu&gt;
      &lt;DropdownMenuTrigger asChild&gt;
        &lt;Button variant=&quot;outline&quot; size=&quot;icon&quot;&gt;
          &lt;Sun className=&quot;h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0&quot; /&gt;
          &lt;Moon className=&quot;absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100&quot; /&gt;
          &lt;span className=&quot;sr-only&quot;&gt;Toggle theme&lt;/span&gt;
        &lt;/Button&gt;
      &lt;/DropdownMenuTrigger&gt;
      &lt;DropdownMenuContent align=&quot;end&quot;&gt;
        &lt;DropdownMenuItem onClick={() =&gt; setTheme(&quot;light&quot;)}&gt;
          Light
        &lt;/DropdownMenuItem&gt;
        &lt;DropdownMenuItem onClick={() =&gt; setTheme(&quot;dark&quot;)}&gt;
          Dark
        &lt;/DropdownMenuItem&gt;
        &lt;DropdownMenuItem onClick={() =&gt; setTheme(&quot;system&quot;)}&gt;
          System
        &lt;/DropdownMenuItem&gt;
      &lt;/DropdownMenuContent&gt;
    &lt;/DropdownMenu&gt;
  )
}
</content>
    </document>

    <document>
      <source>src/lib/utils.ts</source>
      <tags></tags>
      <metadata>
        <size>166</size>
        <lastModified>2025-05-28T21:46:49.754Z</lastModified>
        <extension>ts</extension>
        <directory>src/lib</directory>
      </metadata>
      <content>import { clsx, type ClassValue } from &quot;clsx&quot;
import { twMerge } from &quot;tailwind-merge&quot;

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</content>
    </document>

    <document>
      <source>src/lib/layerResolver.ts</source>
      <tags></tags>
      <metadata>
        <size>8697</size>
        <lastModified>2025-05-29T02:27:27.011Z</lastModified>
        <extension>ts</extension>
        <directory>src/lib</directory>
      </metadata>
      <content>// src/utils/layerResolver.ts
export interface LayerConfig {
  type: &#39;background&#39; | &#39;base&#39; | &#39;clothing&#39; | &#39;accessory&#39; | &#39;overlay&#39;
  name: string
  zIndex: number
  visible: boolean
}

export interface VisibilityRules {
  [key: string]: {
    blocks?: string[] // What this layer blocks
    blockedBy?: string[] // What blocks this layer
    requires?: string[] // What this layer requires to be visible
  }
}

// Asset URL resolver
export function getAssetUrl(type: string, name: string): string {
  return `https://earth.ndao.computer/layers/${type}s/${name}.png`
}

// Layer visibility rules - customize based on your game logic
export const LAYER_VISIBILITY_RULES: VisibilityRules = {
  // Clothing rules
  &#39;cyber-jacket&#39;: {
    blocks: [&#39;parka-yellow&#39;, &#39;miners-jacket&#39;], // Can&#39;t wear multiple jackets
    blockedBy: [],
  },
  &#39;parka-yellow&#39;: {
    blocks: [&#39;cyber-jacket&#39;, &#39;miners-jacket&#39;],
    blockedBy: [],
  },
  &#39;miners-jacket&#39;: {
    blocks: [&#39;cyber-jacket&#39;, &#39;parka-yellow&#39;],
    blockedBy: [],
  },

  // Accessory rules
  sunglasses: {
    blocks: [], // Sunglasses don&#39;t block other accessories
    blockedBy: [],
  },
  &#39;gold-chain&#39;: {
    blocks: [],
    blockedBy: [],
  },
  &#39;lucky-charm&#39;: {
    blocks: [],
    blockedBy: [],
  },

  // Overlay rules
  &#39;glow-red&#39;: {
    blocks: [&#39;rain-fog&#39;], // Glow effects might override weather
    blockedBy: [],
  },
  &#39;rain-fog&#39;: {
    blocks: [],
    blockedBy: [&#39;glow-red&#39;],
  },
  &#39;glitch-vibe&#39;: {
    blocks: [],
    blockedBy: [],
  },
}

// Resolve which layers should be visible based on equipped items and rules
export function resolveVisibleLayers(character: {
  gender: string
  characterType: string
  currentLocation: { biome?: string; name: string }
  inventory: Array&lt;{
    item: {
      name: string
      category: string
      layerType?: string
    }
    isEquipped: boolean
  }&gt;
}): LayerConfig[] {
  const layers: LayerConfig[] = []

  // 1. Add background based on location
  const backgroundName = getBackgroundForLocation(character.currentLocation)
  if (backgroundName) {
    layers.push({
      type: &#39;background&#39;,
      name: backgroundName,
      zIndex: 0,
      visible: true,
    })
  }

  // 2. Add base layer based on character type and gender
  const baseName = getBaseForCharacter(character)
  layers.push({
    type: &#39;base&#39;,
    name: baseName,
    zIndex: 1,
    visible: true,
  })

  // 3. Add equipped items as layers
  const equippedItems = character.inventory.filter((inv) =&gt; inv.isEquipped)

  equippedItems.forEach((inv) =&gt; {
    const layerType = mapCategoryToLayerType(inv.item.category)
    const layerName = kebabCase(inv.item.name)

    if (layerType) {
      layers.push({
        type: layerType,
        name: layerName,
        zIndex: getZIndexForLayerType(layerType),
        visible: true, // Will be resolved in visibility step
      })
    }
  })

  // 4. Add contextual overlays (weather, effects, etc.)
  const overlays = getContextualOverlays(character)
  overlays.forEach((overlay) =&gt; {
    layers.push({
      type: &#39;overlay&#39;,
      name: overlay,
      zIndex: 10,
      visible: true,
    })
  })

  // 5. Apply visibility rules
  return applyVisibilityRules(layers)
}

// Helper functions
function getBackgroundForLocation(location: {
  biome?: string
  name: string
}): string | null {
  // Map location biomes to background images
  const biomeMap: { [key: string]: string } = {
    plains: &#39;mining-plains&#39;,
    desert: &#39;desert-outpost&#39;,
    urban: &#39;cyber-city&#39;,
  }

  return location.biome ? biomeMap[location.biome] || null : null
}

function getBaseForCharacter(character: {
  gender: string
  characterType: string
}): string {
  if (character.characterType === &#39;CREATURE&#39;) {
    return &#39;creature&#39;
  }
  return character.gender.toLowerCase() // &#39;male&#39; or &#39;female&#39;
}

function mapCategoryToLayerType(category: string): LayerConfig[&#39;type&#39;] | null {
  const categoryMap: { [key: string]: LayerConfig[&#39;type&#39;] } = {
    CLOTHING: &#39;clothing&#39;,
    HAT: &#39;clothing&#39;, // Hats go in clothing layer
    ACCESSORY: &#39;accessory&#39;,
    TOOL: &#39;accessory&#39;, // Tools as accessories for now
  }

  return categoryMap[category] || null
}

function getZIndexForLayerType(type: LayerConfig[&#39;type&#39;]): number {
  const zIndexMap = {
    background: 0,
    base: 1,
    clothing: 2,
    accessory: 3,
    overlay: 10,
  }
  return zIndexMap[type]
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getContextualOverlays(character: any): string[] {
  const overlays: string[] = []

  // Add overlays based on game state, time, events, etc.
  // Example: if character has low health, add a red glow
  if (character.health &amp;&amp; character.health &lt; 30) {
    overlays.push(&#39;glow-red&#39;)
  }

  // Add weather effects based on location
  if (character.currentLocation?.biome === &#39;desert&#39; &amp;&amp; Math.random() &gt; 0.7) {
    // Sometimes add heat shimmer effect in desert
    // overlays.push(&#39;heat-shimmer&#39;)
  }

  return overlays
}

function applyVisibilityRules(layers: LayerConfig[]): LayerConfig[] {
  const visibleLayers = [...layers]

  // Apply blocking rules
  layers.forEach((layer) =&gt; {
    const rules = LAYER_VISIBILITY_RULES[layer.name]
    if (rules?.blocks) {
      rules.blocks.forEach((blockedName) =&gt; {
        const blockedLayer = visibleLayers.find((l) =&gt; l.name === blockedName)
        if (blockedLayer) {
          blockedLayer.visible = false
        }
      })
    }
  })

  // Sort by z-index and filter visible layers
  return visibleLayers
    .filter((layer) =&gt; layer.visible)
    .sort((a, b) =&gt; a.zIndex - b.zIndex)
}

// Utility function to convert item names to kebab-case for file names
function kebabCase(str: string): string {
  return str
    .toLowerCase()
    .replace(/[^a-z0-9]/g, &#39;-&#39;)
    .replace(/-+/g, &#39;-&#39;)
    .replace(/^-|-$/g, &#39;&#39;)
}

// Generate metadata for NFT
export interface NFTMetadata {
  name: string
  description: string
  image: string
  attributes: Array&lt;{
    trait_type: string
    value: string
  }&gt;
  assets: {
    layers: string[]
  }
}

export function generateNFTMetadata(character: {
  id: string
  name: string
  gender: string
  characterType: string
  currentLocation: { name: string; biome?: string }
  inventory: Array&lt;{
    item: {
      name: string
      category: string
      rarity: string
      layerType?: string
    }
    isEquipped: boolean
  }&gt;
  energy: number
  health: number
}): NFTMetadata {
  const visibleLayers = resolveVisibleLayers(character)

  // Generate attributes from visible layers and character stats
  const attributes = [
    { trait_type: &#39;Gender&#39;, value: character.gender },
    { trait_type: &#39;Type&#39;, value: character.characterType },
    { trait_type: &#39;Location&#39;, value: character.currentLocation.name },
  ]

  // Add background attribute
  const background = visibleLayers.find((l) =&gt; l.type === &#39;background&#39;)
  if (background) {
    attributes.push({
      trait_type: &#39;Background&#39;,
      value: background.name
        .split(&#39;-&#39;)
        .map((w) =&gt; w.charAt(0).toUpperCase() + w.slice(1))
        .join(&#39; &#39;),
    })
  }

  // Add equipped item attributes
  const equippedItems = character.inventory.filter((inv) =&gt; inv.isEquipped)
  equippedItems.forEach((inv) =&gt; {
    attributes.push({
      trait_type:
        inv.item.category.charAt(0) + inv.item.category.slice(1).toLowerCase(),
      value: inv.item.name,
    })
  })

  // Add status attributes
  if (character.energy &lt; 30) {
    attributes.push({ trait_type: &#39;Status&#39;, value: &#39;Exhausted&#39; })
  } else if (character.energy &gt; 90) {
    attributes.push({ trait_type: &#39;Status&#39;, value: &#39;Energetic&#39; })
  }

  // Generate description
  const description = generateDescription(character, equippedItems)

  return {
    name: character.name,
    description,
    image: `https://earth.ndao.computer/api/render/${character.id}.png`,
    attributes,
    assets: {
      layers: visibleLayers.map((layer) =&gt; getAssetUrl(layer.type, layer.name)),
    },
  }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function generateDescription(character: any, equippedItems: any[]): string {
  const locationDesc = `wandering ${character.currentLocation.name}`
  const itemDesc =
    equippedItems.length &gt; 0
      ? `equipped with ${equippedItems.map((i) =&gt; i.item.name).join(&#39;, &#39;)}`
      : &#39;traveling light&#39;

  const statusDesc =
    character.energy &lt; 30
      ? &#39;looking weary from their adventures&#39;
      : character.energy &gt; 90
      ? &#39;full of energy and ready for action&#39;
      : &#39;continuing their journey&#39;

  return `A ${character.characterType.toLowerCase()} ${locationDesc}, ${itemDesc}, ${statusDesc}.`
}

// Export layer resolution for use in image rendering
export { resolveVisibleLayers as default }
</content>
    </document>

    <document>
      <source>src/main.tsx</source>
      <tags></tags>
      <metadata>
        <size>385</size>
        <lastModified>2025-05-29T00:32:11.986Z</lastModified>
        <extension>tsx</extension>
        <directory>src</directory>
      </metadata>
      <content>import { StrictMode } from &#39;react&#39;
import { createRoot } from &#39;react-dom/client&#39;
import &#39;./index.css&#39;
import App from &#39;./App.tsx&#39;
import { ThemeProvider } from &#39;./components/theme-provider.tsx&#39;

createRoot(document.getElementById(&#39;root&#39;)!).render(
  &lt;StrictMode&gt;
    &lt;ThemeProvider defaultTheme=&quot;dark&quot; storageKey=&quot;vite-ui-theme&quot;&gt;

      &lt;App /&gt;
    &lt;/ThemeProvider&gt;
  &lt;/StrictMode&gt;,
)
</content>
    </document>

    <document>
      <source>src/App.css</source>
      <tags></tags>
      <metadata>
        <size>606</size>
        <lastModified>2025-05-28T21:44:35.041Z</lastModified>
        <extension>css</extension>
        <directory>src</directory>
      </metadata>
      <content>#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</content>
    </document>

    <document>
      <source>src/vite-env.d.ts</source>
      <tags></tags>
      <metadata>
        <size>38</size>
        <lastModified>2025-05-28T21:44:35.044Z</lastModified>
        <extension>ts</extension>
        <directory>src</directory>
      </metadata>
      <content>/// &lt;reference types=&quot;vite/client&quot; /&gt;
</content>
    </document>

    <document>
      <source>src/index.css</source>
      <tags></tags>
      <metadata>
        <size>4484</size>
        <lastModified>2025-05-28T21:46:42.653Z</lastModified>
        <extension>css</extension>
        <directory>src</directory>
      </metadata>
      <content>@import &quot;tailwindcss&quot;;
@import &quot;tw-animate-css&quot;;

@custom-variant dark (&amp;:is(.dark *));

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.147 0.004 49.25);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.147 0.004 49.25);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.147 0.004 49.25);
  --primary: oklch(0.216 0.006 56.043);
  --primary-foreground: oklch(0.985 0.001 106.423);
  --secondary: oklch(0.97 0.001 106.424);
  --secondary-foreground: oklch(0.216 0.006 56.043);
  --muted: oklch(0.97 0.001 106.424);
  --muted-foreground: oklch(0.553 0.013 58.071);
  --accent: oklch(0.97 0.001 106.424);
  --accent-foreground: oklch(0.216 0.006 56.043);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.923 0.003 48.717);
  --input: oklch(0.923 0.003 48.717);
  --ring: oklch(0.709 0.01 56.259);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0.001 106.423);
  --sidebar-foreground: oklch(0.147 0.004 49.25);
  --sidebar-primary: oklch(0.216 0.006 56.043);
  --sidebar-primary-foreground: oklch(0.985 0.001 106.423);
  --sidebar-accent: oklch(0.97 0.001 106.424);
  --sidebar-accent-foreground: oklch(0.216 0.006 56.043);
  --sidebar-border: oklch(0.923 0.003 48.717);
  --sidebar-ring: oklch(0.709 0.01 56.259);
}

.dark {
  --background: oklch(0.147 0.004 49.25);
  --foreground: oklch(0.985 0.001 106.423);
  --card: oklch(0.216 0.006 56.043);
  --card-foreground: oklch(0.985 0.001 106.423);
  --popover: oklch(0.216 0.006 56.043);
  --popover-foreground: oklch(0.985 0.001 106.423);
  --primary: oklch(0.923 0.003 48.717);
  --primary-foreground: oklch(0.216 0.006 56.043);
  --secondary: oklch(0.268 0.007 34.298);
  --secondary-foreground: oklch(0.985 0.001 106.423);
  --muted: oklch(0.268 0.007 34.298);
  --muted-foreground: oklch(0.709 0.01 56.259);
  --accent: oklch(0.268 0.007 34.298);
  --accent-foreground: oklch(0.985 0.001 106.423);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.553 0.013 58.071);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.216 0.006 56.043);
  --sidebar-foreground: oklch(0.985 0.001 106.423);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0.001 106.423);
  --sidebar-accent: oklch(0.268 0.007 34.298);
  --sidebar-accent-foreground: oklch(0.985 0.001 106.423);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.553 0.013 58.071);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</content>
    </document>

    <document>
      <source>src/App.tsx</source>
      <tags></tags>
      <metadata>
        <size>48786</size>
        <lastModified>2025-05-29T04:20:16.379Z</lastModified>
        <extension>tsx</extension>
        <directory>src</directory>
      </metadata>
      <content>import { useState, useEffect } from &#39;react&#39;
import { Button } from &#39;@/components/ui/button&#39;
import { MapPin, Pickaxe, Store, Backpack, ArrowLeft, Zap, Heart, Users, Map, MessageCircle, Send, Coins, Loader2 } from &#39;lucide-react&#39;
import &#39;./App.css&#39;
import { ModeToggle } from &#39;./components/mode-toggle&#39;
// import { resolveVisibleLayers, generateCharacterLayers, generateNFTMetadata } from &#39;@/lib/layerResolver&#39;
import { toast, Toaster } from &#39;sonner&#39;

// API base URL - will be your Netlify functions URL
const API_BASE = &#39;/.netlify/functions&#39;

import type {
  GameView,
  Character,
  Location,
  MarketItem,
  ChatMessage,
  Player
} from &#39;@/types&#39;

function App() {
  const [currentView, setCurrentView] = useState&lt;GameView&gt;(&#39;main&#39;)
  const [selectedLocation, setSelectedLocation] = useState&lt;Location | null&gt;(null)
  const [gameLog, setGameLog] = useState&lt;string[]&gt;([])
  const [chatInput, setChatInput] = useState(&#39;&#39;)
  const [loadingItems, setLoadingItems] = useState&lt;Set&lt;string&gt;&gt;(new Set())

  // market tabs
  const [activeMarketTab, setActiveMarketTab] = useState&lt;&#39;local&#39; | &#39;global&#39;&gt;(&#39;local&#39;)

  // State for API data
  const [character, setCharacter] = useState&lt;Character | null&gt;(null)
  const [locations, setLocations] = useState&lt;Location[]&gt;([])
  const [marketItems, setMarketItems] = useState&lt;MarketItem[]&gt;([])
  const [chatMessages, setChatMessages] = useState&lt;ChatMessage[]&gt;([])
  const [playersAtLocation, setPlayersAtLocation] = useState&lt;Player[]&gt;([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState&lt;string | null&gt;(null)
  const [travelingTo, setTravelingTo] = useState&lt;Location | null&gt;(null)

  // Load initial data
  useEffect(() =&gt; {
    loadGameData()
  }, [])

  // Load chat when location changes
  useEffect(() =&gt; {
    if (character &amp;&amp; currentView === &#39;chat&#39;) {
      loadChatMessages(selectedLocation?.id || character.currentLocation.id)
    }
  }, [currentView, selectedLocation?.id, character?.currentLocation.id, character])

  // Load players when viewing location
  useEffect(() =&gt; {
    if (selectedLocation &amp;&amp; currentView === &#39;location&#39;) {
      loadPlayersAtLocation(selectedLocation.id)
    }
  }, [selectedLocation?.id, currentView, selectedLocation])

  // Load market when opening market view
  useEffect(() =&gt; {
    if (character &amp;&amp; currentView === &#39;market&#39;) {
      loadMarketItems(selectedLocation?.id || character.currentLocation.id)
    }
  }, [currentView, selectedLocation?.id, character?.currentLocation.id, character])

  const loadGameData = async () =&gt; {
    try {
      setLoading(true)

      // Load character data
      const characterResponse = await fetch(`${API_BASE}/get-character?characterId=hardcoded-demo`)
      if (!characterResponse.ok) throw new Error(&#39;Failed to load character&#39;)
      const characterData = await characterResponse.json()
      setCharacter(characterData)

      // Load locations data
      const locationsResponse = await fetch(`${API_BASE}/get-locations`)
      if (!locationsResponse.ok) throw new Error(&#39;Failed to load locations&#39;)
      const locationsData = await locationsResponse.json()
      setLocations(locationsData.locations)

      // Set initial game log
      setGameLog([
        `Welcome to Earth, ${characterData.name}!`,
        `You find yourself in ${characterData.currentLocation.name}.`,
        ...characterData.recentActivity.slice(0, 3).map((activity: Character[&#39;recentActivity&#39;][0]) =&gt;
          `${activity.description}${activity.item ? ` - ${activity.item.name}` : &#39;&#39;}`
        )
      ])

      setError(null)
    } catch (err) {
      console.error(&#39;Failed to load game data:&#39;, err)
      setError(&#39;Failed to load game data. Please refresh the page.&#39;)
    } finally {
      setLoading(false)
    }
  }

  const loadMarketItems = async (locationId: string) =&gt; {
    try {
      const response = await fetch(`${API_BASE}/get-market?locationId=${locationId}`)
      if (response.ok) {
        const data = await response.json()
        setMarketItems(data.items || [])
      }
    } catch (error) {
      console.error(&#39;Failed to load market items:&#39;, error)
      // Fallback to mock data if API not implemented
      setMarketItems([
        {
          id: &#39;1&#39;,
          price: 50,
          quantity: 1,
          isSystemItem: true,
          item: {
            id: &#39;1&#39;,
            name: &#39;Miners Hat&#39;,
            description: &#39;Worn leather hat with a dim headlamp&#39;,
            category: &#39;HAT&#39;,
            rarity: &#39;COMMON&#39;,
            imageUrl: &#39;/items/miners-hat.png&#39;
          }
        },
        {
          id: &#39;2&#39;,
          price: 25,
          quantity: 1,
          isSystemItem: true,
          item: {
            id: &#39;2&#39;,
            name: &#39;Work Gloves&#39;,
            description: &#39;Tough gloves for manual labor&#39;,
            category: &#39;CLOTHING&#39;,
            rarity: &#39;COMMON&#39;
          }
        },
        {
          id: &#39;3&#39;,
          price: 10,
          quantity: 5,
          isSystemItem: true,
          item: {
            id: &#39;3&#39;,
            name: &#39;Energy Drink&#39;,
            description: &#39;Restores energy and keeps you alert&#39;,
            category: &#39;CONSUMABLE&#39;,
            rarity: &#39;COMMON&#39;
          }
        }
      ])
    }
  }

  const loadChatMessages = async (locationId: string) =&gt; {
    try {
      const response = await fetch(`${API_BASE}/get-chat?locationId=${locationId}&amp;limit=50`)
      if (response.ok) {
        const data = await response.json()
        setChatMessages(data.messages || [])
      }
    } catch (error) {
      console.error(&#39;Failed to load chat messages:&#39;, error)
      // Fallback to mock data
      setChatMessages([
        {
          id: &#39;1&#39;,
          message: &#39;Anyone know where the best iron deposits are?&#39;,
          messageType: &#39;CHAT&#39;,
          isSystem: false,
          timeAgo: &#39;3m ago&#39;,
          createdAt: new Date(Date.now() - 3 * 60 * 1000).toISOString(),
          character: {
            id: &#39;1&#39;,
            name: &#39;Wojak #420&#39;,
            characterType: &#39;HUMAN&#39;,
            imageUrl: &#39;/wojak-420.png&#39;
          },
          location: {
            id: locationId,
            name: &#39;Mining Plains&#39;,
            locationType: &#39;REGION&#39;
          }
        },
        {
          id: &#39;2&#39;,
          message: &#39;Try the eastern slopes, found some good scraps there yesterday&#39;,
          messageType: &#39;CHAT&#39;,
          isSystem: false,
          timeAgo: &#39;2m ago&#39;,
          createdAt: new Date(Date.now() - 2 * 60 * 1000).toISOString(),
          character: {
            id: &#39;2&#39;,
            name: &#39;Wojak #1337&#39;,
            characterType: &#39;HUMAN&#39;
          },
          location: {
            id: locationId,
            name: &#39;Mining Plains&#39;,
            locationType: &#39;REGION&#39;
          }
        }
      ])
    }
  }

  const loadPlayersAtLocation = async (locationId: string) =&gt; {
    try {
      const response = await fetch(`${API_BASE}/get-players-at-location?locationId=${locationId}`)
      if (response.ok) {
        const data = await response.json()
        setPlayersAtLocation(data.players || [])
      }
    } catch (error) {
      console.error(&#39;Failed to load players:&#39;, error)
      // Mock data fallback
      setPlayersAtLocation([
        {
          id: &#39;1&#39;,
          name: &#39;Wojak #420&#39;,
          gender: &#39;MALE&#39;,
          characterType: &#39;HUMAN&#39;,
          level: 5,
          energy: 95,
          health: 100,
          status: &#39;Mining&#39;,
          currentImageUrl: &#39;/wojak-420.png&#39;,
          equippedItems: [
            { name: &#39;Miners Hat&#39;, category: &#39;HAT&#39;, rarity: &#39;COMMON&#39; }
          ]
        },
        {
          id: &#39;2&#39;,
          name: &#39;Wojak #69&#39;,
          gender: &#39;FEMALE&#39;,
          characterType: &#39;HUMAN&#39;,
          level: 3,
          energy: 70,
          health: 100,
          status: &#39;Chatting&#39;,
          equippedItems: []
        }
      ])
    }
  }

  const addToLog = (message: string) =&gt; {
    setGameLog(prev =&gt; [...prev.slice(-4), message]) // Keep last 5 messages
  }

  const handleMining = async () =&gt; {
    if (!character) return

    try {
      const response = await fetch(`${API_BASE}/mine-action`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          locationId: selectedLocation?.id || character.currentLocation.id
        })
      })

      const result = await response.json()

      if (!response.ok) {
        addToLog(result.message || result.error)
        return
      }

      // Update character energy
      setCharacter(prev =&gt; prev ? ({
        ...prev,
        energy: result.newEnergyLevel
      }) : null)

      // Show result in log
      addToLog(result.message)

      // Refresh character data to get updated inventory
      loadGameData()

    } catch (error) {
      console.error(&#39;Mining failed:&#39;, error)
      addToLog(&#39;Mining attempt failed. Please try again.&#39;)
    }
  }

  const handleTravel = async (locationId: string) =&gt; {
    if (!character) return

    // Find the destination location for the travel animation
    const destination = locations.find(loc =&gt; loc.id === locationId) ||
      locations.find(loc =&gt; loc.subLocations?.some(sub =&gt; sub.id === locationId))?.subLocations?.find(sub =&gt; sub.id === locationId)

    if (destination) {
      setTravelingTo(destination)
    }

    try {
      const response = await fetch(`${API_BASE}/travel-action`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          destinationId: locationId
        })
      })

      const result = await response.json()

      if (!response.ok) {
        addToLog(result.message || result.error)
        setTravelingTo(null)
        return
      }

      // Show travel completion after a brief delay for the animation
      setTimeout(async () =&gt; {
        // Update character location
        setCharacter(prev =&gt; prev ? ({
          ...prev,
          currentLocation: {
            id: result.newLocation.id,
            name: result.newLocation.name,
            description: result.newLocation.description,
            locationType: result.newLocation.locationType,
            biome: result.newLocation.biome,
            welcomeMessage: result.newLocation.welcomeMessage
          }
        }) : null)

        // Show result in log
        addToLog(result.message)
        if (result.newLocation.welcomeMessage) {
          addToLog(`&quot;${result.newLocation.welcomeMessage}&quot;`)
        }

        // Refresh locations data in background without loading state
        try {
          const locationsResponse = await fetch(`${API_BASE}/get-locations`)
          if (locationsResponse.ok) {
            const locationsData = await locationsResponse.json()
            setLocations(locationsData.locations)
          }
        } catch (err) {
          console.error(&#39;Failed to refresh locations:&#39;, err)
        }

        // Clear traveling state and go to main view
        setTravelingTo(null)
        setCurrentView(&#39;main&#39;)
      }, 1500) // 1.5 second travel animation

    } catch (error) {
      console.error(&#39;Travel failed:&#39;, error)
      addToLog(&#39;Travel failed. Please try again.&#39;)
      setTravelingTo(null)
    }
  }

  const handleLocationSelect = (location: Location) =&gt; {
    setSelectedLocation(location)
    setCurrentView(&#39;location&#39;)
  }

  const handlePurchase = async (marketListingId: string, price: number, itemName: string) =&gt; {
    if (!character) return

    // Set loading state
    setLoadingItems(prev =&gt; new Set(prev).add(marketListingId))

    try {
      const response = await fetch(`${API_BASE}/buy-item`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          marketListingId: marketListingId,
          locationId: selectedLocation?.id || character.currentLocation.id
        })
      })

      const result = await response.json()

      if (!response.ok) {
        toast.error(result.message || result.error)
        return
      }

      toast.success(`Bought ${itemName} for ${price} coins!`)

      // Optimistic update for market items
      setMarketItems(prev =&gt; prev.map(item =&gt; {
        if (item.id === marketListingId) {
          const newQuantity = item.quantity - 1
          return newQuantity &gt; 0 ? { ...item, quantity: newQuantity } : null
        }
        return item
      }).filter(Boolean) as MarketItem[])

      // Only refresh character data (not everything)
      const characterResponse = await fetch(`${API_BASE}/get-character?characterId=hardcoded-demo`)
      if (characterResponse.ok) {
        const characterData = await characterResponse.json()
        setCharacter(characterData)
      }

    } catch (error) {
      console.error(&#39;Purchase failed:&#39;, error)
      toast.error(&#39;Purchase failed&#39;)
    } finally {
      // Remove loading state
      setLoadingItems(prev =&gt; {
        const newSet = new Set(prev)
        newSet.delete(marketListingId)
        return newSet
      })
    }
  }

  const handleSendMessage = async () =&gt; {
    if (!chatInput.trim() || !character) return

    try {
      const response = await fetch(`${API_BASE}/send-message`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          locationId: selectedLocation?.id || character.currentLocation.id,
          message: chatInput,
          messageType: &#39;CHAT&#39;
        })
      })

      if (response.ok) {
        setChatInput(&#39;&#39;)
        // Reload chat messages
        loadChatMessages(selectedLocation?.id || character.currentLocation.id)
      } else {
        // Fallback for demo - add message locally
        const newMessage: ChatMessage = {
          id: Date.now().toString(),
          message: chatInput,
          messageType: &#39;CHAT&#39;,
          isSystem: false,
          timeAgo: &#39;now&#39;,
          createdAt: new Date().toISOString(),
          character: {
            id: character.id,
            name: character.name,
            characterType: &#39;HUMAN&#39;
          },
          location: {
            id: selectedLocation?.id || character.currentLocation.id,
            name: selectedLocation?.name || character.currentLocation.name,
            locationType: selectedLocation?.locationType || character.currentLocation.locationType
          }
        }
        setChatMessages(prev =&gt; [...prev, newMessage])
        setChatInput(&#39;&#39;)
      }
    } catch (error) {
      console.error(&#39;Failed to send message:&#39;, error)
    }
  }

  const handleEquipItem = async (inventoryId: string, isEquipped: boolean) =&gt; {
    if (!character) return

    // Set loading state
    setLoadingItems(prev =&gt; new Set(prev).add(inventoryId))

    try {
      const response = await fetch(`${API_BASE}/equip-item`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          inventoryId: inventoryId,
          equip: !isEquipped
        })
      })

      if (response.ok) {
        // Optimistic update
        setCharacter(prev =&gt; prev ? ({
          ...prev,
          inventory: prev.inventory.map(inv =&gt;
            inv.id === inventoryId ? { ...inv, isEquipped: !isEquipped } : inv
          )
        }) : null)

        toast.success(isEquipped ? &#39;Item unequipped&#39; : &#39;Item equipped&#39;)
      } else {
        toast.error(&#39;Failed to update equipment&#39;)
      }
    } catch (error) {
      console.error(&#39;Failed to equip item:&#39;, error)
      toast.error(&#39;Failed to update equipment&#39;)
    } finally {
      // Remove loading state
      setLoadingItems(prev =&gt; {
        const newSet = new Set(prev)
        newSet.delete(inventoryId)
        return newSet
      })
    }
  }

  const handleUseItem = async (inventoryId: string, itemName: string, energyEffect?: number, healthEffect?: number) =&gt; {
    if (!character) return

    // Calculate actual effects (capped at 100)
    const actualEnergyGain = energyEffect ? Math.min(energyEffect, 100 - character.energy) : 0
    const actualHealthGain = healthEffect ? Math.min(healthEffect, 100 - character.health) : 0

    // Warn if effects would be wasted
    if ((energyEffect &amp;&amp; actualEnergyGain === 0) || (healthEffect &amp;&amp; actualHealthGain === 0)) {
      toast.warning(`You&#39;re already at full ${energyEffect &amp;&amp; actualEnergyGain === 0 ? &#39;energy&#39; : &#39;health&#39;}!`)
      return
    }

    // Set loading state for this specific item
    setLoadingItems(prev =&gt; new Set(prev).add(inventoryId))

    try {
      const response = await fetch(`${API_BASE}/use-item`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          inventoryId: inventoryId
        })
      })

      const result = await response.json()

      if (!response.ok) {
        toast.error(result.message || result.error)
        return
      }

      // Update character stats immediately (optimistic update)
      setCharacter(prev =&gt; prev ? ({
        ...prev,
        energy: Math.min(100, prev.energy + (result.effects?.energy || 0)),
        health: Math.min(100, prev.health + (result.effects?.health || 0)),
        // Update inventory optimistically
        inventory: prev.inventory.map(inv =&gt; {
          if (inv.id === inventoryId) {
            const newQuantity = inv.quantity - 1
            return newQuantity &gt; 0 ? { ...inv, quantity: newQuantity } : null
          }
          return inv
        }).filter(Boolean) as typeof prev.inventory
      }) : null)

      // Show success toast with effects
      const effects = []
      if (result.effects?.energy &gt; 0) effects.push(`+${result.effects.energy} energy`)
      if (result.effects?.health &gt; 0) effects.push(`+${result.effects.health} health`)

      toast.success(`Used ${itemName}${effects.length &gt; 0 ? ` (${effects.join(&#39;, &#39;)})` : &#39;&#39;}`)

      // Don&#39;t reload everything - just let the optimistic update handle it

    } catch (error) {
      console.error(&#39;Use item failed:&#39;, error)
      toast.error(`Failed to use ${itemName}`)
    } finally {
      // Remove loading state
      setLoadingItems(prev =&gt; {
        const newSet = new Set(prev)
        newSet.delete(inventoryId)
        return newSet
      })
    }
  }

  // Initial loading state (only for app startup)
  if (loading &amp;&amp; !travelingTo) {
    return (
      &lt;div className=&quot;min-h-screen bg-background p-4 flex items-center justify-center&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          &lt;div className=&quot;text-2xl mb-4&quot;&gt;🌍&lt;/div&gt;
          &lt;div&gt;Loading Wojak Earth...&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }

  // Travel animation state
  if (travelingTo) {
    return (
      &lt;div className=&quot;min-h-screen bg-background p-4 flex items-center justify-center&quot;&gt;
        &lt;div className=&quot;text-center max-w-md mx-auto&quot;&gt;
          &lt;div className=&quot;mb-6&quot;&gt;
            &lt;div className=&quot;text-4xl mb-4 animate-bounce&quot;&gt;
              {travelingTo.biome === &#39;desert&#39; ? &#39;🏜️&#39; :
                travelingTo.biome === &#39;urban&#39; ? &#39;🏙️&#39; :
                  travelingTo.biome === &#39;plains&#39; ? &#39;🌾&#39; :
                    travelingTo.locationType === &#39;BUILDING&#39; ? &#39;🏠&#39; : &#39;🗺️&#39;}
            &lt;/div&gt;
            &lt;div className=&quot;text-xl font-bold mb-2&quot;&gt;Traveling to...&lt;/div&gt;
            &lt;div className=&quot;text-2xl font-bold text-primary mb-2&quot;&gt;{travelingTo.name}&lt;/div&gt;
            &lt;div className=&quot;text-muted-foreground mb-4&quot;&gt;{travelingTo.description}&lt;/div&gt;

            {/* Animated progress bar */}
            &lt;div className=&quot;w-full bg-muted rounded-full h-2 mb-4 overflow-hidden&quot;&gt;
              &lt;div className=&quot;bg-primary h-2 rounded-full animate-pulse&quot;
                style={{
                  animation: &#39;travel-progress 1.5s ease-in-out forwards&#39;,
                  width: &#39;0%&#39;
                }}&gt;&lt;/div&gt;
            &lt;/div&gt;

            &lt;div className=&quot;text-sm text-muted-foreground animate-pulse&quot;&gt;
              Preparing for arrival...
            &lt;/div&gt;
          &lt;/div&gt;

          {/* Add custom CSS for the travel progress animation */}
          &lt;style&gt;{`
            @keyframes travel-progress {
              0% { width: 0%; }
              100% { width: 100%; }
            }
          `}&lt;/style&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }

  // Error state
  if (error) {
    return (
      &lt;div className=&quot;min-h-screen bg-background p-4 flex items-center justify-center&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          &lt;div className=&quot;text-2xl mb-4&quot;&gt;❌&lt;/div&gt;
          &lt;div className=&quot;text-red-500 mb-4&quot;&gt;{error}&lt;/div&gt;
          &lt;Button onClick={loadGameData}&gt;Retry&lt;/Button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }

  // No character data
  if (!character) {
    return (
      &lt;div className=&quot;min-h-screen bg-background p-4 flex items-center justify-center&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          &lt;div className=&quot;text-2xl mb-4&quot;&gt;🤔&lt;/div&gt;
          &lt;div&gt;No character data found&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }


  // Add this new component for the character display
  const CharacterRenderer: React.FC&lt;{ character: Character }&gt; = ({ character }) =&gt; {
    const [imageError, setImageError] = useState(false)
    const [imageLoading, setImageLoading] = useState(true)

    // Generate the rendered character URL
    const characterImageUrl = `/.netlify/functions/render-character/${character.id}.png`

    const handleImageLoad = () =&gt; {
      setImageLoading(false)
      setImageError(false)
    }

    const handleImageError = () =&gt; {
      setImageLoading(false)
      setImageError(true)
    }

    return (
      &lt;div className=&quot;w-32 h-32 mx-auto bg-gray-200 rounded-lg flex items-center justify-center mb-4 overflow-hidden relative&quot;&gt;
        {imageLoading &amp;&amp; (
          &lt;div className=&quot;absolute inset-0 flex items-center justify-center&quot;&gt;
            &lt;div className=&quot;animate-spin rounded-full h-8 w-8 border-b-2 border-primary&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;
        )}

        {!imageError ? (
          &lt;img
            src={characterImageUrl}
            alt={character.name}
            className=&quot;w-full h-full object-cover&quot;
            onLoad={handleImageLoad}
            onError={handleImageError}
            style={{ display: imageLoading ? &#39;none&#39; : &#39;block&#39; }}
          /&gt;
        ) : (
          // Fallback to default wojak image
          &lt;img
            src={character.currentImageUrl || &quot;/wojak.png&quot;}
            alt={character.name}
            className=&quot;w-full h-full object-cover&quot;
            onLoad={() =&gt; setImageLoading(false)}
            onError={() =&gt; {
              setImageLoading(false)
              // Ultimate fallback
              const target = event?.target as HTMLImageElement
              if (target) {
                target.style.display = &#39;none&#39;
                if (target.parentElement) {
                  target.parentElement.innerHTML = &#39;&lt;div class=&quot;text-4xl&quot;&gt;🥺&lt;/div&gt;&#39;
                }
              }
            }}
          /&gt;
        )}
      &lt;/div&gt;
    )
  }

  // Add this function to show layer information (useful for debugging)
  // const LayerDebugPanel: React.FC&lt;{ character: Character }&gt; = ({ character }) =&gt; {
  //   const characterLayers = generateCharacterLayers(character)
  //   const visibleLayers = resolveVisibleLayers(
  //     characterLayers,
  //     character.currentLocation.biome
  //   )

  //   return (
  //     &lt;div className=&quot;mt-4 p-3 bg-muted/30 rounded-lg&quot;&gt;
  //       &lt;h4 className=&quot;font-medium mb-2 text-sm&quot;&gt;Character Layers (Debug)&lt;/h4&gt;
  //       &lt;div className=&quot;space-y-1 text-xs&quot;&gt;
  //         {visibleLayers.map((layer, i) =&gt; (
  //           &lt;div key={i} className=&quot;flex justify-between items-center&quot;&gt;
  //             &lt;span className={layer.visible ? &#39;text-green-600&#39; : &#39;text-red-500&#39;}&gt;
  //               {layer.type}/{layer.name}
  //             &lt;/span&gt;
  //             &lt;span className=&quot;text-muted-foreground&quot;&gt;
  //               z:{layer.zIndex} {layer.visible ? &#39;✓&#39; : &#39;✗&#39;}
  //             &lt;/span&gt;
  //           &lt;/div&gt;
  //         ))}
  //       &lt;/div&gt;

  //       &lt;div className=&quot;mt-2 pt-2 border-t&quot;&gt;
  //         &lt;a
  //           href={`/.netlify/functions/metadata/${character.tokenId || character.id}`}
  //           target=&quot;_blank&quot;
  //           rel=&quot;noopener noreferrer&quot;
  //           className=&quot;text-xs text-blue-500 hover:underline&quot;
  //         &gt;
  //           View NFT Metadata →
  //         &lt;/a&gt;
  //       &lt;/div&gt;
  //     &lt;/div&gt;
  //   )
  // }



  const renderMainView = () =&gt; (
    &lt;div className=&quot;space-y-6&quot;&gt;
      &lt;ModeToggle /&gt;
      &lt;div className=&quot;text-center&quot;&gt;
        &lt;CharacterRenderer character={character} /&gt;
        &lt;h2 className=&quot;text-xl font-bold&quot;&gt;{character.name}&lt;/h2&gt;
        &lt;p className=&quot;text-muted-foreground&quot;&gt;Currently in {character.currentLocation.name}&lt;/p&gt;
        &lt;div className=&quot;flex justify-center gap-4 mt-2&quot;&gt;
          &lt;span className=&quot;text-sm flex items-center gap-1&quot;&gt;
            &lt;Zap className=&quot;w-3 h-3&quot; /&gt; {character.energy}/100
          &lt;/span&gt;
          &lt;span className=&quot;text-sm flex items-center gap-1&quot;&gt;
            &lt;Heart className=&quot;w-3 h-3&quot; /&gt; {character.health}/100
          &lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div className=&quot;grid grid-cols-2 gap-3&quot;&gt;
        &lt;Button onClick={() =&gt; setCurrentView(&#39;map&#39;)} variant=&quot;outline&quot;&gt;
          &lt;Map className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Map
        &lt;/Button&gt;
        &lt;Button onClick={() =&gt; setCurrentView(&#39;mine&#39;)} variant=&quot;outline&quot;&gt;
          &lt;Pickaxe className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Mine
        &lt;/Button&gt;
        &lt;Button onClick={() =&gt; setCurrentView(&#39;market&#39;)} variant=&quot;outline&quot;&gt;
          &lt;Store className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Market
        &lt;/Button&gt;
        &lt;Button onClick={() =&gt; setCurrentView(&#39;inventory&#39;)} variant=&quot;outline&quot;&gt;
          &lt;Backpack className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Inventory
        &lt;/Button&gt;
      &lt;/div&gt;

      &lt;div className=&quot;mt-4&quot;&gt;
        &lt;Button onClick={() =&gt; setCurrentView(&#39;chat&#39;)} variant=&quot;ghost&quot; className=&quot;w-full&quot;&gt;
          &lt;MessageCircle className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Local Chat ({playersAtLocation.length} online)
        &lt;/Button&gt;
      &lt;/div&gt;

      {/* Add debug panel in development */}
      {/* {process.env.NODE_ENV === &#39;development&#39; &amp;&amp; character &amp;&amp; (
        &lt;LayerDebugPanel character={character} /&gt;
      )} */}
    &lt;/div&gt;
  )

  const renderMapView = () =&gt; (
    &lt;div className=&quot;space-y-4&quot;&gt;
      &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;World Map&lt;/h3&gt;
      &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;
        Explore different locations across Wojak Earth
      &lt;/p&gt;

      &lt;div className=&quot;space-y-3&quot;&gt;
        {locations.map(location =&gt; (
          &lt;div
            key={location.id}
            className=&quot;border rounded-lg p-4 hover:bg-muted/50 transition-colors cursor-pointer&quot;
            onClick={() =&gt; handleLocationSelect(location)}
          &gt;
            &lt;div className=&quot;flex items-start justify-between mb-2&quot;&gt;
              &lt;div&gt;
                &lt;h4 className=&quot;font-medium&quot;&gt;{location.name}&lt;/h4&gt;
                &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;{location.description}&lt;/p&gt;
              &lt;/div&gt;
              &lt;div className=&quot;flex items-center gap-1 text-sm text-muted-foreground&quot;&gt;
                &lt;Users className=&quot;w-3 h-3&quot; /&gt;
                {location.playerCount}
              &lt;/div&gt;
            &lt;/div&gt;

            &lt;div className=&quot;flex items-center justify-between text-xs&quot;&gt;
              &lt;div className=&quot;flex gap-3&quot;&gt;
                &lt;span className=&quot;flex items-center gap-1&quot;&gt;
                  &lt;span className={`w-2 h-2 rounded-full ${location.difficulty &lt;= 2 ? &#39;bg-green-500&#39; :
                    location.difficulty &lt;= 4 ? &#39;bg-yellow-500&#39; : &#39;bg-red-500&#39;
                    }`} /&gt;
                  Level {location.difficulty}
                &lt;/span&gt;
                &lt;span className=&quot;capitalize&quot;&gt;{location.biome}&lt;/span&gt;
              &lt;/div&gt;
              &lt;span className=&quot;text-muted-foreground&quot;&gt;
                {location.lastActive ? new Date(location.lastActive).toLocaleString() : &#39;Active recently&#39;}
              &lt;/span&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        ))}
      &lt;/div&gt;

      &lt;Button onClick={() =&gt; setCurrentView(&#39;main&#39;)} variant=&quot;ghost&quot;&gt;
        &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
        Back
      &lt;/Button&gt;
    &lt;/div&gt;
  )

  const renderLocationView = () =&gt; {
    if (!selectedLocation) return null

    return (
      &lt;div className=&quot;space-y-4&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;{selectedLocation.name}&lt;/h3&gt;
          &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;{selectedLocation.description}&lt;/p&gt;
          {selectedLocation.locationType &amp;&amp; (
            &lt;span className=&quot;inline-block mt-1 px-2 py-1 text-xs bg-muted rounded-full capitalize&quot;&gt;
              {selectedLocation.locationType.toLowerCase()}
            &lt;/span&gt;
          )}
        &lt;/div&gt;

        {selectedLocation.welcomeMessage &amp;&amp; (
          &lt;div className=&quot;bg-muted/50 p-3 rounded-lg text-sm italic text-center&quot;&gt;
            &quot;{selectedLocation.welcomeMessage}&quot;
          &lt;/div&gt;
        )}

        &lt;div className=&quot;grid grid-cols-3 gap-2 text-center text-sm&quot;&gt;
          &lt;div&gt;
            &lt;div className=&quot;font-medium&quot;&gt;{selectedLocation.playerCount}&lt;/div&gt;
            &lt;div className=&quot;text-muted-foreground&quot;&gt;Players&lt;/div&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;div className=&quot;font-medium&quot;&gt;
              {selectedLocation.difficulty ? `Level ${selectedLocation.difficulty}` : &#39;N/A&#39;}
            &lt;/div&gt;
            &lt;div className=&quot;text-muted-foreground&quot;&gt;Difficulty&lt;/div&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;div className=&quot;font-medium capitalize&quot;&gt;
              {selectedLocation.biome || selectedLocation.locationType?.toLowerCase()}
            &lt;/div&gt;
            &lt;div className=&quot;text-muted-foreground&quot;&gt;Type&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        {/* Sub-locations */}
        {selectedLocation.subLocations &amp;&amp; selectedLocation.subLocations.length &gt; 0 &amp;&amp; (
          &lt;div&gt;
            &lt;h4 className=&quot;font-medium mb-2&quot;&gt;Places to Visit&lt;/h4&gt;
            &lt;div className=&quot;space-y-2&quot;&gt;
              {selectedLocation.subLocations.map((subLocation) =&gt; (
                &lt;div
                  key={subLocation.id}
                  className=&quot;flex items-center justify-between p-2 bg-muted/30 rounded cursor-pointer hover:bg-muted/50 transition-colors&quot;
                  onClick={() =&gt; handleLocationSelect(subLocation)}
                &gt;
                  &lt;div&gt;
                    &lt;div className=&quot;font-medium text-sm&quot;&gt;{subLocation.name}&lt;/div&gt;
                    &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;{subLocation.description}&lt;/div&gt;
                  &lt;/div&gt;
                  &lt;div className=&quot;flex items-center gap-2 text-xs text-muted-foreground&quot;&gt;
                    &lt;Users className=&quot;w-3 h-3&quot; /&gt;
                    {subLocation.playerCount}
                  &lt;/div&gt;
                &lt;/div&gt;
              ))}
            &lt;/div&gt;
          &lt;/div&gt;
        )}

        &lt;div&gt;
          &lt;h4 className=&quot;font-medium mb-2 flex items-center gap-2&quot;&gt;
            &lt;Users className=&quot;w-4 h-4&quot; /&gt;
            Players Here ({playersAtLocation.length})
          &lt;/h4&gt;
          &lt;div className=&quot;space-y-2 max-h-32 overflow-y-auto&quot;&gt;
            {playersAtLocation.map(player =&gt; (
              &lt;div key={player.id} className=&quot;flex items-center justify-between p-2 bg-muted/30 rounded text-sm&quot;&gt;
                &lt;div className=&quot;flex items-center gap-2&quot;&gt;
                  &lt;div className=&quot;w-6 h-6 bg-gray-300 rounded-full flex items-center justify-center text-xs&quot;&gt;
                    {player.characterType === &#39;HUMAN&#39; ? &#39;🙂&#39; : &#39;👹&#39;}
                  &lt;/div&gt;
                  &lt;div&gt;
                    &lt;div className=&quot;font-medium&quot;&gt;{player.name}&lt;/div&gt;
                    &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;Level {player.level} • {player.status}&lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=&quot;text-xs text-right&quot;&gt;
                  &lt;div className=&quot;flex items-center gap-1&quot;&gt;
                    &lt;Zap className=&quot;w-2 h-2&quot; /&gt; {player.energy}
                  &lt;/div&gt;
                  &lt;div className=&quot;flex items-center gap-1&quot;&gt;
                    &lt;Heart className=&quot;w-2 h-2&quot; /&gt; {player.health}
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div className=&quot;grid grid-cols-2 gap-2&quot;&gt;
          {selectedLocation.name !== character.currentLocation.name &amp;&amp; (
            &lt;Button onClick={() =&gt; handleTravel(selectedLocation.id)} variant=&quot;outline&quot;&gt;
              &lt;MapPin className=&quot;w-4 h-4 mr-2&quot; /&gt;
              Travel Here
            &lt;/Button&gt;
          )}
          &lt;Button onClick={() =&gt; setCurrentView(&#39;chat&#39;)} variant=&quot;outline&quot;&gt;
            &lt;MessageCircle className=&quot;w-4 h-4 mr-2&quot; /&gt;
            Local Chat
          &lt;/Button&gt;
        &lt;/div&gt;

        {selectedLocation.lore &amp;&amp; (
          &lt;div className=&quot;border-t pt-3&quot;&gt;
            &lt;h4 className=&quot;font-medium mb-2&quot;&gt;Lore&lt;/h4&gt;
            &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;{selectedLocation.lore}&lt;/p&gt;
          &lt;/div&gt;
        )}

        &lt;Button onClick={() =&gt; setCurrentView(&#39;map&#39;)} variant=&quot;ghost&quot;&gt;
          &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Back to Map
        &lt;/Button&gt;
      &lt;/div&gt;
    )
  }

  const renderMineView = () =&gt; (
    &lt;div className=&quot;space-y-4&quot;&gt;
      &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;Mining in {character.currentLocation.name}&lt;/h3&gt;
      &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;
        Search for resources. Each attempt costs 10 energy.
      &lt;/p&gt;

      &lt;div className=&quot;bg-muted/50 p-4 rounded-lg&quot;&gt;
        &lt;h4 className=&quot;font-medium mb-2&quot;&gt;Available Resources:&lt;/h4&gt;
        &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;
          Resources vary by location. Try your luck!
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;Button onClick={handleMining} className=&quot;w-full&quot; disabled={character.energy &lt; 10}&gt;
        &lt;Pickaxe className=&quot;w-4 h-4 mr-2&quot; /&gt;
        Mine for Resources
      &lt;/Button&gt;

      &lt;Button onClick={() =&gt; setCurrentView(&#39;main&#39;)} variant=&quot;ghost&quot;&gt;
        &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
        Back
      &lt;/Button&gt;
    &lt;/div&gt;
  )

  const renderMarketView = () =&gt; {
    // Determine if we&#39;re at a child location (has parent location)
    const currentLoc = selectedLocation || character?.currentLocation
    const isChildLocation = currentLoc &amp;&amp; locations.find(loc =&gt;
      loc.subLocations?.some(sub =&gt; sub.id === currentLoc.id)
    )

    // Filter market items by tab
    const localItems = marketItems.filter(item =&gt; item.isLocalSpecialty || false)
    const globalItems = marketItems.filter(item =&gt; !item.isLocalSpecialty)

    const activeItems = activeMarketTab === &#39;local&#39; ? localItems : globalItems

    return (
      &lt;div className=&quot;space-y-4&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;Market - {currentLoc?.name}&lt;/h3&gt;
          {isChildLocation &amp;&amp; (
            &lt;p className=&quot;text-xs text-muted-foreground&quot;&gt;
              Unique local items + supplies from the main settlement
            &lt;/p&gt;
          )}
        &lt;/div&gt;

        {/* Tab Navigation - only show if child location */}
        {isChildLocation &amp;&amp; (
          &lt;div className=&quot;flex border-b&quot;&gt;
            &lt;button
              className={`flex-1 py-2 px-4 text-sm font-medium border-b-2 transition-colors ${activeMarketTab === &#39;local&#39;
                ? &#39;border-primary text-primary bg-primary/5&#39;
                : &#39;border-transparent text-muted-foreground hover:text-foreground&#39;
                }`}
              onClick={() =&gt; setActiveMarketTab(&#39;local&#39;)}
            &gt;
              Local Specialties
              {localItems.length &gt; 0 &amp;&amp; (
                &lt;span className=&quot;ml-1 text-xs bg-primary/20 text-primary px-1.5 py-0.5 rounded-full&quot;&gt;
                  {localItems.length}
                &lt;/span&gt;
              )}
            &lt;/button&gt;
            &lt;button
              className={`flex-1 py-2 px-4 text-sm font-medium border-b-2 transition-colors ${activeMarketTab === &#39;global&#39;
                ? &#39;border-primary text-primary bg-primary/5&#39;
                : &#39;border-transparent text-muted-foreground hover:text-foreground&#39;
                }`}
              onClick={() =&gt; setActiveMarketTab(&#39;global&#39;)}
            &gt;
              Global Market
              {globalItems.length &gt; 0 &amp;&amp; (
                &lt;span className=&quot;ml-1 text-xs bg-muted text-muted-foreground px-1.5 py-0.5 rounded-full&quot;&gt;
                  {globalItems.length}
                &lt;/span&gt;
              )}
            &lt;/button&gt;
          &lt;/div&gt;
        )}

        {/* Market Items */}
        &lt;div className=&quot;space-y-2&quot;&gt;
          {activeItems.length &gt; 0 ? (
            activeItems.map((marketItem) =&gt; (
              &lt;div key={marketItem.id} className=&quot;flex items-center justify-between p-3 bg-muted/50 rounded-lg&quot;&gt;
                &lt;div className=&quot;flex items-center gap-3&quot;&gt;
                  &lt;div className=&quot;w-8 h-8 bg-muted rounded flex items-center justify-center text-xs&quot;&gt;
                    {marketItem.item.category === &#39;HAT&#39; ? &#39;🎩&#39; :
                      marketItem.item.category === &#39;CONSUMABLE&#39; ? &#39;🥤&#39; :
                        marketItem.isLocalSpecialty ? &#39;✨&#39; : &#39;📦&#39;}
                  &lt;/div&gt;
                  &lt;div&gt;
                    &lt;div className=&quot;font-medium flex items-center gap-2&quot;&gt;
                      {marketItem.item.name}
                      {marketItem.isLocalSpecialty &amp;&amp; (
                        &lt;span className=&quot;text-xs bg-amber-100 text-amber-800 px-1.5 py-0.5 rounded-full&quot;&gt;
                          Local
                        &lt;/span&gt;
                      )}
                    &lt;/div&gt;
                    &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;{marketItem.item.description}&lt;/div&gt;
                    &lt;div className=&quot;text-xs text-muted-foreground capitalize&quot;&gt;
                      {marketItem.item.rarity} • Sold by {marketItem.isSystemItem ? &#39;System&#39; : marketItem.seller?.name}
                    &lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=&quot;text-right&quot;&gt;
                  &lt;div className=&quot;font-bold flex items-center gap-1&quot;&gt;
                    &lt;Coins className=&quot;w-3 h-3&quot; /&gt;
                    {marketItem.price}
                  &lt;/div&gt;
                  &lt;div className=&quot;text-xs text-muted-foreground mb-1&quot;&gt;
                    Qty: {marketItem.quantity &gt; 0 ? marketItem.quantity : &#39;Out of Stock&#39;}
                  &lt;/div&gt;
                  &lt;Button
                    size=&quot;sm&quot;
                    onClick={() =&gt; handlePurchase(marketItem.id, marketItem.price, marketItem.item.name)}
                    disabled={marketItem.quantity === 0}
                  &gt;
                    {marketItem.quantity &gt; 0 ? &#39;Buy&#39; : &#39;Sold Out&#39;}
                  &lt;/Button&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            ))
          ) : (
            &lt;div className=&quot;bg-muted/30 p-8 rounded-lg text-center text-muted-foreground&quot;&gt;
              &lt;Store className=&quot;w-12 h-12 mx-auto mb-2&quot; /&gt;
              {activeMarketTab === &#39;local&#39; ? (
                &lt;&gt;
                  No local specialties available.&lt;br /&gt;
                  Check back later or try the global market.
                &lt;/&gt;
              ) : (
                &lt;&gt;
                  No items available in the global market.&lt;br /&gt;
                  The merchants might be restocking.
                &lt;/&gt;
              )}
            &lt;/div&gt;
          )}
        &lt;/div&gt;

        &lt;Button onClick={() =&gt; setCurrentView(&#39;main&#39;)} variant=&quot;ghost&quot;&gt;
          &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Back
        &lt;/Button&gt;
      &lt;/div&gt;
    )
  }

  const renderInventoryView = () =&gt; (
    &lt;div className=&quot;space-y-4&quot;&gt;
      &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;Inventory&lt;/h3&gt;

      {character.inventory &amp;&amp; character.inventory.length &gt; 0 ? (
        &lt;div className=&quot;space-y-2&quot;&gt;
          {character.inventory.map((inv) =&gt; {
            // Check if consumable effects would be wasted
            const isConsumable = inv.item.category === &#39;CONSUMABLE&#39;
            const energyEffect = inv.item.energyEffect || 0
            const healthEffect = inv.item.healthEffect || 0

            const wouldWasteEnergy = energyEffect &gt; 0 &amp;&amp; character.energy &gt;= 100
            const wouldWasteHealth = healthEffect &gt; 0 &amp;&amp; character.health &gt;= 100
            const wouldBeWasted = isConsumable &amp;&amp; (
              (energyEffect &gt; 0 &amp;&amp; wouldWasteEnergy) ||
              (healthEffect &gt; 0 &amp;&amp; wouldWasteHealth)
            )

            const isLoading = loadingItems.has(inv.id)

            return (
              &lt;div key={inv.id} className=&quot;flex items-center justify-between p-3 bg-muted/50 rounded-lg&quot;&gt;
                &lt;div className=&quot;flex items-center gap-3&quot;&gt;
                  &lt;div className=&quot;w-8 h-8 bg-muted rounded flex items-center justify-center text-xs&quot;&gt;
                    {inv.item.category === &#39;HAT&#39; ? &#39;🎩&#39; :
                      inv.item.category === &#39;MATERIAL&#39; ? &#39;⚡&#39; :
                        inv.item.category === &#39;CONSUMABLE&#39; ? &#39;🥤&#39; : &#39;📦&#39;}
                  &lt;/div&gt;
                  &lt;div&gt;
                    &lt;div className=&quot;font-medium&quot;&gt;{inv.item.name}&lt;/div&gt;
                    &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;{inv.item.description}&lt;/div&gt;

                    {/* Show consumable effects */}
                    {isConsumable &amp;&amp; (energyEffect &gt; 0 || healthEffect &gt; 0) &amp;&amp; (
                      &lt;div className=&quot;text-xs text-green-600 mt-1&quot;&gt;
                        Effects: {[
                          energyEffect &gt; 0 ? `+${energyEffect} energy` : null,
                          healthEffect &gt; 0 ? `+${healthEffect} health` : null
                        ].filter(Boolean).join(&#39;, &#39;)}
                      &lt;/div&gt;
                    )}
                  &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=&quot;text-right&quot;&gt;
                  &lt;div className=&quot;font-bold&quot;&gt;x{inv.quantity}&lt;/div&gt;
                  &lt;div className=&quot;text-xs text-muted-foreground capitalize&quot;&gt;{inv.item.rarity}&lt;/div&gt;

                  {/* Equipment Button */}
                  {inv.item.category !== &#39;MATERIAL&#39; &amp;&amp; inv.item.category !== &#39;CONSUMABLE&#39; &amp;&amp; (
                    &lt;Button
                      size=&quot;sm&quot;
                      variant={inv.isEquipped ? &quot;default&quot; : &quot;outline&quot;}
                      onClick={() =&gt; handleEquipItem(inv.id, inv.isEquipped)}
                      className=&quot;mt-1&quot;
                      disabled={isLoading}
                    &gt;
                      {isLoading ? (
                        &lt;Loader2 className=&quot;w-3 h-3 animate-spin&quot; /&gt;
                      ) : (
                        inv.isEquipped ? &#39;Unequip&#39; : &#39;Equip&#39;
                      )}
                    &lt;/Button&gt;
                  )}

                  {/* Use Button for Consumables */}
                  {isConsumable &amp;&amp; (
                    &lt;Button
                      size=&quot;sm&quot;
                      variant=&quot;outline&quot;
                      onClick={() =&gt; handleUseItem(
                        inv.id,
                        inv.item.name,
                        inv.item.energyEffect,
                        inv.item.healthEffect
                      )}
                      className=&quot;mt-1&quot;
                      disabled={wouldBeWasted || isLoading}
                      title={wouldBeWasted ?
                        `Already at full ${wouldWasteEnergy ? &#39;energy&#39; : &#39;health&#39;}` :
                        `Use ${inv.item.name}`
                      }
                    &gt;
                      {isLoading ? (
                        &lt;Loader2 className=&quot;w-3 h-3 animate-spin&quot; /&gt;
                      ) : wouldBeWasted ? &#39;Full&#39; : &#39;Use&#39;}
                    &lt;/Button&gt;
                  )}

                  {inv.isEquipped &amp;&amp; (
                    &lt;div className=&quot;text-xs text-green-600&quot;&gt;Equipped&lt;/div&gt;
                  )}
                &lt;/div&gt;
              &lt;/div&gt;
            )
          })}
        &lt;/div&gt;
      ) : (
        &lt;div className=&quot;bg-muted/50 p-8 rounded-lg text-center text-muted-foreground&quot;&gt;
          &lt;Backpack className=&quot;w-12 h-12 mx-auto mb-2&quot; /&gt;
          Your bag is empty.&lt;br /&gt;
          Start mining or visit the market!
        &lt;/div&gt;
      )}

      &lt;Button onClick={() =&gt; setCurrentView(&#39;main&#39;)} variant=&quot;ghost&quot;&gt;
        &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
        Back
      &lt;/Button&gt;
    &lt;/div&gt;
  )

  const renderChatView = () =&gt; {
    return (
      &lt;div className=&quot;space-y-4&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          &lt;h3 className=&quot;text-lg font-semibold flex items-center justify-center gap-2&quot;&gt;
            &lt;MessageCircle className=&quot;w-5 h-5&quot; /&gt;
            {selectedLocation ? selectedLocation.name : character.currentLocation.name}
          &lt;/h3&gt;
          &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;
            Local chat • {chatMessages.length} messages
          &lt;/p&gt;
        &lt;/div&gt;

        &lt;div className=&quot;bg-muted/30 rounded-lg p-3 h-64 overflow-y-auto space-y-2&quot;&gt;
          {chatMessages.length &gt; 0 ? (
            chatMessages.map(message =&gt; (
              &lt;div key={message.id} className=&quot;space-y-1&quot;&gt;
                {message.isSystem ? (
                  &lt;div className=&quot;text-xs text-center text-muted-foreground italic&quot;&gt;
                    {message.message}
                  &lt;/div&gt;
                ) : (
                  &lt;div className=&quot;space-y-1&quot;&gt;
                    &lt;div className=&quot;flex items-center gap-2 text-xs&quot;&gt;
                      &lt;div className=&quot;w-4 h-4 bg-gray-300 rounded-full flex items-center justify-center&quot;&gt;
                        {message.character?.characterType === &#39;HUMAN&#39; ? &#39;🙂&#39; : &#39;👹&#39;}
                      &lt;/div&gt;
                      &lt;span className=&quot;font-medium&quot;&gt;{message.character?.name}&lt;/span&gt;
                      &lt;span className=&quot;text-muted-foreground&quot;&gt;{message.timeAgo}&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div className=&quot;text-sm pl-6&quot;&gt;
                      {message.messageType === &#39;EMOTE&#39; ? (
                        &lt;span className=&quot;italic&quot;&gt;*{message.message}*&lt;/span&gt;
                      ) : (
                        message.message
                      )}
                    &lt;/div&gt;
                  &lt;/div&gt;
                )}
              &lt;/div&gt;
            ))
          ) : (
            &lt;div className=&quot;text-sm text-muted-foreground text-center&quot;&gt;
              No messages yet. Be the first to say something!
            &lt;/div&gt;
          )}
        &lt;/div&gt;

        &lt;div className=&quot;flex gap-2&quot;&gt;
          &lt;input
            type=&quot;text&quot;
            placeholder=&quot;Type your message...&quot;
            value={chatInput}
            onChange={(e) =&gt; setChatInput(e.target.value)}
            onKeyPress={(e) =&gt; e.key === &#39;Enter&#39; &amp;&amp; handleSendMessage()}
            className=&quot;flex-1 px-3 py-2 border rounded-md text-sm&quot;
          /&gt;
          &lt;Button size=&quot;sm&quot; onClick={handleSendMessage} disabled={!chatInput.trim()}&gt;
            &lt;Send className=&quot;w-4 h-4&quot; /&gt;
          &lt;/Button&gt;
        &lt;/div&gt;

        &lt;Button onClick={() =&gt; setCurrentView(selectedLocation ? &#39;location&#39; : &#39;main&#39;)} variant=&quot;ghost&quot;&gt;
          &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Back
        &lt;/Button&gt;
      &lt;/div&gt;
    )
  }

  return (
    &lt;div className=&quot;min-h-screen bg-background p-4&quot;&gt;
      &lt;Toaster
        position=&quot;top-center&quot;
        toastOptions={{
          style: {
            background: &#39;hsl(var(--background))&#39;,
            color: &#39;hsl(var(--foreground))&#39;,
            border: &#39;1px solid hsl(var(--border))&#39;,
          },
        }}
      /&gt;
      &lt;div className=&quot;max-w-md mx-auto&quot;&gt;
        &lt;div className=&quot;bg-card border rounded-lg p-6 shadow-sm&quot;&gt;
          &lt;h1 className=&quot;text-2xl font-bold text-center mb-6 flex items-center justify-center gap-2&quot;&gt;
            &lt;MapPin className=&quot;w-6 h-6&quot; /&gt;
            Wojak Earth
          &lt;/h1&gt;

          {currentView === &#39;main&#39; &amp;&amp; renderMainView()}
          {currentView === &#39;map&#39; &amp;&amp; renderMapView()}
          {currentView === &#39;location&#39; &amp;&amp; renderLocationView()}
          {currentView === &#39;mine&#39; &amp;&amp; renderMineView()}
          {currentView === &#39;market&#39; &amp;&amp; renderMarketView()}
          {currentView === &#39;inventory&#39; &amp;&amp; renderInventoryView()}
          {currentView === &#39;chat&#39; &amp;&amp; renderChatView()}
        &lt;/div&gt;

        {/* Game Log */}
        &lt;div className=&quot;mt-4 bg-card border rounded-lg p-4&quot;&gt;
          &lt;h4 className=&quot;font-medium mb-2&quot;&gt;Recent Activity&lt;/h4&gt;
          &lt;div className=&quot;space-y-1 text-sm&quot;&gt;
            {gameLog.map((log, i) =&gt; (
              &lt;div key={i} className=&quot;text-muted-foreground&quot;&gt;
                {log}
              &lt;/div&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}

export default App
</content>
    </document>

    <document>
      <source>index.html</source>
      <tags></tags>
      <metadata>
        <size>367</size>
        <lastModified>2025-05-28T21:48:47.451Z</lastModified>
        <extension>html</extension>
        <directory>Root</directory>
      </metadata>
      <content>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/wojak-earth.svg&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;wojak-earth&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;module&quot; src=&quot;/src/main.tsx&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</content>
    </document>

    <document>
      <source>tsconfig.app.json</source>
      <tags></tags>
      <metadata>
        <size>755</size>
        <lastModified>2025-05-28T21:48:18.933Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;compilerOptions&quot;: {
      &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [
        &quot;./src/*&quot;
      ]
    },
    &quot;tsBuildInfoFile&quot;: &quot;./node_modules/.tmp/tsconfig.app.tsbuildinfo&quot;,
    &quot;target&quot;: &quot;ES2020&quot;,
    &quot;useDefineForClassFields&quot;: true,
    &quot;lib&quot;: [&quot;ES2020&quot;, &quot;DOM&quot;, &quot;DOM.Iterable&quot;],
    &quot;module&quot;: &quot;ESNext&quot;,
    &quot;skipLibCheck&quot;: true,

    /* Bundler mode */
    &quot;moduleResolution&quot;: &quot;bundler&quot;,
    &quot;allowImportingTsExtensions&quot;: true,
    &quot;verbatimModuleSyntax&quot;: true,
    &quot;moduleDetection&quot;: &quot;force&quot;,
    &quot;noEmit&quot;: true,
    &quot;jsx&quot;: &quot;react-jsx&quot;,

    /* Linting */
    &quot;strict&quot;: true,
    &quot;noUnusedLocals&quot;: true,
    &quot;noUnusedParameters&quot;: true,
    &quot;noFallthroughCasesInSwitch&quot;: true,
    &quot;noUncheckedSideEffectImports&quot;: true
  },
  &quot;include&quot;: [&quot;src&quot;]
}
</content>
    </document>

    <document>
      <source>README.md</source>
      <tags></tags>
      <metadata>
        <size>14</size>
        <lastModified>2025-05-28T21:49:18.650Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content># wojak-earth
</content>
    </document>

    <document>
      <source>tsconfig.node.json</source>
      <tags></tags>
      <metadata>
        <size>598</size>
        <lastModified>2025-05-28T21:46:21.462Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;compilerOptions&quot;: {
    &quot;tsBuildInfoFile&quot;: &quot;./node_modules/.tmp/tsconfig.node.tsbuildinfo&quot;,
    &quot;target&quot;: &quot;ES2022&quot;,
    &quot;lib&quot;: [&quot;ES2023&quot;],
    &quot;module&quot;: &quot;ESNext&quot;,
    &quot;skipLibCheck&quot;: true,

    /* Bundler mode */
    &quot;moduleResolution&quot;: &quot;bundler&quot;,
    &quot;allowImportingTsExtensions&quot;: true,
    &quot;verbatimModuleSyntax&quot;: true,
    &quot;moduleDetection&quot;: &quot;force&quot;,
    &quot;noEmit&quot;: true,

    /* Linting */
    &quot;strict&quot;: true,
    &quot;noUnusedLocals&quot;: true,
    &quot;noUnusedParameters&quot;: true,
    &quot;noFallthroughCasesInSwitch&quot;: true,
    &quot;noUncheckedSideEffectImports&quot;: true
  },
  &quot;include&quot;: [&quot;vite.config.ts&quot;]
}
</content>
    </document>

    <document>
      <source>.gitignore</source>
      <tags></tags>
      <metadata>
        <size>292</size>
        <lastModified>2025-05-28T23:07:21.376Z</lastModified>
        <extension>gitignore</extension>
        <directory>Root</directory>
      </metadata>
      <content># Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

.env

# Local Netlify folder
.netlify
</content>
    </document>

    <document>
      <source>TODO.md</source>
      <tags></tags>
      <metadata>
        <size>5874</size>
        <lastModified>2025-05-29T04:23:56.038Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content># Wojak Earth - HONEST Project Status &amp; TODO

Updated: **May 2025** 🔍

## **✅ ACTUALLY WORKING FEATURES**

### Database &amp; Core Infrastructure

- ✅ Full Prisma schema with all models and relationships
- ✅ Database seeded with comprehensive test data
- ✅ Hierarchical location system working
- ✅ React/TypeScript frontend structure
- ✅ Type interfaces moved to separate file for better organization

### Verified Working Systems

- ✅ **Character Display**: Shows character data, energy, health, inventory
- ✅ **Location Navigation**: Map view, location selection, travel UI
- ✅ **Travel System**: Can move between locations (API working with smooth animation)
- ✅ **UI Framework**: All views render, navigation works
- ✅ **Game Activity Log**: Shows recent actions and updates

### Serverless Functions Status

- ✅ `get-character.js` - **WORKING** (4,642 bytes, tested)
- ✅ `get-locations.js` - **WORKING** (hierarchical locations with player counts)
- ✅ `get-players-at-location.js` - **WORKING** (2,971 bytes)
- ✅ `get-chat.js` - **WORKING** (4,454 bytes)
- ✅ `travel-action.js` - **WORKING** (5,685 bytes)
- ✅ `mine-action.js` - **WORKING** (6,197 bytes, tested)
- ✅ `get-market.js` - **WORKING** (Fixed, supports hierarchical markets)
- ✅ `buy-item.js` - **WORKING** (Proper system/player item handling)
- ✅ `equip-item.js` - **WORKING** (Equip/unequip functionality)
- ✅ `use-item.js` - **WORKING** (NEW: Consumable system)
- ✅ `send-message.js` - **WORKING** (Chat messaging)

## **🚀 RECENTLY COMPLETED FEATURES**

### Market System ✅

- ✅ **Hierarchical Markets**: Parent/child location market inheritance
- ✅ **Tabbed Interface**: Local Specialties vs Global Market
- ✅ **System Item Management**: Items stay in DB when sold out, can be restocked
- ✅ **Market Seed Script**: Game master powers to restock any market
- ✅ **Purchase Flow**: Complete buy-item functionality working

### Equipment System ✅

- ✅ **Equip/Unequip**: Full equipment management
- ✅ **Visual Indicators**: Shows equipped status
- ✅ **Layer-based Logic**: Items conflict properly (same layer type)

### Consumable System ✅ **NEW**

- ✅ **Use Button**: Consumables can be used from inventory
- ✅ **Effect Application**: Energy/health restoration working
- ✅ **Smart Prevention**: Won&#39;t waste consumables at full stats
- ✅ **Quantity Management**: Items reduce quantity or disappear when used
- ✅ **Visual Feedback**: Shows effects preview in inventory

### UX Improvements ✅ **NEW**

- ✅ **Toast Notifications**: Sonner integration for smooth feedback
- ✅ **Loading States**: Individual button spinners (no more full page reload)
- ✅ **Optimistic Updates**: UI updates immediately, feels instant
- ✅ **Error Handling**: Proper error messages via toasts

### Mining System ✅

- ✅ **Mining Functionality**: Actually works with real resource spawning
- ✅ **Energy Consumption**: Costs 10 energy per attempt
- ✅ **Resource Discovery**: Items added to inventory
- ✅ **Location-based Resources**: Different items in different locations

### Chat System ✅

- ✅ **Message Loading**: Displays existing chat history
- ✅ **Message Sending**: Can send new messages
- ✅ **Real-time Feel**: Messages appear immediately
- ✅ **Scope Handling**: Local vs regional chat working

## **🔧 TECHNICAL IMPROVEMENTS**

### Code Quality ✅ **NEW**

- ✅ **Type Organization**: Moved interfaces to `src/types/index.ts`
- ✅ **ES Module Consistency**: All functions use proper import/export
- ✅ **Error Handling**: Comprehensive error states and user feedback
- ✅ **Loading States**: Proper async state management

### Game Master Tools ✅ **NEW**

- ✅ **Market Seed Script**: `npm run seed:markets` for restocking
- ✅ **Location-specific Configs**: Different inventory per location
- ✅ **Flexible Commands**: Can target specific locations or clear/restock all

## **🚧 AREAS FOR FUTURE ENHANCEMENT**

### Component Architecture

- ⚠️ **App.tsx is large** - Could benefit from component splitting
- 💡 **Future**: Split into `&lt;InventoryView /&gt;`, `&lt;MarketView /&gt;`, `&lt;MiningView /&gt;` etc.

### Advanced Features (Not MVP)

- ❌ **NFT Integration**: No blockchain connection yet
- ❌ **Wallet Connection**: No Web3 integration
- ❌ **Image Generation**: Layer system exists but PNG rendering not implemented
- ❌ **Player-to-Player Trading**: Only system items available
- ❌ **Currency System**: No actual coin deduction (purchases are free)
- ❌ **Level/XP System**: No character progression mechanics
- ❌ **Guilds/Teams**: No social systems beyond chat

### Performance &amp; Polish

- 💡 **Rich Toast Content**: Could add more detailed notifications
- 💡 **Image Optimization**: Layer assets could be compressed
- 💡 **Caching**: Could implement better data caching strategies
- 💡 **Animation Polish**: Could add more game feel animations

## **🎯 CURRENT STATUS: SOLID MVP**

The core game loop is **fully functional**:

1. ✅ **Explore** different locations
2. ✅ **Mine** for resources (costs energy)
3. ✅ **Buy/Sell** items at markets
4. ✅ **Equip** gear for your character
5. ✅ **Use** consumables to restore energy/health
6. ✅ **Chat** with other players
7. ✅ **Travel** between interconnected locations

## **🏆 WHAT WORKS REALLY WELL**

- **Smooth UX**: No jarring page reloads, instant feedback
- **Hierarchical World**: Locations feel connected and purposeful
- **Market Economy**: Different locations have different specialties
- **Resource Management**: Energy/health/inventory systems work together
- **Game Master Tools**: Easy to manage and expand content

## **💭 NEXT PRIORITIES** (if desired)

1. **Component Refactoring**: Break down App.tsx for maintainability
2. **Currency System**: Add actual coin management to purchases
3. **Player-to-Player Trading**: Enable real marketplace between players
4. **Character Progression**: Add leveling/Xp system
5. **Layer Image Rendering**: Complete the PNG generation system
</content>
    </document>

    <document>
      <source>package.json</source>
      <tags></tags>
      <metadata>
        <size>1294</size>
        <lastModified>2025-05-29T04:08:23.455Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;name&quot;: &quot;wojak-earth&quot;,
  &quot;private&quot;: true,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;vite&quot;,
    &quot;build&quot;: &quot;tsc -b &amp;&amp; vite build&quot;,
    &quot;lint&quot;: &quot;eslint .&quot;,
    &quot;preview&quot;: &quot;vite preview&quot;,
    &quot;db:seed&quot;: &quot;tsx prisma/seed.ts&quot;,
    &quot;seed:markets&quot;: &quot;tsx scripts/seed-markets.ts&quot;
  },
  &quot;prisma&quot;: {
    &quot;seed&quot;: &quot;tsx prisma/seed.ts&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@prisma/client&quot;: &quot;^6.8.2&quot;,
    &quot;@radix-ui/react-dropdown-menu&quot;: &quot;^2.1.15&quot;,
    &quot;@radix-ui/react-slot&quot;: &quot;^1.2.3&quot;,
    &quot;@tailwindcss/vite&quot;: &quot;^4.1.8&quot;,
    &quot;class-variance-authority&quot;: &quot;^0.7.1&quot;,
    &quot;clsx&quot;: &quot;^2.1.1&quot;,
    &quot;lucide-react&quot;: &quot;^0.511.0&quot;,
    &quot;next-themes&quot;: &quot;^0.4.6&quot;,
    &quot;prisma&quot;: &quot;^6.8.2&quot;,
    &quot;react&quot;: &quot;^19.1.0&quot;,
    &quot;react-dom&quot;: &quot;^19.1.0&quot;,
    &quot;sonner&quot;: &quot;^2.0.3&quot;,
    &quot;tailwind-merge&quot;: &quot;^3.3.0&quot;,
    &quot;tailwindcss&quot;: &quot;^4.1.8&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@eslint/js&quot;: &quot;^9.25.0&quot;,
    &quot;@types/node&quot;: &quot;^22.15.24&quot;,
    &quot;@types/react&quot;: &quot;^19.1.2&quot;,
    &quot;@types/react-dom&quot;: &quot;^19.1.2&quot;,
    &quot;@vitejs/plugin-react&quot;: &quot;^4.4.1&quot;,
    &quot;eslint&quot;: &quot;^9.25.0&quot;,
    &quot;eslint-plugin-react-hooks&quot;: &quot;^5.2.0&quot;,
    &quot;eslint-plugin-react-refresh&quot;: &quot;^0.4.19&quot;,
    &quot;globals&quot;: &quot;^16.0.0&quot;,
    &quot;tsx&quot;: &quot;^4.19.4&quot;,
    &quot;tw-animate-css&quot;: &quot;^1.3.0&quot;,
    &quot;typescript&quot;: &quot;~5.8.3&quot;,
    &quot;typescript-eslint&quot;: &quot;^8.30.1&quot;,
    &quot;vite&quot;: &quot;^6.3.5&quot;
  }
}
</content>
    </document>

    <document>
      <source>.env</source>
      <tags></tags>
      <metadata>
        <size>135</size>
        <lastModified>2025-05-28T21:52:13.504Z</lastModified>
        <extension>env</extension>
        <directory>Root</directory>
      </metadata>
      <content>DATABASE_URL=postgresql://neondb_owner:npg_su0rywczKEv9@ep-lively-river-a6lm0x4f-pooler.us-west-2.aws.neon.tech/neondb?sslmode=require
</content>
    </document>

    <document>
      <source>components.json</source>
      <tags></tags>
      <metadata>
        <size>423</size>
        <lastModified>2025-05-28T21:46:42.115Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;$schema&quot;: &quot;https://ui.shadcn.com/schema.json&quot;,
  &quot;style&quot;: &quot;new-york&quot;,
  &quot;rsc&quot;: false,
  &quot;tsx&quot;: true,
  &quot;tailwind&quot;: {
    &quot;config&quot;: &quot;&quot;,
    &quot;css&quot;: &quot;src/index.css&quot;,
    &quot;baseColor&quot;: &quot;stone&quot;,
    &quot;cssVariables&quot;: true,
    &quot;prefix&quot;: &quot;&quot;
  },
  &quot;aliases&quot;: {
    &quot;components&quot;: &quot;@/components&quot;,
    &quot;utils&quot;: &quot;@/lib/utils&quot;,
    &quot;ui&quot;: &quot;@/components/ui&quot;,
    &quot;lib&quot;: &quot;@/lib&quot;,
    &quot;hooks&quot;: &quot;@/hooks&quot;
  },
  &quot;iconLibrary&quot;: &quot;lucide&quot;
}</content>
    </document>

    <document>
      <source>tsconfig.json</source>
      <tags></tags>
      <metadata>
        <size>233</size>
        <lastModified>2025-05-28T21:45:45.831Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;files&quot;: [],
  &quot;references&quot;: [
    {
      &quot;path&quot;: &quot;./tsconfig.app.json&quot;
    },
    {
      &quot;path&quot;: &quot;./tsconfig.node.json&quot;
    }
  ],
  &quot;compilerOptions&quot;: {
    &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [&quot;./src/*&quot;]
    }
  }
}
</content>
    </document>

    <document>
      <source>eslint.config.js</source>
      <tags></tags>
      <metadata>
        <size>734</size>
        <lastModified>2025-05-28T21:44:35.037Z</lastModified>
        <extension>js</extension>
        <directory>Root</directory>
      </metadata>
      <content>import js from &#39;@eslint/js&#39;
import globals from &#39;globals&#39;
import reactHooks from &#39;eslint-plugin-react-hooks&#39;
import reactRefresh from &#39;eslint-plugin-react-refresh&#39;
import tseslint from &#39;typescript-eslint&#39;

export default tseslint.config(
  { ignores: [&#39;dist&#39;] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: [&#39;**/*.{ts,tsx}&#39;],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      &#39;react-hooks&#39;: reactHooks,
      &#39;react-refresh&#39;: reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      &#39;react-refresh/only-export-components&#39;: [
        &#39;warn&#39;,
        { allowConstantExport: true },
      ],
    },
  },
)
</content>
    </document>

    <document>
      <source>vite.config.ts</source>
      <tags></tags>
      <metadata>
        <size>327</size>
        <lastModified>2025-05-28T21:46:16.230Z</lastModified>
        <extension>ts</extension>
        <directory>Root</directory>
      </metadata>
      <content>import path from &#39;path&#39;
import tailwindcss from &#39;@tailwindcss/vite&#39;
import react from &#39;@vitejs/plugin-react&#39;
import { defineConfig } from &#39;vite&#39;

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      &#39;@&#39;: path.resolve(__dirname, &#39;./src&#39;),
    },
  },
})
</content>
    </document>
    
  </documents>

</bundle>