<?xml version="1.0" encoding="UTF-8"?>
<bundle id="master-2025-05-29T13-24-46-833Z" created="2025-05-29T13:24:46.833Z" fileCount="70">
  
  <metadata>
    <projectName>project</projectName>
    <totalFiles>70</totalFiles>
    <bundleType>master</bundleType>
    <ignorePatterns>
      <pattern>node_modules</pattern>
      <pattern>.git</pattern>
      <pattern>dist</pattern>
      <pattern>build</pattern>
      <pattern>coverage</pattern>
      <pattern>.next</pattern>
      <pattern>.cache</pattern>
      <pattern>.netlify</pattern>
      <pattern>package-lock.json</pattern>
      <pattern>yarn.lock</pattern>
      <pattern>.DS_Store</pattern>
      <pattern>Thumbs.db</pattern>
      <pattern>*.mp3</pattern>
      <pattern>*.mp4</pattern>
      <pattern>*.wav</pattern>
      <pattern>*.ogg</pattern>
      <pattern>*.m4a</pattern>
      <pattern>*.flac</pattern>
      <pattern>*.jpg</pattern>
      <pattern>*.jpeg</pattern>
      <pattern>*.gif</pattern>
      <pattern>*.webp</pattern>
      <pattern>*.svg</pattern>
      <pattern>*.ico</pattern>
      <pattern>*.pxd</pattern>
      <pattern>*.pdf</pattern>
      <pattern>*.doc</pattern>
      <pattern>*.docx</pattern>
      <pattern>*.zip</pattern>
      <pattern>*.tar</pattern>
      <pattern>*.gz</pattern>
      <pattern>*.rar</pattern>
      <pattern>*.png</pattern>
    </ignorePatterns>
  </metadata>

  <directoryTree>
  <directory name="netlify" path="netlify">
    <directory name="functions" path="netlify/functions">
      <file name="buy-item.js" path="netlify/functions/buy-item.js" size="0" lastModified="2025-05-29T03:25:43.591Z">
        <tags></tags>
      </file>
      <file name="equip-item.js" path="netlify/functions/equip-item.js" size="0" lastModified="2025-05-29T05:38:49.985Z">
        <tags></tags>
      </file>
      <file name="get-character.js" path="netlify/functions/get-character.js" size="0" lastModified="2025-05-28T23:17:38.002Z">
        <tags></tags>
      </file>
      <file name="get-chat.js" path="netlify/functions/get-chat.js" size="0" lastModified="2025-05-28T23:51:59.175Z">
        <tags></tags>
      </file>
      <file name="get-locations.js" path="netlify/functions/get-locations.js" size="0" lastModified="2025-05-29T00:12:36.034Z">
        <tags></tags>
      </file>
      <file name="get-market.js" path="netlify/functions/get-market.js" size="0" lastModified="2025-05-29T03:47:50.500Z">
        <tags></tags>
      </file>
      <file name="get-players-at-location.js" path="netlify/functions/get-players-at-location.js" size="0" lastModified="2025-05-28T23:55:02.361Z">
        <tags></tags>
      </file>
      <file name="metadata.js" path="netlify/functions/metadata.js" size="0" lastModified="2025-05-29T02:46:06.495Z">
        <tags></tags>
      </file>
      <file name="mine-action.js" path="netlify/functions/mine-action.js" size="0" lastModified="2025-05-29T07:11:55.499Z">
        <tags></tags>
      </file>
      <file name="render-character.js" path="netlify/functions/render-character.js" size="0" lastModified="2025-05-29T02:46:20.676Z">
        <tags></tags>
      </file>
      <file name="send-message.js" path="netlify/functions/send-message.js" size="0" lastModified="2025-05-29T00:06:10.082Z">
        <tags></tags>
      </file>
      <file name="travel-action.js" path="netlify/functions/travel-action.js" size="0" lastModified="2025-05-28T23:30:33.914Z">
        <tags></tags>
      </file>
      <file name="use-item.js" path="netlify/functions/use-item.js" size="0" lastModified="2025-05-29T04:02:05.691Z">
        <tags></tags>
      </file>
    </directory>
  </directory>
  <directory name="prisma" path="prisma">
    <file name="schema.prisma" path="prisma/schema.prisma" size="0" lastModified="2025-05-28T22:31:59.236Z">
      <tags></tags>
    </file>
    <file name="seed.ts" path="prisma/seed.ts" size="0" lastModified="2025-05-28T23:49:37.575Z">
      <tags></tags>
    </file>
  </directory>
  <directory name="scripts" path="scripts">
    <file name="add-new-regions.ts" path="scripts/add-new-regions.ts" size="0" lastModified="2025-05-29T08:48:57.681Z">
      <tags></tags>
    </file>
    <file name="add-proper-tools.ts" path="scripts/add-proper-tools.ts" size="0" lastModified="2025-05-29T06:21:08.021Z">
      <tags></tags>
    </file>
    <file name="add-themed-items.ts" path="scripts/add-themed-items.ts" size="0" lastModified="2025-05-29T05:47:45.577Z">
      <tags></tags>
    </file>
    <file name="debug-market-locations.ts" path="scripts/debug-market-locations.ts" size="0" lastModified="2025-05-29T06:00:54.267Z">
      <tags></tags>
    </file>
    <file name="fix-market-locations.ts" path="scripts/fix-market-locations.ts" size="0" lastModified="2025-05-29T06:07:56.390Z">
      <tags></tags>
    </file>
    <file name="seed-enhanced-markets.ts" path="scripts/seed-enhanced-markets.ts" size="0" lastModified="2025-05-29T06:25:23.751Z">
      <tags></tags>
    </file>
    <file name="seed-markets.ts" path="scripts/seed-markets.ts" size="0" lastModified="2025-05-29T06:22:57.295Z">
      <tags></tags>
    </file>
    <file name="seed-mining-resources.ts" path="scripts/seed-mining-resources.ts" size="0" lastModified="2025-05-29T04:58:00.336Z">
      <tags></tags>
    </file>
    <file name="setup-complete-game.ts" path="scripts/setup-complete-game.ts" size="0" lastModified="2025-05-29T06:32:31.722Z">
      <tags></tags>
    </file>
    <file name="setup-new-regions-content.ts" path="scripts/setup-new-regions-content.ts" size="0" lastModified="2025-05-29T10:04:14.004Z">
      <tags></tags>
    </file>
    <file name="ultimate-world-setup.ts" path="scripts/ultimate-world-setup.ts" size="0" lastModified="2025-05-29T10:08:28.693Z">
      <tags></tags>
    </file>
    <file name="update-mining-with-tools.ts" path="scripts/update-mining-with-tools.ts" size="0" lastModified="2025-05-29T06:21:32.931Z">
      <tags></tags>
    </file>
  </directory>
  <directory name="src" path="src">
    <directory name="components" path="src/components">
      <directory name="ui" path="src/components/ui">
        <file name="avatar.tsx" path="src/components/ui/avatar.tsx" size="0" lastModified="2025-05-29T08:13:25.444Z">
          <tags></tags>
        </file>
        <file name="badge.tsx" path="src/components/ui/badge.tsx" size="0" lastModified="2025-05-29T08:13:25.456Z">
          <tags></tags>
        </file>
        <file name="button.tsx" path="src/components/ui/button.tsx" size="0" lastModified="2025-05-28T21:47:16.145Z">
          <tags></tags>
        </file>
        <file name="dialog.tsx" path="src/components/ui/dialog.tsx" size="0" lastModified="2025-05-29T08:13:25.281Z">
          <tags></tags>
        </file>
        <file name="dropdown-menu.tsx" path="src/components/ui/dropdown-menu.tsx" size="0" lastModified="2025-05-29T00:35:27.082Z">
          <tags></tags>
        </file>
        <file name="scroll-area.tsx" path="src/components/ui/scroll-area.tsx" size="0" lastModified="2025-05-29T08:13:25.435Z">
          <tags></tags>
        </file>
        <file name="sonner.tsx" path="src/components/ui/sonner.tsx" size="0" lastModified="2025-05-29T04:28:51.400Z">
          <tags></tags>
        </file>
        <file name="tabs.tsx" path="src/components/ui/tabs.tsx" size="0" lastModified="2025-05-29T11:14:29.295Z">
          <tags></tags>
        </file>
        <file name="tooltip.tsx" path="src/components/ui/tooltip.tsx" size="0" lastModified="2025-05-29T11:09:24.963Z">
          <tags></tags>
        </file>
      </directory>
      <directory name="views" path="src/components/views">
        <file name="index.ts" path="src/components/views/index.ts" size="0" lastModified="2025-05-29T11:12:15.786Z">
          <tags></tags>
        </file>
        <file name="InventoryView.tsx" path="src/components/views/InventoryView.tsx" size="0" lastModified="2025-05-29T11:14:50.302Z">
          <tags></tags>
        </file>
        <file name="MarketView.tsx" path="src/components/views/MarketView.tsx" size="0" lastModified="2025-05-29T04:43:00.072Z">
          <tags></tags>
        </file>
        <file name="MiningView.tsx" path="src/components/views/MiningView.tsx" size="0" lastModified="2025-05-29T05:11:37.300Z">
          <tags></tags>
        </file>
        <file name="WorldMapView.tsx" path="src/components/views/WorldMapView.tsx" size="0" lastModified="2025-05-29T12:27:30.500Z">
          <tags></tags>
        </file>
      </directory>
      <file name="mode-toggle.tsx" path="src/components/mode-toggle.tsx" size="0" lastModified="2025-05-29T00:32:40.806Z">
        <tags></tags>
      </file>
      <file name="theme-provider.tsx" path="src/components/theme-provider.tsx" size="0" lastModified="2025-05-29T00:31:34.688Z">
        <tags></tags>
      </file>
      <file name="wallet-connect-button.tsx" path="src/components/wallet-connect-button.tsx" size="0" lastModified="2025-05-29T08:13:24.988Z">
        <tags></tags>
      </file>
      <file name="wallet-provider.tsx" path="src/components/wallet-provider.tsx" size="0" lastModified="2025-05-29T08:13:24.629Z">
        <tags></tags>
      </file>
      <file name="wallet-select-modal.tsx" path="src/components/wallet-select-modal.tsx" size="0" lastModified="2025-05-29T08:13:25.130Z">
        <tags></tags>
      </file>
    </directory>
    <directory name="lib" path="src/lib">
      <file name="layerResolver.ts" path="src/lib/layerResolver.ts" size="0" lastModified="2025-05-29T02:27:27.011Z">
        <tags></tags>
      </file>
      <file name="utils.ts" path="src/lib/utils.ts" size="0" lastModified="2025-05-28T21:46:49.754Z">
        <tags></tags>
      </file>
    </directory>
    <directory name="types" path="src/types">
      <file name="index.ts" path="src/types/index.ts" size="0" lastModified="2025-05-29T07:19:18.019Z">
        <tags></tags>
      </file>
    </directory>
    <file name="App.css" path="src/App.css" size="0" lastModified="2025-05-28T21:44:35.041Z">
      <tags></tags>
    </file>
    <file name="App.tsx" path="src/App.tsx" size="0" lastModified="2025-05-29T12:22:54.002Z">
      <tags></tags>
    </file>
    <file name="index.css" path="src/index.css" size="0" lastModified="2025-05-28T21:46:42.653Z">
      <tags></tags>
    </file>
    <file name="main.tsx" path="src/main.tsx" size="0" lastModified="2025-05-29T07:59:24.953Z">
      <tags></tags>
    </file>
    <file name="vite-env.d.ts" path="src/vite-env.d.ts" size="0" lastModified="2025-05-28T21:44:35.044Z">
      <tags></tags>
    </file>
  </directory>
  <file name=".env" path=".env" size="0" lastModified="2025-05-28T21:52:13.504Z">
    <tags></tags>
  </file>
  <file name=".gitignore" path=".gitignore" size="0" lastModified="2025-05-28T23:07:21.376Z">
    <tags></tags>
  </file>
  <file name="components.json" path="components.json" size="0" lastModified="2025-05-28T21:46:42.115Z">
    <tags></tags>
  </file>
  <file name="eslint.config.js" path="eslint.config.js" size="0" lastModified="2025-05-28T21:44:35.037Z">
    <tags></tags>
  </file>
  <file name="index.html" path="index.html" size="0" lastModified="2025-05-28T21:48:47.451Z">
    <tags></tags>
  </file>
  <file name="LITEPAPER.md" path="LITEPAPER.md" size="0" lastModified="2025-05-29T13:15:03.925Z">
    <tags></tags>
  </file>
  <file name="NFT.md" path="NFT.md" size="0" lastModified="2025-05-29T13:22:36.411Z">
    <tags></tags>
  </file>
  <file name="package.json" path="package.json" size="0" lastModified="2025-05-29T11:14:27.449Z">
    <tags></tags>
  </file>
  <file name="PITCHDECK.md" path="PITCHDECK.md" size="0" lastModified="2025-05-29T13:01:27.667Z">
    <tags></tags>
  </file>
  <file name="README.md" path="README.md" size="0" lastModified="2025-05-29T13:12:00.912Z">
    <tags></tags>
  </file>
  <file name="TODO.md" path="TODO.md" size="0" lastModified="2025-05-29T12:58:43.062Z">
    <tags></tags>
  </file>
  <file name="tsconfig.app.json" path="tsconfig.app.json" size="0" lastModified="2025-05-28T21:48:18.933Z">
    <tags></tags>
  </file>
  <file name="tsconfig.json" path="tsconfig.json" size="0" lastModified="2025-05-28T21:45:45.831Z">
    <tags></tags>
  </file>
  <file name="tsconfig.node.json" path="tsconfig.node.json" size="0" lastModified="2025-05-28T21:46:21.462Z">
    <tags></tags>
  </file>
  <file name="vite.config.ts" path="vite.config.ts" size="0" lastModified="2025-05-28T21:46:16.230Z">
    <tags></tags>
  </file>
  <file name="WHITEPAPER.md" path="WHITEPAPER.md" size="0" lastModified="2025-05-29T13:03:30.347Z">
    <tags></tags>
  </file>
</directoryTree>

  <asciiTree>
project/
├── netlify/
│   └── functions/
│       ├── buy-item.js
│       ├── equip-item.js
│       ├── get-character.js
│       ├── get-chat.js
│       ├── get-locations.js
│       ├── get-market.js
│       ├── get-players-at-location.js
│       ├── metadata.js
│       ├── mine-action.js
│       ├── render-character.js
│       ├── send-message.js
│       ├── travel-action.js
│       └── use-item.js
├── prisma/
│   ├── schema.prisma
│   └── seed.ts
├── scripts/
│   ├── add-new-regions.ts
│   ├── add-proper-tools.ts
│   ├── add-themed-items.ts
│   ├── debug-market-locations.ts
│   ├── fix-market-locations.ts
│   ├── seed-enhanced-markets.ts
│   ├── seed-markets.ts
│   ├── seed-mining-resources.ts
│   ├── setup-complete-game.ts
│   ├── setup-new-regions-content.ts
│   ├── ultimate-world-setup.ts
│   └── update-mining-with-tools.ts
├── src/
│   ├── components/
│   │   ├── ui/
│   │   │   ├── avatar.tsx
│   │   │   ├── badge.tsx
│   │   │   ├── button.tsx
│   │   │   ├── dialog.tsx
│   │   │   ├── dropdown-menu.tsx
│   │   │   ├── scroll-area.tsx
│   │   │   ├── sonner.tsx
│   │   │   ├── tabs.tsx
│   │   │   └── tooltip.tsx
│   │   ├── views/
│   │   │   ├── index.ts
│   │   │   ├── InventoryView.tsx
│   │   │   ├── MarketView.tsx
│   │   │   ├── MiningView.tsx
│   │   │   └── WorldMapView.tsx
│   │   ├── mode-toggle.tsx
│   │   ├── theme-provider.tsx
│   │   ├── wallet-connect-button.tsx
│   │   ├── wallet-provider.tsx
│   │   └── wallet-select-modal.tsx
│   ├── lib/
│   │   ├── layerResolver.ts
│   │   └── utils.ts
│   ├── types/
│   │   └── index.ts
│   ├── App.css
│   ├── App.tsx
│   ├── index.css
│   ├── main.tsx
│   └── vite-env.d.ts
├── .env
├── .gitignore
├── components.json
├── eslint.config.js
├── index.html
├── LITEPAPER.md
├── NFT.md
├── package.json
├── PITCHDECK.md
├── README.md
├── TODO.md
├── tsconfig.app.json
├── tsconfig.json
├── tsconfig.node.json
├── vite.config.ts
└── WHITEPAPER.md

70 files, 10 directories
  </asciiTree>

  <documents>
    
    <document>
      <source>prisma/seed.ts</source>
      <tags></tags>
      <metadata>
        <size>21139</size>
        <lastModified>2025-05-28T23:49:37.575Z</lastModified>
        <extension>ts</extension>
        <directory>prisma</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

async function main() {
  console.log(&#39;🌱 Starting expanded database seed...&#39;)

  // Clean existing data (optional - remove in production)
  await prisma.chatMessage.deleteMany()
  await prisma.marketListing.deleteMany()
  await prisma.locationResource.deleteMany()
  await prisma.characterInventory.deleteMany()
  await prisma.characterImage.deleteMany()
  await prisma.transaction.deleteMany()
  await prisma.character.deleteMany()
  await prisma.location.deleteMany()
  await prisma.item.deleteMany()

  console.log(&#39;🧹 Cleaned existing data&#39;)

  // Create Items first (same as before)
  const items = await Promise.all([
    // Mining Materials
    prisma.item.create({
      data: {
        name: &#39;Dirty Coal&#39;,
        description: &#39;Basic fuel found in shallow mines&#39;,
        category: &#39;MATERIAL&#39;,
        rarity: &#39;COMMON&#39;,
        imageUrl: &#39;/items/dirty-coal.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Iron Scraps&#39;,
        description: &#39;Rusty metal pieces, still useful&#39;,
        category: &#39;MATERIAL&#39;,
        rarity: &#39;COMMON&#39;,
        imageUrl: &#39;/items/iron-scraps.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Ancient Coin&#39;,
        description: &#39;Currency from a forgotten civilization&#39;,
        category: &#39;MATERIAL&#39;,
        rarity: &#39;RARE&#39;,
        imageUrl: &#39;/items/ancient-coin.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Crystal Shard&#39;,
        description: &#39;Glowing fragment with mysterious properties&#39;,
        category: &#39;MATERIAL&#39;,
        rarity: &#39;EPIC&#39;,
        imageUrl: &#39;/items/crystal-shard.png&#39;,
      },
    }),

    // Equipment
    prisma.item.create({
      data: {
        name: &#39;Miners Hat&#39;,
        description: &#39;Worn leather hat with a dim headlamp&#39;,
        category: &#39;HAT&#39;,
        layerType: &#39;HAT&#39;,
        rarity: &#39;COMMON&#39;,
        durability: 100,
        energyEffect: 5,
        imageUrl: &#39;/items/miners-hat.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Work Gloves&#39;,
        description: &#39;Tough gloves for manual labor&#39;,
        category: &#39;CLOTHING&#39;,
        layerType: &#39;ACCESSORY&#39;,
        rarity: &#39;COMMON&#39;,
        durability: 80,
        imageUrl: &#39;/items/work-gloves.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Lucky Charm&#39;,
        description: &quot;A rabbit&#39;s foot that might bring fortune&quot;,
        category: &#39;ACCESSORY&#39;,
        layerType: &#39;ACCESSORY&#39;,
        rarity: &#39;UNCOMMON&#39;,
        imageUrl: &#39;/items/lucky-charm.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Cyber Jacket&#39;,
        description: &#39;High-tech jacket with built-in displays&#39;,
        category: &#39;CLOTHING&#39;,
        layerType: &#39;CLOTHING&#39;,
        rarity: &#39;RARE&#39;,
        energyEffect: 15,
        imageUrl: &#39;/items/cyber-jacket.png&#39;,
      },
    }),

    // Consumables
    prisma.item.create({
      data: {
        name: &#39;Energy Drink&#39;,
        description: &#39;Restores energy and keeps you alert&#39;,
        category: &#39;CONSUMABLE&#39;,
        rarity: &#39;COMMON&#39;,
        energyEffect: 25,
        imageUrl: &#39;/items/energy-drink.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Health Potion&#39;,
        description: &#39;Mysterious red liquid that heals wounds&#39;,
        category: &#39;CONSUMABLE&#39;,
        rarity: &#39;UNCOMMON&#39;,
        healthEffect: 30,
        imageUrl: &#39;/items/health-potion.png&#39;,
      },
    }),
  ])

  console.log(`✨ Created ${items.length} items`)

  // Create top-level locations (same as before)
  const miningPlains = await prisma.location.create({
    data: {
      name: &#39;Mining Plains&#39;,
      description: &#39;Rich in basic materials and perfect for newcomers&#39;,
      locationType: &#39;REGION&#39;,
      biome: &#39;plains&#39;,
      difficulty: 1,
      playerCount: 8, // Will be updated by actual characters
      lastActive: new Date(Date.now() - 2 * 60 * 1000),
      hasMarket: true,
      hasMining: true,
      hasChat: true,
      chatScope: &#39;REGIONAL&#39;,
      welcomeMessage: &#39;The wind carries the sound of pickaxes striking stone.&#39;,
      lore: &#39;Once a vast battlefield, these plains now serve as the primary mining grounds for new arrivals to Earth.&#39;,
      mapX: 100,
      mapY: 200,
    },
  })

  const desertOutpost = await prisma.location.create({
    data: {
      name: &#39;Desert Outpost&#39;,
      description: &#39;Harsh but rewarding terrain for experienced miners&#39;,
      locationType: &#39;REGION&#39;,
      biome: &#39;desert&#39;,
      difficulty: 3,
      playerCount: 3,
      lastActive: new Date(Date.now() - 12 * 60 * 1000),
      hasMarket: true,
      hasMining: true,
      hasChat: true,
      chatScope: &#39;REGIONAL&#39;,
      welcomeMessage: &#39;The scorching sun beats down mercilessly.&#39;,
      lore: &#39;A remote trading post built around an ancient oasis.&#39;,
      mapX: 400,
      mapY: 100,
    },
  })

  const cyberCity = await prisma.location.create({
    data: {
      name: &#39;Cyber City&#39;,
      description: &#39;The technological heart of wojak civilization&#39;,
      locationType: &#39;CITY&#39;,
      biome: &#39;urban&#39;,
      difficulty: 2,
      playerCount: 12,
      lastActive: new Date(Date.now() - 30 * 1000),
      hasMarket: true,
      hasMining: false,
      hasChat: true,
      chatScope: &#39;LOCAL&#39;,
      welcomeMessage: &#39;Neon lights flicker in the perpetual twilight.&#39;,
      lore: &#39;The beating heart of wojak civilization.&#39;,
      mapX: 300,
      mapY: 300,
    },
  })

  // Create sub-locations
  const rustyPickaxeInn = await prisma.location.create({
    data: {
      name: &#39;Rusty Pickaxe Inn&#39;,
      description: &#39;A cozy tavern where miners share stories and ale&#39;,
      locationType: &#39;BUILDING&#39;,
      parentLocationId: miningPlains.id,
      difficulty: 1,
      playerCount: 4,
      lastActive: new Date(Date.now() - 5 * 60 * 1000),
      hasMarket: true,
      hasMining: false,
      hasChat: true,
      chatScope: &#39;LOCAL&#39;,
      welcomeMessage: &#39;The smell of ale and roasted meat fills the air.&#39;,
    },
  })

  const crystalCaves = await prisma.location.create({
    data: {
      name: &#39;Crystal Caves&#39;,
      description: &#39;Deep underground shafts where rare crystals grow&#39;,
      locationType: &#39;BUILDING&#39;,
      parentLocationId: miningPlains.id,
      difficulty: 2,
      playerCount: 4,
      lastActive: new Date(Date.now() - 1 * 60 * 1000),
      hasMarket: false,
      hasMining: true,
      hasChat: true,
      chatScope: &#39;LOCAL&#39;,
      welcomeMessage: &#39;Crystalline formations sparkle in your torchlight.&#39;,
    },
  })

  const centralExchange = await prisma.location.create({
    data: {
      name: &#39;Central Exchange&#39;,
      description: &#39;The main financial district and trading hub&#39;,
      locationType: &#39;BUILDING&#39;,
      parentLocationId: cyberCity.id,
      difficulty: 2,
      playerCount: 8,
      lastActive: new Date(Date.now() - 2 * 60 * 1000),
      hasMarket: true,
      hasMining: false,
      hasChat: true,
      chatScope: &#39;LOCAL&#39;,
      welcomeMessage:
        &#39;Holographic displays show market prices from across the world.&#39;,
    },
  })

  const glitchClub = await prisma.location.create({
    data: {
      name: &#39;The Glitch Club&#39;,
      description: &#39;Underground social hub for hackers and rebels&#39;,
      locationType: &#39;BUILDING&#39;,
      parentLocationId: cyberCity.id,
      difficulty: 2,
      playerCount: 4,
      lastActive: new Date(Date.now() - 15 * 60 * 1000),
      hasMarket: false,
      hasMining: false,
      hasChat: true,
      chatScope: &#39;LOCAL&#39;,
      welcomeMessage: &#39;Bass-heavy music thumps through the smoky atmosphere.&#39;,
    },
  })

  console.log(&#39;🏘️ Created locations&#39;)

  // 🆕 CREATE DIVERSE CHARACTERS (Our Test Players)
  const characters = await Promise.all([
    // Our main test character
    prisma.character.create({
      data: {
        nftAddress: &#39;DemoNFT123456789&#39;,
        tokenId: &#39;1337&#39;,
        walletAddress: &#39;DemoWallet123456789&#39;,
        name: &#39;Wojak #1337&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: miningPlains.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak.png&#39;,
        energy: 85,
        health: 100,
      },
    }),

    // Mining Plains characters
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT420420420&#39;,
        tokenId: &#39;420&#39;,
        walletAddress: &#39;Wallet420&#39;,
        name: &#39;Wojak #420&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: miningPlains.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-420.png&#39;,
        energy: 95,
        health: 100,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT69696969&#39;,
        tokenId: &#39;69&#39;,
        walletAddress: &#39;Wallet69&#39;,
        name: &#39;Wojak #69&#39;,
        gender: &#39;FEMALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: rustyPickaxeInn.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-69.png&#39;,
        energy: 70,
        health: 100,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT888888&#39;,
        tokenId: &#39;888&#39;,
        walletAddress: &#39;Wallet888&#39;,
        name: &#39;Wojak #888&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: crystalCaves.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-888.png&#39;,
        energy: 45,
        health: 90,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT2077777&#39;,
        tokenId: &#39;2077&#39;,
        walletAddress: &#39;Wallet2077&#39;,
        name: &#39;Wojak #2077&#39;,
        gender: &#39;FEMALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: crystalCaves.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-2077.png&#39;,
        energy: 60,
        health: 85,
      },
    }),

    // Cyber City characters
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT1001001&#39;,
        tokenId: &#39;100&#39;,
        walletAddress: &#39;Wallet100&#39;,
        name: &#39;Wojak #100&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: centralExchange.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-100.png&#39;,
        energy: 80,
        health: 100,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT7777777&#39;,
        tokenId: &#39;777&#39;,
        walletAddress: &#39;Wallet777&#39;,
        name: &#39;Wojak #777&#39;,
        gender: &#39;FEMALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: centralExchange.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-777.png&#39;,
        energy: 90,
        health: 95,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT3333333&#39;,
        tokenId: &#39;333&#39;,
        walletAddress: &#39;Wallet333&#39;,
        name: &#39;Wojak #333&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: glitchClub.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-333.png&#39;,
        energy: 55,
        health: 80,
      },
    }),

    // Desert characters
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT5555555&#39;,
        tokenId: &#39;555&#39;,
        walletAddress: &#39;Wallet555&#39;,
        name: &#39;Wojak #555&#39;,
        gender: &#39;FEMALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: desertOutpost.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-555.png&#39;,
        energy: 40,
        health: 75,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT9999999&#39;,
        tokenId: &#39;999&#39;,
        walletAddress: &#39;Wallet999&#39;,
        name: &#39;Wojak #999&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;CREATURE&#39;,
        currentLocationId: desertOutpost.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-999.png&#39;,
        energy: 85,
        health: 100,
      },
    }),
  ])

  console.log(`👥 Created ${characters.length} characters`)

  // 🆕 CREATE REALISTIC CHAT MESSAGES
  const chatMessages = await Promise.all([
    // Mining Plains chat (regional - shows in main area and sub-locations)
    prisma.chatMessage.create({
      data: {
        locationId: miningPlains.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #420&#39;)!.id,
        message: &#39;Anyone know where the best iron deposits are?&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 3 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: miningPlains.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #1337&#39;)!.id,
        message:
          &#39;Try the eastern slopes, found some good scraps there yesterday&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 2 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: miningPlains.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #420&#39;)!.id,
        message: &#39;Thanks! Heading there now&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 90 * 1000),
      },
    }),

    // Rusty Pickaxe Inn chat (local - cozy tavern conversation)
    prisma.chatMessage.create({
      data: {
        locationId: rustyPickaxeInn.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #69&#39;)!.id,
        message: &#39;This ale tastes like it was brewed in a boot 😂&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 8 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: rustyPickaxeInn.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #420&#39;)!.id,
        message: &#39;Hey, at least it gets you drunk!&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 7 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: rustyPickaxeInn.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #69&#39;)!.id,
        message: &#39;True! Anyone up for some mining stories?&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 6 * 60 * 1000),
      },
    }),

    // Crystal Caves chat (focused on mining)
    prisma.chatMessage.create({
      data: {
        locationId: crystalCaves.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #888&#39;)!.id,
        message: &#39;Whoa! Just found a crystal shard in the deep tunnel!&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 5 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: crystalCaves.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #2077&#39;)!.id,
        message: &#39;Nice! What rarity?&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 4 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: crystalCaves.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #888&#39;)!.id,
        message: &quot;Epic! First one I&#39;ve ever seen&quot;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 3 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: crystalCaves.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #2077&#39;)!.id,
        message: &quot;Damn, I&#39;ve been mining here for weeks with no luck&quot;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 2 * 60 * 1000),
      },
    }),

    // Central Exchange chat (trading focused)
    prisma.chatMessage.create({
      data: {
        locationId: centralExchange.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #100&#39;)!.id,
        message: &#39;WTS: Cyber Jacket, rare quality. Looking for ancient coins&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 15 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: centralExchange.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #777&#39;)!.id,
        message: &#39;How many coins?&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 14 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: centralExchange.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #100&#39;)!.id,
        message: &#39;15 coins, firm price&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 13 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: centralExchange.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #777&#39;)!.id,
        message: &#39;Deal! Meet me at the trade terminal&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 12 * 60 * 1000),
      },
    }),

    // Glitch Club chat (underground vibe)
    prisma.chatMessage.create({
      data: {
        locationId: glitchClub.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #333&#39;)!.id,
        message: &#39;*nods to the beat* This track is fire 🔥&#39;,
        messageType: &#39;EMOTE&#39;,
        createdAt: new Date(Date.now() - 20 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: glitchClub.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #777&#39;)!.id,
        message: &#39;Anyone know who the DJ is tonight?&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 18 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: glitchClub.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #333&#39;)!.id,
        message: &#39;DJ CyberWojak, they drop the sickest beats in the city&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 16 * 60 * 1000),
      },
    }),

    // Desert Outpost chat (survival focused)
    prisma.chatMessage.create({
      data: {
        locationId: desertOutpost.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #555&#39;)!.id,
        message: &#39;Water supplies running low... need to find the oasis&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 25 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: desertOutpost.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #999&#39;)!.id,
        message: &#39;Follow the ancient stone markers, they lead to water&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 23 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: desertOutpost.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #555&#39;)!.id,
        message: &#39;Thanks creature-wojak, you know this desert well&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 22 * 60 * 1000),
      },
    }),

    // System messages
    prisma.chatMessage.create({
      data: {
        locationId: miningPlains.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #420&#39;)!.id,
        message: &#39;Wojak #420 found: Iron Scraps (COMMON)&#39;,
        messageType: &#39;SYSTEM&#39;,
        isSystem: true,
        createdAt: new Date(Date.now() - 10 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: crystalCaves.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #888&#39;)!.id,
        message: &#39;Wojak #888 found: Crystal Shard (EPIC)&#39;,
        messageType: &#39;SYSTEM&#39;,
        isSystem: true,
        createdAt: new Date(Date.now() - 4 * 60 * 1000),
      },
    }),
  ])

  console.log(`💬 Created ${chatMessages.length} chat messages`)

  // Create some sample inventory items
  await Promise.all([
    prisma.characterInventory.create({
      data: {
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #1337&#39;)!.id,
        itemId: items.find((i) =&gt; i.name === &#39;Dirty Coal&#39;)!.id,
        quantity: 3,
      },
    }),
    prisma.characterInventory.create({
      data: {
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #1337&#39;)!.id,
        itemId: items.find((i) =&gt; i.name === &#39;Miners Hat&#39;)!.id,
        quantity: 1,
        isEquipped: true,
      },
    }),
    prisma.characterInventory.create({
      data: {
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #888&#39;)!.id,
        itemId: items.find((i) =&gt; i.name === &#39;Crystal Shard&#39;)!.id,
        quantity: 1,
      },
    }),
  ])

  // Create some location resources
  await Promise.all([
    prisma.locationResource.create({
      data: {
        locationId: miningPlains.id,
        itemId: items.find((i) =&gt; i.name === &#39;Dirty Coal&#39;)!.id,
        spawnRate: 0.6,
        maxPerDay: 20,
        difficulty: 1,
      },
    }),
    prisma.locationResource.create({
      data: {
        locationId: crystalCaves.id,
        itemId: items.find((i) =&gt; i.name === &#39;Crystal Shard&#39;)!.id,
        spawnRate: 0.1,
        maxPerDay: 3,
        difficulty: 3,
      },
    }),
  ])

  console.log(&#39;🎉 Expanded database seed completed successfully!&#39;)
}

main()
  .catch((e) =&gt; {
    console.error(&#39;❌ Enhanced seed failed:&#39;, e)
    process.exit(1)
  })
  .finally(async () =&gt; {
    await prisma.$disconnect()
  })
</content>
    </document>

    <document>
      <source>prisma/schema.prisma</source>
      <tags></tags>
      <metadata>
        <size>7380</size>
        <lastModified>2025-05-28T22:31:59.236Z</lastModified>
        <extension>prisma</extension>
        <directory>prisma</directory>
      </metadata>
      <content>// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = &quot;prisma-client-js&quot;
}

datasource db {
  provider = &quot;postgresql&quot;
  url      = env(&quot;DATABASE_URL&quot;)
}

model Character {
  id            String @id @default(cuid())
  nftAddress    String @unique // Solana NFT address
  tokenId       String @unique // Token ID or mint address
  walletAddress String // Owner&#39;s wallet

  // Character basics
  name          String
  gender        Gender
  characterType CharacterType @default(HUMAN)

  // Current state
  currentLocationId String
  currentLocation   Location @relation(fields: [currentLocationId], references: [id])

  // NFT versioning
  currentVersion  Int     @default(1)
  currentImageUrl String?

  // Game stats
  energy Int @default(100)
  health Int @default(100)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  inventory      CharacterInventory[]
  imageHistory   CharacterImage[]
  transactions   Transaction[]
  marketListings MarketListing[]
  chatMessages   ChatMessage[]

  @@map(&quot;characters&quot;)
}

model Item {
  id          String       @id @default(cuid())
  name        String       @unique
  description String
  category    ItemCategory

  // Visual properties
  layerType LayerType? // which layer this item affects
  imageUrl  String? // item&#39;s image for layering

  // Game properties
  rarity     Rarity @default(COMMON)
  durability Int? // for equipment that degrades

  // Stats effects (optional for MVP)
  energyEffect Int?
  healthEffect Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  characterInventory CharacterInventory[]
  locationResources  LocationResource[]
  marketListings     MarketListing[]

  @@map(&quot;items&quot;)
}

model ChatMessage {
  id          String @id @default(cuid())
  locationId  String
  characterId String

  message     String
  messageType ChatMessageType @default(CHAT)

  // For system messages (player joined, found item, etc.)
  isSystem Boolean @default(false)

  location  Location  @relation(fields: [locationId], references: [id], onDelete: Cascade)
  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@map(&quot;chat_messages&quot;)
}

model Location {
  id          String  @id @default(cuid())
  name        String
  description String
  imageUrl    String?

  // Hierarchy support
  parentLocationId String?
  parentLocation   Location?  @relation(&quot;LocationHierarchy&quot;, fields: [parentLocationId], references: [id])
  subLocations     Location[] @relation(&quot;LocationHierarchy&quot;)

  // Location type
  locationType LocationType @default(REGION) // REGION, CITY, BUILDING, ROOM

  // Location properties
  biome      String? // only for top-level locations
  difficulty Int     @default(1)

  // Map positioning
  mapX Int? // X coordinate on map
  mapY Int? // Y coordinate on map

  // Location stats
  playerCount Int       @default(0) // cached count for performance
  lastActive  DateTime? // when someone last performed an action here

  // Location features
  hasMarket Boolean @default(true)
  hasMining Boolean @default(true)
  hasTravel Boolean @default(true)
  hasChat   Boolean @default(true) // enable chat in this location

  // Chat settings
  chatScope ChatScope @default(LOCAL) // LOCAL (this location only) or REGIONAL (includes parent)

  // Flavor text
  welcomeMessage String? // custom message when entering
  lore           String? // extended description/backstory

  // Entry requirements (optional)
  minLevel  Int? // minimum level to enter
  entryCost Int? // cost in coins to enter
  isPrivate Boolean @default(false) // requires invitation/ownership

  // Available resources for mining
  resources LocationResource[]

  // Characters currently here
  characters Character[]

  // Market items available here
  marketListings MarketListing[]

  // Chat messages in this location
  chatMessages ChatMessage[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, parentLocationId]) // location names must be unique within parent
  @@map(&quot;locations&quot;)
}

model CharacterInventory {
  id          String  @id @default(cuid())
  characterId String
  itemId      String
  quantity    Int     @default(1)
  isEquipped  Boolean @default(false)

  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  item      Item      @relation(fields: [itemId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([characterId, itemId])
  @@map(&quot;character_inventory&quot;)
}

model LocationResource {
  id         String @id @default(cuid())
  locationId String
  itemId     String

  // Mining properties
  spawnRate  Float @default(0.1) // chance per mining attempt
  maxPerDay  Int? // daily limit per character
  difficulty Int   @default(1)

  location Location @relation(fields: [locationId], references: [id], onDelete: Cascade)
  item     Item     @relation(fields: [itemId], references: [id])

  @@unique([locationId, itemId])
  @@map(&quot;location_resources&quot;)
}

model CharacterImage {
  id          String  @id @default(cuid())
  characterId String
  version     Int
  imageUrl    String
  description String? // what changed in this version

  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([characterId, version])
  @@map(&quot;character_images&quot;)
}

model MarketListing {
  id         String  @id @default(cuid())
  sellerId   String? // null for system items
  locationId String
  itemId     String

  price        Int // in game currency or SOL lamports
  quantity     Int     @default(1)
  isSystemItem Boolean @default(false) // true for NPC shop items

  seller   Character? @relation(fields: [sellerId], references: [id])
  location Location   @relation(fields: [locationId], references: [id])
  item     Item       @relation(fields: [itemId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map(&quot;market_listings&quot;)
}

model Transaction {
  id          String          @id @default(cuid())
  characterId String
  type        TransactionType
  itemId      String?
  quantity    Int?
  description String

  character Character @relation(fields: [characterId], references: [id])

  createdAt DateTime @default(now())

  @@map(&quot;transactions&quot;)
}

// Enums
enum Gender {
  MALE
  FEMALE
}

enum CharacterType {
  HUMAN
  CREATURE
}

enum LocationType {
  REGION // Continents, large areas
  CITY // Towns, cities
  BUILDING // Inns, shops, temples
  ROOM // Specific rooms within buildings
}

enum ChatScope {
  LOCAL // Only this specific location
  REGIONAL // This location + parent location
  GLOBAL // Entire game (for special locations)
}

enum ChatMessageType {
  CHAT // Regular player chat
  EMOTE // Player actions (/me waves)
  SYSTEM // System announcements
  WHISPER // Private messages
}

enum ItemCategory {
  CLOTHING
  HAT
  ACCESSORY
  TOOL
  CONSUMABLE
  MATERIAL
}

enum LayerType {
  BACKGROUND
  BASE
  CLOTHING
  HAT
  FACE_COVERING
  ACCESSORY
}

enum Rarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
}

enum TransactionType {
  MINT
  MINE
  BUY
  SELL
  TRAVEL
  EQUIP
  UNEQUIP
}
</content>
    </document>

    <document>
      <source>netlify/functions/metadata.js</source>
      <tags></tags>
      <metadata>
        <size>6861</size>
        <lastModified>2025-05-29T02:46:06.495Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>// netlify/functions/metadata.js
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// Configuration
const ASSET_BASE_URL = process.env.NODE_ENV === &#39;production&#39;
  ? &#39;https://earth.ndao.computer&#39;
  : process.env.URL || &#39;http://localhost:8888&#39;

/**
 * Generate trait attributes from character data
 */
function generateAttributes(character) {
  const attributes = []

  // Basic character traits
  attributes.push({
    trait_type: &quot;Gender&quot;,
    value: character.gender
  })

  attributes.push({
    trait_type: &quot;Character Type&quot;,
    value: character.characterType
  })

  // Location-based traits
  if (character.currentLocation) {
    attributes.push({
      trait_type: &quot;Current Location&quot;,
      value: character.currentLocation.name
    })

    if (character.currentLocation.biome) {
      attributes.push({
        trait_type: &quot;Biome&quot;,
        value: character.currentLocation.biome.charAt(0).toUpperCase() +
          character.currentLocation.biome.slice(1)
      })
    }
  }

  // Equipment traits
  if (character.inventory) {
    const equippedItems = character.inventory.filter(inv =&gt; inv.isEquipped)

    equippedItems.forEach(inv =&gt; {
      const item = inv.item
      attributes.push({
        trait_type: item.category.charAt(0).toUpperCase() +
          item.category.slice(1).toLowerCase(),
        value: item.name
      })
    })

    // Equipment count
    attributes.push({
      trait_type: &quot;Equipped Items&quot;,
      value: equippedItems.length,
      display_type: &quot;number&quot;
    })
  }

  // Stats
  attributes.push({
    trait_type: &quot;Energy&quot;,
    value: character.energy,
    max_value: 100,
    display_type: &quot;boost_percentage&quot;
  })

  attributes.push({
    trait_type: &quot;Health&quot;,
    value: character.health,
    max_value: 100,
    display_type: &quot;boost_percentage&quot;
  })

  // Game progression (could be calculated)
  const daysSinceCreation = Math.floor(
    (Date.now() - new Date(character.createdAt).getTime()) / (1000 * 60 * 60 * 24)
  )

  attributes.push({
    trait_type: &quot;Days Active&quot;,
    value: daysSinceCreation,
    display_type: &quot;number&quot;
  })

  return attributes
}

/**
 * Generate visible layers data
 */
function generateLayerData(character) {
  const layers = []

  // Background
  const backgroundName = character.currentLocation?.biome || &#39;mining-plains&#39;
  layers.push(`${ASSET_BASE_URL}/layers/backgrounds/${backgroundName}.png`)

  // Base
  const baseName = character.gender?.toLowerCase() || &#39;male&#39;
  layers.push(`${ASSET_BASE_URL}/layers/bases/${baseName}.png`)

  // Equipment layers
  if (character.inventory) {
    character.inventory
      .filter(inv =&gt; inv.isEquipped)
      .forEach(inv =&gt; {
        const item = inv.item
        let layerPath

        // Map items to layer paths
        switch (item.name) {
          case &#39;Miners Hat&#39;:
            layerPath = &#39;accessories/miners-hat.png&#39;
            break
          case &#39;Cyber Jacket&#39;:
            layerPath = &#39;clothing/cyber-jacket.png&#39;
            break
          case &#39;Work Gloves&#39;:
            layerPath = &#39;accessories/work-gloves.png&#39;
            break
          case &#39;Lucky Charm&#39;:
            layerPath = &#39;accessories/lucky-charm.png&#39;
            break
          // Add more mappings as needed
        }

        if (layerPath) {
          layers.push(`${ASSET_BASE_URL}/layers/${layerPath}`)
        }
      })
  }

  return layers
}

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;,
    &#39;Content-Type&#39;: &#39;application/json&#39;,
    &#39;Cache-Control&#39;: &#39;public, max-age=1800&#39; // Cache for 30 minutes
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    // Extract token ID from path
    const pathParts = event.path.split(&#39;/&#39;)
    const tokenId = pathParts[pathParts.length - 1]

    if (!tokenId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Token ID required&#39; })
      }
    }

    // Get character data
    let character

    if (tokenId === &#39;demo&#39; || tokenId === &#39;1337&#39;) {
      // Demo character
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; },
        include: {
          currentLocation: true,
          inventory: {
            where: { isEquipped: true },
            include: { item: true }
          }
        }
      })
    } else {
      // Try to find by tokenId first, then by ID
      character = await prisma.character.findFirst({
        where: {
          OR: [
            { tokenId: tokenId },
            { id: tokenId }
          ]
        },
        include: {
          currentLocation: true,
          inventory: {
            where: { isEquipped: true },
            include: { item: true }
          }
        }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Generate metadata
    const metadata = {
      name: character.name,
      description: `${character.name} is a ${character.characterType.toLowerCase()} explorer currently in ${character.currentLocation?.name || &#39;Unknown Location&#39;}. Energy: ${character.energy}/100, Health: ${character.health}/100.`,
      image: `${ASSET_BASE_URL}/.netlify/functions/render-character/${character.tokenId || character.id}.png`,
      external_url: `${ASSET_BASE_URL}/character/${character.tokenId || character.id}`,

      // Standard NFT metadata
      attributes: generateAttributes(character),

      // Wojak Earth specific data
      wojak_earth: {
        character_id: character.id,
        token_id: character.tokenId,
        nft_address: character.nftAddress,
        current_location: {
          id: character.currentLocation?.id,
          name: character.currentLocation?.name,
          type: character.currentLocation?.locationType,
          biome: character.currentLocation?.biome
        },
        stats: {
          energy: character.energy,
          health: character.health,
          level: Math.floor((Date.now() - new Date(character.createdAt).getTime()) / (1000 * 60 * 60 * 24 * 7)) + 1 // Rough level calculation
        },
        assets: {
          layers: generateLayerData(character),
          last_updated: new Date().toISOString()
        }
      }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(metadata, null, 2)
    }

  } catch (error) {
    console.error(&#39;Error generating metadata:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Metadata generation failed&#39;,
        message: error.message
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/buy-item.js</source>
      <tags></tags>
      <metadata>
        <size>6043</size>
        <lastModified>2025-05-29T03:25:43.591Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const { characterId = &#39;hardcoded-demo&#39;, marketListingId, quantity = 1 } = JSON.parse(event.body || &#39;{}&#39;)

    if (!marketListingId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Market listing ID is required&#39; })
      }
    }

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Get market listing with item details
    const marketListing = await prisma.marketListing.findUnique({
      where: { id: marketListingId },
      include: {
        item: true,
        seller: true,
        location: true
      }
    })

    if (!marketListing) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Market listing not found&#39; })
      }
    }

    // Check if enough quantity available
    if (quantity &gt; marketListing.quantity) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Insufficient quantity&#39;,
          message: `Only ${marketListing.quantity} available, you requested ${quantity}`
        })
      }
    }

    // Calculate total cost
    const totalCost = marketListing.price * quantity

    // For MVP: Skip currency check (assume player has enough)
    // TODO: Implement currency system
    // if (character.coins &lt; totalCost) {
    //   return {
    //     statusCode: 400,
    //     headers,
    //     body: JSON.stringify({
    //       error: &#39;Insufficient funds&#39;,
    //       message: `Item costs ${totalCost} coins, you have ${character.coins}`
    //     })
    //   }
    // }

    // Perform transaction
    const result = await prisma.$transaction(async (tx) =&gt; {
      // Add item to character inventory
      const existingInventory = await tx.characterInventory.findUnique({
        where: {
          characterId_itemId: {
            characterId: character.id,
            itemId: marketListing.itemId
          }
        }
      })

      let inventoryItem
      if (existingInventory) {
        // Update existing inventory
        inventoryItem = await tx.characterInventory.update({
          where: { id: existingInventory.id },
          data: { quantity: existingInventory.quantity + quantity },
          include: { item: true }
        })
      } else {
        // Create new inventory entry
        inventoryItem = await tx.characterInventory.create({
          data: {
            characterId: character.id,
            itemId: marketListing.itemId,
            quantity: quantity
          },
          include: { item: true }
        })
      }

      // Update or remove market listing
      if (marketListing.quantity === quantity &amp;&amp; !marketListing.isSystemItem) {
        // Only remove player listings when sold out
        await tx.marketListing.delete({
          where: { id: marketListingId }
        })
      } else {
        // Reduce quantity (system items can go to 0 but stay in DB)
        await tx.marketListing.update({
          where: { id: marketListingId },
          data: { quantity: marketListing.quantity - quantity }
        })
      }

      // TODO: Handle currency transfer
      // if (!marketListing.isSystemItem &amp;&amp; marketListing.seller) {
      //   // Transfer coins to seller
      //   await tx.character.update({
      //     where: { id: marketListing.sellerId },
      //     data: { coins: { increment: totalCost } }
      //   })
      // }
      // 
      // // Deduct coins from buyer
      // await tx.character.update({
      //   where: { id: character.id },
      //   data: { coins: { decrement: totalCost } }
      // })

      // Log the transaction
      const transaction = await tx.transaction.create({
        data: {
          characterId: character.id,
          type: &#39;BUY&#39;,
          itemId: marketListing.itemId,
          quantity: quantity,
          description: `Bought ${quantity}x ${marketListing.item.name} for ${totalCost} coins from ${marketListing.location.name} market`
        }
      })

      return {
        inventoryItem,
        transaction,
        totalCost,
        remainingQuantity: marketListing.quantity - quantity
      }
    })

    // Prepare response
    const responseData = {
      success: true,
      message: `Successfully purchased ${quantity}x ${marketListing.item.name}!`,
      purchase: {
        itemName: marketListing.item.name,
        itemRarity: marketListing.item.rarity,
        quantity: quantity,
        totalCost: totalCost,
        newInventoryQuantity: result.inventoryItem.quantity
      },
      marketListing: {
        id: marketListingId,
        remainingQuantity: result.remainingQuantity,
        wasRemoved: result.remainingQuantity === 0
      }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error purchasing item:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Purchase failed&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/use-item.js</source>
      <tags></tags>
      <metadata>
        <size>5806</size>
        <lastModified>2025-05-29T04:02:05.691Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>// netlify/functions/use-item.js
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const { characterId = &#39;hardcoded-demo&#39;, inventoryId } = JSON.parse(event.body || &#39;{}&#39;)

    if (!inventoryId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Inventory ID is required&#39; })
      }
    }

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Get inventory item with details
    const inventoryItem = await prisma.characterInventory.findUnique({
      where: { id: inventoryId },
      include: { item: true }
    })

    if (!inventoryItem) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Inventory item not found&#39; })
      }
    }

    // Verify ownership
    if (inventoryItem.characterId !== character.id) {
      return {
        statusCode: 403,
        headers,
        body: JSON.stringify({ error: &#39;Item does not belong to this character&#39; })
      }
    }

    // Check if item is consumable
    if (inventoryItem.item.category !== &#39;CONSUMABLE&#39;) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Item not consumable&#39;,
          message: `${inventoryItem.item.name} cannot be consumed`
        })
      }
    }

    // Check if there&#39;s quantity to consume
    if (inventoryItem.quantity &lt;= 0) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;No items to use&#39;,
          message: `You don&#39;t have any ${inventoryItem.item.name} to use`
        })
      }
    }

    // Calculate effects (capped at 100)
    const energyEffect = inventoryItem.item.energyEffect || 0
    const healthEffect = inventoryItem.item.healthEffect || 0

    const newEnergy = Math.min(100, character.energy + energyEffect)
    const newHealth = Math.min(100, character.health + healthEffect)

    const actualEnergyGain = newEnergy - character.energy
    const actualHealthGain = newHealth - character.health

    // Check if effects would be wasted
    if (actualEnergyGain === 0 &amp;&amp; actualHealthGain === 0) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;No effect&#39;,
          message: `Using ${inventoryItem.item.name} would have no effect - you&#39;re already at full health and energy`
        })
      }
    }

    // Perform consumption within transaction
    const result = await prisma.$transaction(async (tx) =&gt; {
      // Update character stats
      const updatedCharacter = await tx.character.update({
        where: { id: character.id },
        data: {
          energy: newEnergy,
          health: newHealth
        }
      })

      // Reduce inventory quantity or remove item
      let updatedInventory
      if (inventoryItem.quantity === 1) {
        // Remove item completely
        await tx.characterInventory.delete({
          where: { id: inventoryId }
        })
        updatedInventory = null
      } else {
        // Reduce quantity
        updatedInventory = await tx.characterInventory.update({
          where: { id: inventoryId },
          data: { quantity: inventoryItem.quantity - 1 },
          include: { item: true }
        })
      }

      // Log the transaction
      const transaction = await tx.transaction.create({
        data: {
          characterId: character.id,
          type: &#39;MINE&#39;, // We can add &#39;USE&#39; to the enum later, using MINE for now
          itemId: inventoryItem.itemId,
          quantity: 1,
          description: `Used ${inventoryItem.item.name}${actualEnergyGain &gt; 0 || actualHealthGain &gt; 0 ?
            ` (${[
              actualEnergyGain &gt; 0 ? `+${actualEnergyGain} energy` : null,
              actualHealthGain &gt; 0 ? `+${actualHealthGain} health` : null
            ].filter(Boolean).join(&#39;, &#39;)})` : &#39;&#39;
            }`
        }
      })

      return {
        character: updatedCharacter,
        inventory: updatedInventory,
        transaction,
        effects: {
          energy: actualEnergyGain,
          health: actualHealthGain
        }
      }
    })

    // Prepare response
    const responseData = {
      success: true,
      message: `Used ${inventoryItem.item.name}!`,
      effects: result.effects,
      newStats: {
        energy: result.character.energy,
        health: result.character.health
      },
      inventory: {
        remainingQuantity: result.inventory?.quantity || 0,
        wasRemoved: !result.inventory
      }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error using item:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to use item&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/get-locations.js</source>
      <tags></tags>
      <metadata>
        <size>3256</size>
        <lastModified>2025-05-29T00:12:36.034Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    // Fetch all top-level locations (no parent) with their sub-locations
    const locations = await prisma.location.findMany({
      where: {
        parentLocationId: null // Only top-level locations
      },
      include: {
        subLocations: {
          include: {
            _count: {
              select: {
                characters: true // Count characters in each sub-location
              }
            }
          },
          orderBy: {
            name: &#39;asc&#39;
          }
        },
        _count: {
          select: {
            characters: true // Count characters directly in parent location
          }
        }
      },
      orderBy: {
        difficulty: &#39;asc&#39; // Easier locations first
      }
    })

    // Transform data for frontend with aggregated player counts
    const responseData = locations.map(location =&gt; {
      // Calculate total players: direct + all sub-locations
      const directPlayerCount = location._count.characters
      const subLocationPlayerCount = location.subLocations.reduce((total, subLoc) =&gt; {
        return total + subLoc._count.characters
      }, 0)
      const totalPlayerCount = directPlayerCount + subLocationPlayerCount

      return {
        id: location.id,
        name: location.name,
        description: location.description,
        locationType: location.locationType,
        biome: location.biome,
        difficulty: location.difficulty,
        playerCount: totalPlayerCount, // Aggregated count
        directPlayerCount: directPlayerCount, // Players directly at this location
        lastActive: location.lastActive,
        hasMarket: location.hasMarket,
        hasMining: location.hasMining,
        hasChat: location.hasChat,
        welcomeMessage: location.welcomeMessage,
        lore: location.lore,

        subLocations: location.subLocations.map(subLoc =&gt; ({
          id: subLoc.id,
          name: subLoc.name,
          description: subLoc.description,
          locationType: subLoc.locationType,
          difficulty: subLoc.difficulty,
          playerCount: subLoc._count.characters, // Real player count for sub-location
          hasMarket: subLoc.hasMarket,
          hasMining: subLoc.hasMining,
          hasChat: subLoc.hasChat,
          welcomeMessage: subLoc.welcomeMessage,
          parentLocationId: subLoc.parentLocationId
        }))
      }
    })

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        locations: responseData,
        timestamp: new Date().toISOString()
      })
    }

  } catch (error) {
    console.error(&#39;Error fetching locations:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to fetch locations&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/get-character.js</source>
      <tags></tags>
      <metadata>
        <size>4642</size>
        <lastModified>2025-05-28T23:17:38.002Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    // For MVP, we&#39;ll use hardcoded character ID
    const characterId = event.queryStringParameters?.characterId || &#39;hardcoded-demo&#39;

    let character

    if (characterId === &#39;hardcoded-demo&#39;) {
      // Return our seeded test character
      character = await prisma.character.findFirst({
        where: {
          name: &quot;Wojak #1337&quot;
        },
        include: {
          currentLocation: true,
          inventory: {
            include: {
              item: true
            }
          },
          imageHistory: {
            orderBy: {
              version: &#39;desc&#39;
            },
            take: 5
          },
          transactions: {
            orderBy: {
              createdAt: &#39;desc&#39;
            },
            take: 10
            // Remove the item include since Transaction doesn&#39;t have a direct relation
          }
        }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId },
        include: {
          currentLocation: true,
          inventory: {
            include: {
              item: true
            }
          },
          imageHistory: {
            orderBy: {
              version: &#39;desc&#39;
            },
            take: 5
          },
          transactions: {
            orderBy: {
              createdAt: &#39;desc&#39;
            },
            take: 10
          }
        }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({
          error: &#39;Character not found&#39;,
          message: &#39;No character exists with the provided ID&#39;
        })
      }
    }

    // For transactions with itemId, we&#39;ll fetch the item separately if needed
    const transactionsWithItems = []
    for (const tx of character.transactions) {
      if (tx.itemId) {
        const item = await prisma.item.findUnique({
          where: { id: tx.itemId }
        })
        transactionsWithItems.push({
          ...tx,
          item: item ? { name: item.name, rarity: item.rarity } : null
        })
      } else {
        transactionsWithItems.push({ ...tx, item: null })
      }
    }

    // Transform the data for frontend consumption
    const responseData = {
      id: character.id,
      name: character.name,
      gender: character.gender,
      characterType: character.characterType,
      energy: character.energy,
      health: character.health,
      currentImageUrl: character.currentImageUrl,
      currentVersion: character.currentVersion,
      nftAddress: character.nftAddress,
      tokenId: character.tokenId,

      currentLocation: {
        id: character.currentLocation.id,
        name: character.currentLocation.name,
        description: character.currentLocation.description,
        locationType: character.currentLocation.locationType,
        biome: character.currentLocation.biome,
        welcomeMessage: character.currentLocation.welcomeMessage
      },

      inventory: character.inventory.map(inv =&gt; ({
        id: inv.id,
        quantity: inv.quantity,
        isEquipped: inv.isEquipped,
        item: {
          id: inv.item.id,
          name: inv.item.name,
          description: inv.item.description,
          category: inv.item.category,
          rarity: inv.item.rarity,
          imageUrl: inv.item.imageUrl,
          layerType: inv.item.layerType
        }
      })),

      imageHistory: character.imageHistory.map(img =&gt; ({
        version: img.version,
        imageUrl: img.imageUrl,
        description: img.description,
        createdAt: img.createdAt
      })),

      recentActivity: transactionsWithItems.map(tx =&gt; ({
        id: tx.id,
        type: tx.type,
        description: tx.description,
        quantity: tx.quantity,
        createdAt: tx.createdAt,
        item: tx.item
      }))
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error fetching character:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to fetch character data&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/equip-item.js</source>
      <tags></tags>
      <metadata>
        <size>6557</size>
        <lastModified>2025-05-29T05:38:49.985Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>// netlify/functions/equip-item.js - Fixed version
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const { characterId = &#39;hardcoded-demo&#39;, inventoryId, equip = true } = JSON.parse(event.body || &#39;{}&#39;)

    if (!inventoryId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Inventory ID is required&#39; })
      }
    }

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Get inventory item with details
    const inventoryItem = await prisma.characterInventory.findUnique({
      where: { id: inventoryId },
      include: { item: true }
    })

    if (!inventoryItem) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Inventory item not found&#39; })
      }
    }

    // Verify ownership
    if (inventoryItem.characterId !== character.id) {
      return {
        statusCode: 403,
        headers,
        body: JSON.stringify({ error: &#39;Item does not belong to this character&#39; })
      }
    }

    // Check if item is equippable
    const equipableCategories = [&#39;HAT&#39;, &#39;CLOTHING&#39;, &#39;ACCESSORY&#39;, &#39;TOOL&#39;]
    if (!equipableCategories.includes(inventoryItem.item.category)) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Item not equippable&#39;,
          message: `${inventoryItem.item.category} items cannot be equipped`
        })
      }
    }

    // Perform equipment action within transaction
    const result = await prisma.$transaction(async (tx) =&gt; {
      let replacedItems = []

      if (equip) {
        // Find conflicting items in the same category to auto-unequip
        const conflictingItems = await tx.characterInventory.findMany({
          where: {
            characterId: character.id,
            isEquipped: true,
            item: {
              category: inventoryItem.item.category
            },
            id: { not: inventoryId } // Don&#39;t include the item we&#39;re trying to equip
          },
          include: { item: true }
        })

        // Unequip conflicting items
        if (conflictingItems.length &gt; 0) {
          await tx.characterInventory.updateMany({
            where: {
              characterId: character.id,
              isEquipped: true,
              item: {
                category: inventoryItem.item.category
              },
              id: { not: inventoryId }
            },
            data: { isEquipped: false }
          })

          // Log unequip transactions for replaced items
          for (const item of conflictingItems) {
            await tx.transaction.create({
              data: {
                characterId: character.id,
                type: &#39;UNEQUIP&#39;,
                itemId: item.itemId,
                description: `Auto-unequipped ${item.item.name} (replaced by ${inventoryItem.item.name})`
              }
            })
          }

          replacedItems = conflictingItems.map(item =&gt; item.item.name)
        }

        // Equip the new item
        const updatedItem = await tx.characterInventory.update({
          where: { id: inventoryId },
          data: { isEquipped: true },
          include: { item: true }
        })

        // Log the equip transaction
        await tx.transaction.create({
          data: {
            characterId: character.id,
            type: &#39;EQUIP&#39;,
            itemId: inventoryItem.itemId,
            description: `Equipped ${inventoryItem.item.name}`
          }
        })

        return {
          action: &#39;equipped&#39;,
          item: updatedItem,
          replacedItems: replacedItems
        }

      } else {
        // Unequip the item
        const updatedItem = await tx.characterInventory.update({
          where: { id: inventoryId },
          data: { isEquipped: false },
          include: { item: true }
        })

        // Log the transaction
        await tx.transaction.create({
          data: {
            characterId: character.id,
            type: &#39;UNEQUIP&#39;,
            itemId: inventoryItem.itemId,
            description: `Unequipped ${inventoryItem.item.name}`
          }
        })

        return { action: &#39;unequipped&#39;, item: updatedItem, replacedItems: [] }
      }
    })

    // Calculate stat effects (for future implementation)
    const statEffects = {
      energy: inventoryItem.item.energyEffect || 0,
      health: inventoryItem.item.healthEffect || 0
    }

    // Prepare response with replacement info
    let message = `${inventoryItem.item.name} ${result.action} successfully!`
    if (result.replacedItems.length &gt; 0) {
      message += ` (Replaced: ${result.replacedItems.join(&#39;, &#39;)})`
    }

    const responseData = {
      success: true,
      message: message,
      item: {
        id: result.item.id,
        name: result.item.item.name,
        category: result.item.item.category,
        rarity: result.item.item.rarity,
        isEquipped: result.item.isEquipped,
        layerType: result.item.item.layerType
      },
      action: result.action,
      replacedItems: result.replacedItems,
      statEffects: equip ? statEffects : { energy: -statEffects.energy, health: -statEffects.health }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error equipping/unequipping item:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Equipment action failed&#39;,
        details: error.message // Added for debugging
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/get-market.js</source>
      <tags></tags>
      <metadata>
        <size>6022</size>
        <lastModified>2025-05-29T03:47:50.500Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>// netlify/functions/get-market.js - Updated version
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    const locationId = event.queryStringParameters?.locationId
    const limit = parseInt(event.queryStringParameters?.limit || &#39;20&#39;)

    if (!locationId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Location ID is required&#39; })
      }
    }

    // Get location with parent info
    const location = await prisma.location.findUnique({
      where: { id: locationId },
      include: {
        parentLocation: true
      }
    })

    if (!location) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Location not found&#39; })
      }
    }

    if (!location.hasMarket) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;No market available&#39;,
          message: &#39;This location does not have a market&#39;
        })
      }
    }

    let allMarketListings = []

    // Get local market listings (items specifically at this location)
    const localListings = await prisma.marketListing.findMany({
      where: {
        locationId: locationId
      },
      include: {
        item: true,
        seller: {
          select: {
            id: true,
            name: true,
            characterType: true
          }
        }
      }
    })

    // If this is a child location, also get parent location&#39;s items (global market)
    let globalListings = []
    if (location.parentLocationId) {
      globalListings = await prisma.marketListing.findMany({
        where: {
          locationId: location.parentLocationId
        },
        include: {
          item: true,
          seller: {
            select: {
              id: true,
              name: true,
              characterType: true
            }
          }
        }
      })
    }

    // Combine and mark items appropriately
    const combinedListings = [
      ...localListings.map(listing =&gt; ({ ...listing, isLocalSpecialty: true })),
      ...globalListings.map(listing =&gt; ({ ...listing, isLocalSpecialty: false }))
    ]

    // If no listings exist at all, create some default items
    if (combinedListings.length === 0) {
      // Get some items to create system listings for
      const availableItems = await prisma.item.findMany({
        where: {
          category: {
            in: [&#39;HAT&#39;, &#39;CLOTHING&#39;, &#39;ACCESSORY&#39;, &#39;CONSUMABLE&#39;]
          }
        },
        take: 6
      })

      // Create system market listings
      const systemListings = await Promise.all(
        availableItems.map(item =&gt; {
          // Price based on rarity
          let price = 10
          switch (item.rarity) {
            case &#39;UNCOMMON&#39;: price = 25; break
            case &#39;RARE&#39;: price = 50; break
            case &#39;EPIC&#39;: price = 100; break
            case &#39;LEGENDARY&#39;: price = 250; break
          }

          return prisma.marketListing.create({
            data: {
              locationId: locationId,
              itemId: item.id,
              price: price,
              quantity: item.category === &#39;CONSUMABLE&#39; ? 5 : 1,
              isSystemItem: true
            },
            include: {
              item: true,
              seller: {
                select: {
                  id: true,
                  name: true,
                  characterType: true
                }
              }
            }
          })
        })
      )

      // Use the newly created listings
      allMarketListings = systemListings.map(listing =&gt; ({ ...listing, isLocalSpecialty: true }))
    } else {
      allMarketListings = combinedListings
    }

    // Transform listings for frontend
    const transformedListings = allMarketListings
      .sort((a, b) =&gt; {
        // Sort: local specialties first, then by creation date
        if (a.isLocalSpecialty &amp;&amp; !b.isLocalSpecialty) return -1
        if (!a.isLocalSpecialty &amp;&amp; b.isLocalSpecialty) return 1
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      })
      .slice(0, limit)
      .map(listing =&gt; ({
        id: listing.id,
        price: listing.price,
        quantity: listing.quantity,
        isSystemItem: listing.isSystemItem,
        isLocalSpecialty: listing.isLocalSpecialty,
        seller: listing.seller ? {
          id: listing.seller.id,
          name: listing.seller.name,
          characterType: listing.seller.characterType
        } : null,
        item: {
          id: listing.item.id,
          name: listing.item.name,
          description: listing.item.description,
          category: listing.item.category,
          rarity: listing.item.rarity,
          imageUrl: listing.item.imageUrl,
          layerType: listing.item.layerType,
          energyEffect: listing.item.energyEffect,
          healthEffect: listing.item.healthEffect
        },
        createdAt: listing.createdAt
      }))

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        items: transformedListings,
        totalCount: transformedListings.length,
        locationId: locationId,
        locationName: location.name,
        isChildLocation: !!location.parentLocationId,
        parentLocationName: location.parentLocation?.name,
        timestamp: new Date().toISOString()
      })
    }

  } catch (error) {
    console.error(&#39;Error fetching market items:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to fetch market items&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/get-players-at-location.js</source>
      <tags></tags>
      <metadata>
        <size>2971</size>
        <lastModified>2025-05-28T23:55:02.361Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;,
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return {
      statusCode: 200,
      headers,
      body: &#39;&#39;
    }
  }

  try {
    const locationId = event.queryStringParameters?.locationId

    if (!locationId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Location ID is required&#39; })
      }
    }

    const players = await prisma.character.findMany({
      where: {
        currentLocationId: locationId
      },
      select: {
        id: true,
        name: true,
        gender: true,
        characterType: true,
        energy: true,
        health: true,
        currentImageUrl: true,
        createdAt: true,
        inventory: {
          where: { isEquipped: true },
          include: { item: true }
        }
      },
      orderBy: {
        name: &#39;asc&#39;
      }
    })

    const playersWithStatus = players.map(player =&gt; {
      let status = &#39;Idle&#39;

      if (player.energy &lt; 20) {
        status = &#39;Resting&#39;
      } else if (player.energy &gt; 90) {
        status = &#39;Energetic&#39;
      } else if (player.inventory.some(inv =&gt; inv.item.category === &#39;HAT&#39;)) {
        status = &#39;Mining&#39;
      } else if (player.energy &lt; 50) {
        status = &#39;Tired&#39;
      } else {
        const activities = [&#39;Mining&#39;, &#39;Exploring&#39;, &#39;Trading&#39;, &#39;Chatting&#39;, &#39;Just Arrived&#39;]
        status = activities[Math.floor(Math.random() * activities.length)]
      }

      const daysSinceCreation = Math.floor((Date.now() - player.createdAt.getTime()) / (1000 * 60 * 60 * 24))
      const level = Math.max(1, Math.floor(daysSinceCreation / 7) + Math.floor(Math.random() * 20) + 1)

      return {
        id: player.id,
        name: player.name,
        gender: player.gender,
        characterType: player.characterType,
        level: level,
        energy: player.energy,
        health: player.health,
        status: status,
        currentImageUrl: player.currentImageUrl,
        equippedItems: player.inventory.map(inv =&gt; ({
          name: inv.item.name,
          category: inv.item.category,
          rarity: inv.item.rarity
        }))
      }
    })

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        players: playersWithStatus,
        totalCount: playersWithStatus.length,
        locationId: locationId,
        timestamp: new Date().toISOString()
      })
    }

  } catch (error) {
    console.error(&#39;Error fetching players:&#39;, error)
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to fetch players at location&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/mine-action.js</source>
      <tags></tags>
      <metadata>
        <size>6197</size>
        <lastModified>2025-05-29T07:11:55.499Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const { characterId = &#39;hardcoded-demo&#39;, locationId } = JSON.parse(event.body || &#39;{}&#39;)

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; },
        include: { currentLocation: true }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId },
        include: { currentLocation: true }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Use current location if none specified
    const targetLocationId = locationId || character.currentLocationId

    // Check if character has enough energy
    const ENERGY_COST = 10
    if (character.energy &lt; ENERGY_COST) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Not enough energy&#39;,
          message: `Mining requires ${ENERGY_COST} energy. You have ${character.energy}.`,
          currentEnergy: character.energy,
          required: ENERGY_COST
        })
      }
    }

    // Get location and its available resources
    const location = await prisma.location.findUnique({
      where: { id: targetLocationId },
      include: {
        resources: {
          include: {
            item: true
          }
        }
      }
    })

    if (!location || !location.hasMining) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Cannot mine here&#39;,
          message: &#39;This location does not support mining&#39;
        })
      }
    }

    if (location.resources.length === 0) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;No resources available&#39;,
          message: &#39;This location has no mineable resources&#39;
        })
      }
    }

    // Mining logic - check each resource by spawn rate
    const roll = Math.random()
    let foundResource = null

    // Sort by spawn rate (highest first) for better user experience
    const sortedResources = location.resources.sort((a, b) =&gt; b.spawnRate - a.spawnRate)

    for (const resource of sortedResources) {
      if (roll &lt; resource.spawnRate) {
        foundResource = resource
        break
      }
    }

    // Start transaction to update character and add item
    const result = await prisma.$transaction(async (tx) =&gt; {
      // Reduce character energy
      const updatedCharacter = await tx.character.update({
        where: { id: character.id },
        data: {
          energy: character.energy - ENERGY_COST
        }
      })

      let addedItem = null
      let transaction = null

      if (foundResource) {
        // Check if character already has this item in inventory
        const existingInventory = await tx.characterInventory.findUnique({
          where: {
            characterId_itemId: {
              characterId: character.id,
              itemId: foundResource.itemId
            }
          }
        })

        if (existingInventory) {
          // Update quantity
          addedItem = await tx.characterInventory.update({
            where: { id: existingInventory.id },
            data: { quantity: existingInventory.quantity + 1 },
            include: { item: true }
          })
        } else {
          // Create new inventory entry
          addedItem = await tx.characterInventory.create({
            data: {
              characterId: character.id,
              itemId: foundResource.itemId,
              quantity: 1
            },
            include: { item: true }
          })
        }

        // Log the transaction
        transaction = await tx.transaction.create({
          data: {
            characterId: character.id,
            type: &#39;MINE&#39;,
            itemId: foundResource.itemId,
            quantity: 1,
            description: `Found ${foundResource.item.name} while mining in ${location.name}`
          }
        })
      } else {
        // Log failed mining attempt
        transaction = await tx.transaction.create({
          data: {
            characterId: character.id,
            type: &#39;MINE&#39;,
            description: `Mining attempt in ${location.name} - nothing found`
          }
        })
      }

      return {
        character: updatedCharacter,
        foundItem: addedItem,
        transaction
      }
    })

    // Prepare response
    const responseData = {
      success: true,
      energyUsed: ENERGY_COST,
      newEnergyLevel: result.character.energy,
      location: {
        id: location.id,
        name: location.name
      }
    }

    if (result.foundItem) {
      responseData.foundItem = {
        name: result.foundItem.item.name,
        description: result.foundItem.item.description,
        rarity: result.foundItem.item.rarity,
        imageUrl: result.foundItem.item.imageUrl,
        newQuantity: result.foundItem.quantity
      }
      responseData.message = `You found: ${result.foundItem.item.name} (${result.foundItem.item.rarity})!`
    } else {
      responseData.message = &quot;You dig around but find nothing useful...&quot;
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error during mining:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Mining operation failed&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/travel-action.js</source>
      <tags></tags>
      <metadata>
        <size>5685</size>
        <lastModified>2025-05-28T23:30:33.914Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const { characterId = &#39;hardcoded-demo&#39;, destinationId } = JSON.parse(event.body || &#39;{}&#39;)

    if (!destinationId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Destination ID is required&#39; })
      }
    }

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; },
        include: { currentLocation: true }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId },
        include: { currentLocation: true }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Get destination location
    const destination = await prisma.location.findUnique({
      where: { id: destinationId },
      include: {
        subLocations: true,
        parentLocation: true
      }
    })

    if (!destination) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Destination not found&#39; })
      }
    }

    // Check if already at destination
    if (character.currentLocationId === destinationId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Already at destination&#39;,
          message: `You are already in ${destination.name}`
        })
      }
    }

    // TODO: Future travel requirements check
    // const requirements = getTravelRequirements(character.currentLocation, destination)
    // const canTravel = checkTravelRequirements(character, requirements)
    // if (!canTravel.allowed) {
    //   return { statusCode: 400, body: JSON.stringify({ error: canTravel.reason }) }
    // }

    // For MVP: Instant travel with no cost
    const result = await prisma.$transaction(async (tx) =&gt; {
      // Update character location
      const updatedCharacter = await tx.character.update({
        where: { id: character.id },
        data: {
          currentLocationId: destinationId
        },
        include: {
          currentLocation: true
        }
      })

      // Log the travel transaction
      const transaction = await tx.transaction.create({
        data: {
          characterId: character.id,
          type: &#39;TRAVEL&#39;,
          description: `Traveled from ${character.currentLocation.name} to ${destination.name}`
        }
      })

      // Update player counts (decrement old location, increment new location)
      await tx.location.update({
        where: { id: character.currentLocationId },
        data: {
          playerCount: { decrement: 1 }
        }
      })

      await tx.location.update({
        where: { id: destinationId },
        data: {
          playerCount: { increment: 1 },
          lastActive: new Date()
        }
      })

      return {
        character: updatedCharacter,
        transaction
      }
    })

    // Prepare response
    const responseData = {
      success: true,
      message: `Welcome to ${destination.name}!`,
      newLocation: {
        id: destination.id,
        name: destination.name,
        description: destination.description,
        locationType: destination.locationType,
        biome: destination.biome,
        welcomeMessage: destination.welcomeMessage,
        lore: destination.lore,
        hasMarket: destination.hasMarket,
        hasMining: destination.hasMining,
        hasChat: destination.hasChat
      },
      previousLocation: {
        id: character.currentLocation.id,
        name: character.currentLocation.name
      },
      // Future: costs incurred
      costs: {
        time: 0,      // minutes
        energy: 0,    // energy points
        money: 0,     // SOL
        status: []    // required items used
      }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error during travel:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Travel failed&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}

// Future: Travel requirements calculation
function getTravelRequirements(origin, destination) {
  // Calculate based on:
  // - Distance (map coordinates)
  // - Difficulty difference
  // - Location type (REGION vs BUILDING vs ROOM)
  // - Special requirements per location

  return {
    time: 0,        // Will calculate based on distance/difficulty
    energy: 0,      // Will calculate based on terrain/difficulty  
    money: 0,       // Will be location-specific
    status: []      // Will check location.minLevel, required items, etc.
  }
}

function checkTravelRequirements(character, requirements) {
  // Check if character meets all requirements
  // - Has enough energy
  // - Can afford SOL cost
  // - Has required status items in inventory
  // - Meets level requirements

  return {
    allowed: true,
    reason: null
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/render-character.js</source>
      <tags></tags>
      <metadata>
        <size>4859</size>
        <lastModified>2025-05-29T02:46:20.676Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>// netlify/functions/render-character.js
import { PrismaClient } from &#39;@prisma/client&#39;

// For now, let&#39;s create a simple version without Sharp since it might be causing issues
const prisma = new PrismaClient()

// Configuration
const ASSET_BASE_URL = process.env.NODE_ENV === &#39;production&#39;
  ? &#39;https://earth.ndao.computer&#39;
  : process.env.URL || &#39;http://localhost:8888&#39;

/**
 * Generate character layers from database data
 */
function generateCharacterLayers(character) {
  const layers = []

  // Background layer
  const backgroundName = character.currentLocation?.biome || &#39;mining-plains&#39;
  layers.push({
    type: &#39;backgrounds&#39;,
    name: backgroundName,
    url: `${ASSET_BASE_URL}/layers/backgrounds/${backgroundName}.png`,
    visible: true,
    zIndex: 0
  })

  // Base layer
  const baseName = character.gender?.toLowerCase() || &#39;male&#39;
  layers.push({
    type: &#39;bases&#39;,
    name: baseName,
    url: `${ASSET_BASE_URL}/layers/bases/${baseName}.png`,
    visible: true,
    zIndex: 1
  })

  // Equipment layers from inventory
  if (character.inventory) {
    character.inventory
      .filter(inv =&gt; inv.isEquipped)
      .forEach(inv =&gt; {
        const item = inv.item
        let layerType, layerName

        // Map items to layers
        switch (item.category) {
          case &#39;HAT&#39;:
            if (item.name === &#39;Miners Hat&#39;) {
              layerType = &#39;accessories&#39;
              layerName = &#39;miners-hat&#39;
            }
            break
          case &#39;CLOTHING&#39;:
            if (item.name === &#39;Cyber Jacket&#39;) {
              layerType = &#39;clothing&#39;
              layerName = &#39;cyber-jacket&#39;
            } else if (item.name === &#39;Work Gloves&#39;) {
              layerType = &#39;accessories&#39;
              layerName = &#39;work-gloves&#39;
            }
            break
          case &#39;ACCESSORY&#39;:
            if (item.name === &#39;Lucky Charm&#39;) {
              layerType = &#39;accessories&#39;
              layerName = &#39;lucky-charm&#39;
            }
            break
        }

        if (layerType &amp;&amp; layerName) {
          layers.push({
            type: layerType,
            name: layerName,
            url: `${ASSET_BASE_URL}/layers/${layerType}/${layerName}.png`,
            visible: true,
            zIndex: layerType === &#39;clothing&#39; ? 2 : 3
          })
        }
      })
  }

  // Sort by z-index
  return layers.sort((a, b) =&gt; a.zIndex - b.zIndex)
}

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;,
    &#39;Cache-Control&#39;: &#39;public, max-age=3600&#39; // Cache for 1 hour
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    // Extract character ID from path
    const pathParts = event.path.split(&#39;/&#39;)
    const characterParam = pathParts[pathParts.length - 1]
    const characterId = characterParam.replace(&#39;.png&#39;, &#39;&#39;)

    if (!characterId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Character ID required&#39; })
      }
    }

    // Get character data
    let character

    if (characterId === &#39;demo&#39; || characterId === &#39;1337&#39;) {
      // Demo character
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; },
        include: {
          currentLocation: true,
          inventory: {
            where: { isEquipped: true },
            include: { item: true }
          }
        }
      })
    } else {
      // Real character by ID
      character = await prisma.character.findUnique({
        where: { id: characterId },
        include: {
          currentLocation: true,
          inventory: {
            where: { isEquipped: true },
            include: { item: true }
          }
        }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // For now, just return the layer information as JSON until we get Sharp working
    // Generate layers
    const layers = generateCharacterLayers(character)

    return {
      statusCode: 200,
      headers: {
        ...headers,
        &#39;Content-Type&#39;: &#39;application/json&#39;
      },
      body: JSON.stringify({
        character: {
          id: character.id,
          name: character.name,
          location: character.currentLocation?.name
        },
        layers: layers,
        message: &#39;Layer composition ready - PNG rendering coming soon!&#39;
      })
    }

  } catch (error) {
    console.error(&#39;Error rendering character:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Rendering failed&#39;,
        message: error.message
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/send-message.js</source>
      <tags></tags>
      <metadata>
        <size>6576</size>
        <lastModified>2025-05-29T00:06:10.082Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const {
      characterId = &#39;hardcoded-demo&#39;,
      locationId,
      message,
      messageType = &#39;CHAT&#39;
    } = JSON.parse(event.body || &#39;{}&#39;)

    if (!locationId || !message?.trim()) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Missing required fields&#39;,
          message: &#39;Location ID and message content are required&#39;
        })
      }
    }

    // Validate message length
    if (message.length &gt; 500) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Message too long&#39;,
          message: &#39;Messages must be 500 characters or less&#39;
        })
      }
    }

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Get location to verify it exists and has chat enabled
    const location = await prisma.location.findUnique({
      where: { id: locationId }
    })

    if (!location) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Location not found&#39; })
      }
    }

    if (!location.hasChat) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Chat not available&#39;,
          message: &#39;This location does not support chat&#39;
        })
      }
    }

    // Verify character is at this location or a related location (for regional chat)
    let canChat = false

    if (character.currentLocationId === locationId) {
      canChat = true
    } else if (location.chatScope === &#39;REGIONAL&#39;) {
      // Check if character is in a sub-location or parent location
      const characterLocation = await prisma.location.findUnique({
        where: { id: character.currentLocationId }
      })

      if (characterLocation) {
        // Check if character&#39;s location is a parent of the chat location
        if (characterLocation.id === location.parentLocationId) {
          canChat = true
        }
        // Check if character&#39;s location has the same parent as chat location
        else if (characterLocation.parentLocationId === location.parentLocationId &amp;&amp; location.parentLocationId) {
          canChat = true
        }
        // Check if chat location is a sub-location of character&#39;s location
        else if (location.parentLocationId === characterLocation.id) {
          canChat = true
        }
      }
    }

    if (!canChat) {
      return {
        statusCode: 403,
        headers,
        body: JSON.stringify({
          error: &#39;Cannot chat here&#39;,
          message: &#39;You must be at this location to participate in chat&#39;
        })
      }
    }

    // Basic content filtering (expand as needed)
    const bannedWords = [&#39;spam&#39;, &#39;scam&#39;, &#39;hack&#39;] // Add more as needed
    const lowercaseMessage = message.toLowerCase()
    const hasBannedWords = bannedWords.some(word =&gt; lowercaseMessage.includes(word))

    if (hasBannedWords) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Message blocked&#39;,
          message: &#39;Your message contains prohibited content&#39;
        })
      }
    }

    // Rate limiting check (simple version)
    const recentMessages = await prisma.chatMessage.findMany({
      where: {
        characterId: character.id,
        createdAt: {
          gte: new Date(Date.now() - 60000) // Last minute
        }
      }
    })

    if (recentMessages.length &gt;= 10) {
      return {
        statusCode: 429,
        headers,
        body: JSON.stringify({
          error: &#39;Rate limited&#39;,
          message: &#39;Please wait before sending another message&#39;
        })
      }
    }

    // Create chat message
    const chatMessage = await prisma.chatMessage.create({
      data: {
        locationId: locationId,
        characterId: character.id,
        message: message.trim(),
        messageType: messageType,
        isSystem: false
      },
      include: {
        character: {
          select: {
            id: true,
            name: true,
            characterType: true,
            currentImageUrl: true
          }
        },
        location: {
          select: {
            id: true,
            name: true,
            locationType: true
          }
        }
      }
    })

    // Update location last active timestamp
    await prisma.location.update({
      where: { id: locationId },
      data: { lastActive: new Date() }
    })

    // Transform message for response
    const transformedMessage = {
      id: chatMessage.id,
      message: chatMessage.message,
      messageType: chatMessage.messageType,
      isSystem: chatMessage.isSystem,
      timeAgo: &#39;now&#39;,
      createdAt: chatMessage.createdAt,
      character: {
        id: chatMessage.character.id,
        name: chatMessage.character.name,
        characterType: chatMessage.character.characterType,
        imageUrl: chatMessage.character.currentImageUrl
      },
      location: {
        id: chatMessage.location.id,
        name: chatMessage.location.name,
        locationType: chatMessage.location.locationType
      }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        success: true,
        message: &#39;Message sent successfully&#39;,
        chatMessage: transformedMessage,
        timestamp: new Date().toISOString()
      })
    }

  } catch (error) {
    console.error(&#39;Error sending message:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to send message&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/get-chat.js</source>
      <tags></tags>
      <metadata>
        <size>4454</size>
        <lastModified>2025-05-28T23:51:59.175Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    const locationId = event.queryStringParameters?.locationId
    const limit = parseInt(event.queryStringParameters?.limit || &#39;50&#39;)

    if (!locationId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Location ID is required&#39; })
      }
    }

    // Get the location to understand chat scope
    const location = await prisma.location.findUnique({
      where: { id: locationId },
      include: {
        parentLocation: true,
        subLocations: true
      }
    })

    if (!location) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Location not found&#39; })
      }
    }

    let chatLocationIds = [locationId]

    // Handle chat scope - REGIONAL chat includes parent and sub-locations
    if (location.chatScope === &#39;REGIONAL&#39;) {
      // If this is a parent location, include all sub-locations
      if (location.subLocations?.length &gt; 0) {
        chatLocationIds.push(...location.subLocations.map(sub =&gt; sub.id))
      }
      // If this is a sub-location, include the parent
      if (location.parentLocationId) {
        chatLocationIds.push(location.parentLocationId)
        // Also include sibling sub-locations
        const siblings = await prisma.location.findMany({
          where: {
            parentLocationId: location.parentLocationId,
            id: { not: locationId }
          }
        })
        chatLocationIds.push(...siblings.map(sib =&gt; sib.id))
      }
    }

    // Get chat messages for the relevant locations
    const messages = await prisma.chatMessage.findMany({
      where: {
        locationId: { in: chatLocationIds }
      },
      include: {
        character: {
          select: {
            id: true,
            name: true,
            characterType: true,
            currentImageUrl: true
          }
        },
        location: {
          select: {
            id: true,
            name: true,
            locationType: true
          }
        }
      },
      orderBy: {
        createdAt: &#39;desc&#39;
      },
      take: limit
    })

    // Transform messages for frontend
    const transformedMessages = messages.reverse().map(msg =&gt; {
      // Calculate time ago
      const timeAgo = getTimeAgo(msg.createdAt)

      return {
        id: msg.id,
        message: msg.message,
        messageType: msg.messageType,
        isSystem: msg.isSystem,
        timeAgo: timeAgo,
        createdAt: msg.createdAt,
        character: msg.isSystem ? null : {
          id: msg.character.id,
          name: msg.character.name,
          characterType: msg.character.characterType,
          imageUrl: msg.character.currentImageUrl
        },
        location: {
          id: msg.location.id,
          name: msg.location.name,
          locationType: msg.location.locationType
        }
      }
    })

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        messages: transformedMessages,
        totalCount: transformedMessages.length,
        locationId: locationId,
        chatScope: location.chatScope,
        locationName: location.name,
        timestamp: new Date().toISOString()
      })
    }

  } catch (error) {
    console.error(&#39;Error fetching chat messages:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to fetch chat messages&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}

// Helper function to calculate time ago
function getTimeAgo(date) {
  const now = new Date()
  const diffInSeconds = Math.floor((now - date) / 1000)

  if (diffInSeconds &lt; 60) {
    return `${diffInSeconds}s ago`
  } else if (diffInSeconds &lt; 3600) {
    const minutes = Math.floor(diffInSeconds / 60)
    return `${minutes}m ago`
  } else if (diffInSeconds &lt; 86400) {
    const hours = Math.floor(diffInSeconds / 3600)
    return `${hours}h ago`
  } else {
    const days = Math.floor(diffInSeconds / 86400)
    return `${days}d ago`
  }
}
</content>
    </document>

    <document>
      <source>scripts/update-mining-with-tools.ts</source>
      <tags></tags>
      <metadata>
        <size>4576</size>
        <lastModified>2025-05-29T06:21:32.931Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/update-mining-with-tools.ts - Add new tools to mining locations
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// Additional mining resources with new tools
const TOOL_MINING_CONFIGS = {
  &#39;Mining Plains&#39;: [
    { name: &#39;Basic Pickaxe&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 1 },
    { name: &#39;Multi-Tool&#39;, spawnRate: 0.05, maxPerDay: 2, difficulty: 1 },
    { name: &#39;Repair Kit&#39;, spawnRate: 0.04, maxPerDay: 2, difficulty: 1 },
  ],

  &#39;Crystal Caves&#39;: [
    { name: &#39;Drill Hammer&#39;, spawnRate: 0.03, maxPerDay: 1, difficulty: 3 },
    { name: &#39;Scanning Device&#39;, spawnRate: 0.02, maxPerDay: 1, difficulty: 3 },
    { name: &#39;Laser Cutter&#39;, spawnRate: 0.015, maxPerDay: 1, difficulty: 4 },
    { name: &#39;Omni-Tool&#39;, spawnRate: 0.002, maxPerDay: 1, difficulty: 5 }, // Ultra rare
  ],

  &#39;Desert Outpost&#39;: [
    { name: &#39;Survival Knife&#39;, spawnRate: 0.06, maxPerDay: 2, difficulty: 2 },
    { name: &#39;Fire Starter&#39;, spawnRate: 0.05, maxPerDay: 3, difficulty: 1 },
    { name: &#39;GPS Tracker&#39;, spawnRate: 0.03, maxPerDay: 1, difficulty: 2 },
  ],

  &#39;Central Exchange&#39;: [
    { name: &#39;Hacking Toolkit&#39;, spawnRate: 0.02, maxPerDay: 1, difficulty: 4 },
    { name: &#39;Signal Booster&#39;, spawnRate: 0.04, maxPerDay: 2, difficulty: 3 },
    {
      name: &#39;Quantum Processor&#39;,
      spawnRate: 0.008,
      maxPerDay: 1,
      difficulty: 4,
    },
  ],

  &#39;The Glitch Club&#39;: [
    { name: &#39;Hacking Toolkit&#39;, spawnRate: 0.035, maxPerDay: 2, difficulty: 3 }, // Better in underground
    { name: &#39;Reality Wrench&#39;, spawnRate: 0.001, maxPerDay: 1, difficulty: 5 }, // Legendary find
  ],
}

async function updateMiningWithTools() {
  console.log(&#39;🔧 Adding new tools to mining locations...&#39;)

  try {
    const locations = await prisma.location.findMany({
      where: { hasMining: true },
    })

    const items = await prisma.item.findMany()
    const itemMap = new Map(items.map((item) =&gt; [item.name, item]))

    let totalResourcesAdded = 0

    for (const location of locations) {
      const toolConfigs =
        TOOL_MINING_CONFIGS[location.name as keyof typeof TOOL_MINING_CONFIGS]

      if (!toolConfigs) {
        continue // Skip locations without tool configs
      }

      console.log(`\n🔧 Adding tools to ${location.name}...`)

      for (const toolConfig of toolConfigs) {
        const item = itemMap.get(toolConfig.name)

        if (!item) {
          console.log(`  ❌ Tool &#39;${toolConfig.name}&#39; not found in database`)
          continue
        }

        // Check if resource already exists
        const existingResource = await prisma.locationResource.findUnique({
          where: {
            locationId_itemId: {
              locationId: location.id,
              itemId: item.id,
            },
          },
        })

        if (existingResource) {
          console.log(
            `  ⚠️  ${toolConfig.name} already configured for this location`
          )
          continue
        }

        // Create new resource
        await prisma.locationResource.create({
          data: {
            locationId: location.id,
            itemId: item.id,
            spawnRate: toolConfig.spawnRate,
            maxPerDay: toolConfig.maxPerDay,
            difficulty: toolConfig.difficulty,
          },
        })

        console.log(
          `  ✨ Added ${toolConfig.name}: ${(
            toolConfig.spawnRate * 100
          ).toFixed(1)}% spawn`
        )
        totalResourcesAdded++
      }
    }

    console.log(
      `\n🎉 Tool mining resources added! Added ${totalResourcesAdded} new tool nodes`
    )

    // Show ultra-rare tool finds
    console.log(&#39;\n⭐ Ultra-Rare Tool Finds:&#39;)
    const rareToolResources = await prisma.locationResource.findMany({
      where: {
        spawnRate: { lt: 0.01 },
        item: { category: &#39;TOOL&#39; },
      },
      include: {
        item: true,
        location: true,
      },
      orderBy: { spawnRate: &#39;asc&#39; },
    })

    rareToolResources.forEach((resource) =&gt; {
      console.log(
        `  🔧 ${resource.item.name} in ${resource.location.name}: ${(
          resource.spawnRate * 100
        ).toFixed(2)}% chance`
      )
    })

    // Show total tool mining nodes
    const totalToolNodes = await prisma.locationResource.count({
      where: {
        item: { category: &#39;TOOL&#39; },
      },
    })

    console.log(`\n📊 Total tool mining nodes: ${totalToolNodes}`)
  } catch (error) {
    console.error(&#39;❌ Failed to update mining with tools:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

updateMiningWithTools()
</content>
    </document>

    <document>
      <source>scripts/seed-mining-resources.ts</source>
      <tags></tags>
      <metadata>
        <size>7017</size>
        <lastModified>2025-05-29T04:58:00.336Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/seed-mining-resources.ts
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// Mining resource configurations per location
const MINING_CONFIGS = {
  &#39;Mining Plains&#39;: {
    resources: [
      { name: &#39;Dirty Coal&#39;, spawnRate: 0.6, maxPerDay: 25, difficulty: 1 },
      { name: &#39;Iron Scraps&#39;, spawnRate: 0.4, maxPerDay: 15, difficulty: 1 },
      { name: &#39;Ancient Coin&#39;, spawnRate: 0.05, maxPerDay: 2, difficulty: 1 }, // Rare find
    ],
  },
  &#39;Crystal Caves&#39;: {
    resources: [
      { name: &#39;Crystal Shard&#39;, spawnRate: 0.15, maxPerDay: 5, difficulty: 3 },
      { name: &#39;Iron Scraps&#39;, spawnRate: 0.3, maxPerDay: 8, difficulty: 2 },
      { name: &#39;Ancient Coin&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 2 },
    ],
  },
  &#39;Desert Outpost&#39;: {
    resources: [
      { name: &#39;Ancient Coin&#39;, spawnRate: 0.2, maxPerDay: 8, difficulty: 3 }, // Desert specialty
      { name: &#39;Crystal Shard&#39;, spawnRate: 0.08, maxPerDay: 2, difficulty: 4 }, // Very rare
      { name: &#39;Iron Scraps&#39;, spawnRate: 0.25, maxPerDay: 6, difficulty: 3 },
    ],
  },
  // Sub-locations get their own resources too
  &#39;Rusty Pickaxe Inn&#39;: {
    resources: [
      { name: &#39;Dirty Coal&#39;, spawnRate: 0.3, maxPerDay: 5, difficulty: 1 }, // Limited indoor mining
    ],
  },
}

async function seedMiningResources() {
  console.log(&#39;⛏️  Starting mining resources seed...&#39;)

  try {
    // Get all locations and items for reference
    const locations = await prisma.location.findMany({
      where: { hasMining: true },
    })

    const items = await prisma.item.findMany()
    const itemMap = new Map(items.map((item) =&gt; [item.name, item]))

    console.log(`📍 Found ${locations.length} minable locations`)
    console.log(`📦 Found ${items.length} items in database`)

    for (const location of locations) {
      const config =
        MINING_CONFIGS[location.name as keyof typeof MINING_CONFIGS]

      if (!config) {
        console.log(`⚠️  No mining config for ${location.name}, skipping...`)
        continue
      }

      console.log(`\n⛏️  Setting up mining resources for ${location.name}...`)

      for (const resourceConfig of config.resources) {
        const item = itemMap.get(resourceConfig.name)

        if (!item) {
          console.log(
            `  ❌ Item &#39;${resourceConfig.name}&#39; not found in database`
          )
          continue
        }

        // Check if resource already exists
        const existingResource = await prisma.locationResource.findUnique({
          where: {
            locationId_itemId: {
              locationId: location.id,
              itemId: item.id,
            },
          },
        })

        if (existingResource) {
          // Update existing resource
          await prisma.locationResource.update({
            where: { id: existingResource.id },
            data: {
              spawnRate: resourceConfig.spawnRate,
              maxPerDay: resourceConfig.maxPerDay,
              difficulty: resourceConfig.difficulty,
            },
          })
          console.log(
            `  🔄 Updated ${resourceConfig.name}: ${(
              resourceConfig.spawnRate * 100
            ).toFixed(1)}% spawn rate, max ${resourceConfig.maxPerDay}/day`
          )
        } else {
          // Create new resource
          await prisma.locationResource.create({
            data: {
              locationId: location.id,
              itemId: item.id,
              spawnRate: resourceConfig.spawnRate,
              maxPerDay: resourceConfig.maxPerDay,
              difficulty: resourceConfig.difficulty,
            },
          })
          console.log(
            `  ✨ Added ${resourceConfig.name}: ${(
              resourceConfig.spawnRate * 100
            ).toFixed(1)}% spawn rate, max ${resourceConfig.maxPerDay}/day`
          )
        }
      }
    }

    console.log(&#39;\n🎉 Mining resources seed completed successfully!&#39;)

    // Show summary
    const totalResources = await prisma.locationResource.count()
    console.log(`📊 Total mining resources available: ${totalResources}`)

    // Show resource breakdown by location
    console.log(&#39;\n📋 Resource Summary:&#39;)
    for (const location of locations) {
      const locationResources = await prisma.locationResource.findMany({
        where: { locationId: location.id },
        include: { item: true },
      })

      if (locationResources.length &gt; 0) {
        console.log(`\n  ${location.name}:`)
        locationResources.forEach((resource) =&gt; {
          console.log(
            `    • ${resource.item.name} (${(resource.spawnRate * 100).toFixed(
              1
            )}% chance, ${resource.maxPerDay}/day max)`
          )
        })
      }
    }
  } catch (error) {
    console.error(&#39;❌ Mining resources seed failed:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

// Command line options
const args = process.argv.slice(2)

if (args.includes(&#39;--help&#39;) || args.includes(&#39;-h&#39;)) {
  console.log(`
⛏️  Mining Resources Seed Script

Usage:
  npm run seed:mining                    # Setup all mining resources
  npm run seed:mining --clear            # Clear all resources first
  npm run seed:mining --location &quot;Mining Plains&quot;  # Setup specific location

Options:
  --clear                               Clear all location resources first
  --location &lt;name&gt;                     Only setup specific location
  --dry-run                            Show what would be changed without making changes
  --help, -h                           Show this help message

Resource Spawn Rates:
  0.6 = 60% chance (very common)
  0.4 = 40% chance (common)  
  0.2 = 20% chance (uncommon)
  0.1 = 10% chance (rare)
  0.05 = 5% chance (very rare)
`)
  process.exit(0)
}

// Handle clear option
if (args.includes(&#39;--clear&#39;)) {
  console.log(&#39;🧹 Clearing existing mining resources...&#39;)
  await prisma.locationResource.deleteMany({})
  console.log(&#39;✅ Cleared all mining resources&#39;)
}

// Handle dry run
if (args.includes(&#39;--dry-run&#39;)) {
  console.log(&#39;🔍 DRY RUN MODE - No changes will be made&#39;)
  // You&#39;d implement dry run logic here
}

// Handle specific location
const locationArg = args.indexOf(&#39;--location&#39;)
if (locationArg !== -1 &amp;&amp; args[locationArg + 1]) {
  const targetLocation = args[locationArg + 1]
  console.log(`🎯 Targeting specific location: ${targetLocation}`)

  // Filter MINING_CONFIGS to only include the target location
  const filteredConfig = {
    [targetLocation]:
      MINING_CONFIGS[targetLocation as keyof typeof MINING_CONFIGS],
  }

  if (!filteredConfig[targetLocation]) {
    console.error(`❌ No mining config found for location: ${targetLocation}`)
    console.log(&#39;Available locations:&#39;, Object.keys(MINING_CONFIGS).join(&#39;, &#39;))
    process.exit(1)
  }

  // Replace the configs with filtered version
  Object.keys(MINING_CONFIGS).forEach((key) =&gt; {
    if (key !== targetLocation) {
      delete MINING_CONFIGS[key as keyof typeof MINING_CONFIGS]
    }
  })
}

// Run the seed
seedMiningResources()
</content>
    </document>

    <document>
      <source>scripts/fix-market-locations.ts</source>
      <tags></tags>
      <metadata>
        <size>2825</size>
        <lastModified>2025-05-29T06:07:56.390Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/fix-market-locations.ts - Fix market settings
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

async function fixMarketLocations() {
  console.log(&#39;🔧 Fixing market location settings...\n&#39;)

  try {
    // Enable markets for locations that should have them
    const locationsToEnableMarkets = [
      &#39;Crystal Caves&#39;, // Should have a market
      &#39;The Glitch Club&#39;, // Should have a market
      &#39;Cyber City&#39;,
    ]

    // Disable markets for locations that shouldn&#39;t have them
    const locationsToDisableMarkets = [
      // &#39;Cyber City&#39;, // Parent location - markets are in sub-locations
    ]

    console.log(&#39;✅ ENABLING MARKETS:&#39;)
    for (const locationName of locationsToEnableMarkets) {
      const result = await prisma.location.updateMany({
        where: { name: locationName },
        data: { hasMarket: true },
      })

      if (result.count &gt; 0) {
        console.log(`  🏪 ${locationName} - market enabled`)
      } else {
        console.log(`  ❌ ${locationName} - location not found`)
      }
    }

    console.log(&#39;\n❌ DISABLING MARKETS:&#39;)
    for (const locationName of locationsToDisableMarkets) {
      const result = await prisma.location.updateMany({
        where: { name: locationName },
        data: { hasMarket: false },
      })

      if (result.count &gt; 0) {
        console.log(
          `  🚫 ${locationName} - market disabled (use sub-locations instead)`
        )
      } else {
        console.log(`  ❌ ${locationName} - location not found`)
      }
    }

    console.log(&#39;\n🔍 UPDATED MARKET LOCATIONS:&#39;)
    const marketLocations = await prisma.location.findMany({
      where: { hasMarket: true },
      orderBy: [{ parentLocationId: &#39;asc&#39; }, { name: &#39;asc&#39; }],
    })

    marketLocations.forEach((location) =&gt; {
      const isParent = !location.parentLocationId
      const parentIcon = isParent ? &#39;🏛️&#39; : &#39;  └─&#39;
      console.log(`${parentIcon} ${location.name} (${location.locationType})`)
    })

    console.log(`\n📊 Total market locations: ${marketLocations.length}`)

    // Check if we have configs for all market locations
    const MARKET_CONFIG_NAMES = [
      &#39;Mining Plains&#39;,
      &#39;Central Exchange&#39;,
      &#39;Desert Outpost&#39;,
      &#39;The Glitch Club&#39;,
      &#39;Rusty Pickaxe Inn&#39;,
      &#39;Crystal Caves&#39;,
      &#39;Cyber City&#39;, // Added parent location config
    ]

    console.log(&#39;\n🎯 MARKET CONFIG COVERAGE:&#39;)
    marketLocations.forEach((location) =&gt; {
      const hasConfig = MARKET_CONFIG_NAMES.includes(location.name)
      const configIcon = hasConfig ? &#39;✅&#39; : &#39;❌&#39;
      console.log(`  ${configIcon} ${location.name}`)
    })

    console.log(&#39;\n✨ Market location settings fixed!&#39;)
  } catch (error) {
    console.error(&#39;❌ Fix failed:&#39;, error)
  } finally {
    await prisma.$disconnect()
  }
}

fixMarketLocations()
</content>
    </document>

    <document>
      <source>scripts/setup-new-regions-content.ts</source>
      <tags></tags>
      <metadata>
        <size>9594</size>
        <lastModified>2025-05-29T10:04:14.004Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/setup-new-regions-content.ts - Markets &amp; Mining for the 5 new regions
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// Market configurations for new regions
const NEW_MARKET_CONFIGS = {
  &#39;The Glitch Wastes&#39;: [
    { name: &#39;Glitch Goggles&#39;, quantity: 2, price: 120 },
    { name: &#39;Buffer Overflow Potion&#39;, quantity: 1, price: 200 },
    { name: &#39;Pixel Dust&#39;, quantity: 15, price: 8 },
    { name: &#39;Energy Drink&#39;, quantity: 5, price: 20 }, // More expensive in harsh digital wasteland
    { name: &#39;Hacking Toolkit&#39;, quantity: 3, price: 90 }, // Cheaper here
    { name: &#39;Signal Booster&#39;, quantity: 2, price: 60 },
  ],

  &#39;Error 404 Oasis&#39;: [
    { name: &#39;Buffer Overflow Potion&#39;, quantity: 3, price: 180 }, // Oasis specialty
    { name: &#39;Health Potion&#39;, quantity: 8, price: 40 },
    { name: &#39;Temporal Stabilizer&#39;, quantity: 2, price: 85 }, // Cross-region rare item
  ],

  &#39;Fungi Networks&#39;: [
    { name: &#39;Symbiotic Armor&#39;, quantity: 1, price: 300 },
    { name: &#39;Decay Catalyst&#39;, quantity: 2, price: 150 },
    { name: &#39;Neural Spores&#39;, quantity: 12, price: 25 },
    { name: &#39;Mycelium Thread&#39;, quantity: 20, price: 5 },
    { name: &#39;Health Potion&#39;, quantity: 15, price: 18 }, // Cheaper organic healing
    { name: &#39;Bone Marrow Elixir&#39;, quantity: 4, price: 60 },
  ],

  &#39;Spore Exchange&#39;: [
    { name: &#39;Neural Spores&#39;, quantity: 25, price: 20 }, // Exchange specialty
    { name: &#39;Mycelium Thread&#39;, quantity: 50, price: 3 },
    { name: &#39;Living Bone Tools&#39;, quantity: 2, price: 180 },
    { name: &#39;Symbiotic Armor&#39;, quantity: 2, price: 280 },
  ],

  &#39;Temporal Rift Zone&#39;: [
    { name: &#39;Paradox Engine&#39;, quantity: 1, price: 5000 }, // Ultra rare legendary
    { name: &#39;Temporal Flux&#39;, quantity: 2, price: 1000 },
    { name: &#39;Causality Loop&#39;, quantity: 3, price: 400 },
    { name: &#39;Temporal Stabilizer&#39;, quantity: 8, price: 75 },
    { name: &#39;Energy Drink&#39;, quantity: 3, price: 25 }, // Time dilation makes everything expensive
  ],

  &quot;Yesterday&#39;s Tomorrow&quot;: [
    { name: &#39;Temporal Stabilizer&#39;, quantity: 15, price: 65 }, // Tomorrow&#39;s specialty
    { name: &#39;Causality Loop&#39;, quantity: 5, price: 350 },
    { name: &#39;Quantum Processor&#39;, quantity: 1, price: 400 }, // From other regions
    { name: &#39;Ancient Coin&#39;, quantity: 10, price: 30 }, // From various timelines
  ],

  &#39;The Bone Markets&#39;: [
    { name: &#39;Living Bone Tools&#39;, quantity: 4, price: 160 },
    { name: &#39;Skeletal Framework&#39;, quantity: 2, price: 220 },
    { name: &#39;Calcium Crystals&#39;, quantity: 20, price: 15 },
    { name: &#39;Bone Marrow Elixir&#39;, quantity: 12, price: 45 },
    { name: &#39;Ancient Coin&#39;, quantity: 8, price: 40 }, // Bones are old
    { name: &#39;Health Potion&#39;, quantity: 6, price: 50 }, // Death-adjacent pricing
  ],

  &#39;Calcium Exchange&#39;: [
    { name: &#39;Calcium Crystals&#39;, quantity: 40, price: 10 }, // Exchange bulk pricing
    { name: &#39;Living Bone Tools&#39;, quantity: 8, price: 140 },
    { name: &#39;Skeletal Framework&#39;, quantity: 4, price: 200 },
    { name: &#39;Ancient Artifact&#39;, quantity: 1, price: 800 }, // Rare ancient find
  ],

  &#39;Static Fields&#39;: [
    { name: &#39;Signal Booster Helmet&#39;, quantity: 2, price: 180 },
    { name: &#39;White Noise Generator&#39;, quantity: 3, price: 130 },
    { name: &#39;Frequency Modulator&#39;, quantity: 2, price: 200 },
    { name: &#39;Static Cling&#39;, quantity: 25, price: 6 },
    { name: &#39;Glitch Goggles&#39;, quantity: 1, price: 140 }, // Cross-region synergy
  ],

  &#39;Dead Air Tavern&#39;: [
    { name: &#39;Energy Drink&#39;, quantity: 12, price: 15 },
    { name: &#39;Static Cling&#39;, quantity: 30, price: 4 }, // Tavern bulk
    { name: &#39;Frequency Modulator&#39;, quantity: 3, price: 180 },
    { name: &#39;Code Energy Drink&#39;, quantity: 8, price: 22 }, // Digital synergy
  ],
}

// Mining configurations for new regions
const NEW_MINING_CONFIGS = {
  &#39;The Glitch Wastes&#39;: [
    { name: &#39;Pixel Dust&#39;, spawnRate: 0.4, maxPerDay: 20, difficulty: 4 },
    { name: &#39;Fragmented Code&#39;, spawnRate: 0.12, maxPerDay: 6, difficulty: 5 },
    { name: &#39;Static Cling&#39;, spawnRate: 0.25, maxPerDay: 12, difficulty: 4 },
    { name: &#39;Glitch Goggles&#39;, spawnRate: 0.02, maxPerDay: 1, difficulty: 6 },
  ],

  &#39;Corrupted Data Mines&#39;: [
    { name: &#39;Fragmented Code&#39;, spawnRate: 0.3, maxPerDay: 10, difficulty: 5 },
    { name: &#39;Pixel Dust&#39;, spawnRate: 0.6, maxPerDay: 25, difficulty: 4 },
    { name: &#39;Buffer Overflow Potion&#39;, spawnRate: 0.008, maxPerDay: 1, difficulty: 7 }, // Ultra rare
  ],

  &#39;Fungi Networks&#39;: [
    { name: &#39;Mycelium Thread&#39;, spawnRate: 0.5, maxPerDay: 30, difficulty: 3 },
    { name: &#39;Neural Spores&#39;, spawnRate: 0.25, maxPerDay: 15, difficulty: 3 },
    { name: &#39;Decay Catalyst&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 4 },
  ],

  &#39;The Great Mycelium&#39;: [
    { name: &#39;Neural Spores&#39;, spawnRate: 0.4, maxPerDay: 20, difficulty: 4 },
    { name: &#39;Symbiotic Armor&#39;, spawnRate: 0.015, maxPerDay: 1, difficulty: 5 },
    { name: &#39;Mycelium Thread&#39;, spawnRate: 0.7, maxPerDay: 35, difficulty: 3 },
  ],

  &#39;Temporal Rift Zone&#39;: [
    { name: &#39;Temporal Flux&#39;, spawnRate: 0.05, maxPerDay: 2, difficulty: 6 }, // Very rare
    { name: &#39;Causality Loop&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 5 },
    { name: &#39;Temporal Stabilizer&#39;, spawnRate: 0.15, maxPerDay: 8, difficulty: 5 },
  ],

  &#39;Clock Tower Ruins&#39;: [
    { name: &#39;Temporal Flux&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 6 },
    { name: &#39;Paradox Engine&#39;, spawnRate: 0.001, maxPerDay: 1, difficulty: 8 }, // Legendary rare
    { name: &#39;Ancient Coin&#39;, spawnRate: 0.2, maxPerDay: 10, difficulty: 4 }, // Time displaced
  ],

  &#39;The Bone Markets&#39;: [
    { name: &#39;Calcium Crystals&#39;, spawnRate: 0.35, maxPerDay: 18, difficulty: 3 },
    { name: &#39;Living Bone Tools&#39;, spawnRate: 0.06, maxPerDay: 3, difficulty: 4 },
    { name: &#39;Ancient Coin&#39;, spawnRate: 0.18, maxPerDay: 8, difficulty: 3 }, // Grave goods
  ],

  &#39;Static Fields&#39;: [
    { name: &#39;Static Cling&#39;, spawnRate: 0.45, maxPerDay: 22, difficulty: 4 },
    { name: &#39;White Noise Generator&#39;, spawnRate: 0.07, maxPerDay: 3, difficulty: 5 },
    { name: &#39;Frequency Modulator&#39;, spawnRate: 0.04, maxPerDay: 2, difficulty: 5 },
  ],

  &#39;Channel 0&#39;: [
    { name: &#39;Static Cling&#39;, spawnRate: 0.6, maxPerDay: 30, difficulty: 4 },
    { name: &#39;Signal Booster Helmet&#39;, spawnRate: 0.02, maxPerDay: 1, difficulty: 6 },
    { name: &#39;Frequency Modulator&#39;, spawnRate: 0.08, maxPerDay: 4, difficulty: 5 },
  ],
}

async function setupNewRegionsContent() {
  console.log(&#39;🛒 Setting up markets and mining for new regions...\n&#39;)

  try {
    // Get all locations and items for reference
    const locations = await prisma.location.findMany({
      where: { hasMarket: true }
    })
    const miningLocations = await prisma.location.findMany({
      where: { hasMining: true }
    })
    const items = await prisma.item.findMany()
    const itemMap = new Map(items.map(item =&gt; [item.name, item]))

    console.log(`📍 Found ${locations.length} market locations`)
    console.log(`⛏️ Found ${miningLocations.length} mining locations`)

    // Setup markets
    console.log(&#39;\n🏪 Setting up markets...&#39;)
    let marketListingsAdded = 0

    for (const location of locations) {
      const config = NEW_MARKET_CONFIGS[location.name as keyof typeof NEW_MARKET_CONFIGS]
      if (!config) continue

      console.log(`  📦 Stocking ${location.name}...`)

      for (const itemConfig of config) {
        const item = itemMap.get(itemConfig.name)
        if (!item) {
          console.log(`    ❌ Item &#39;${itemConfig.name}&#39; not found`)
          continue
        }

        // Check if listing already exists
        const existing = await prisma.marketListing.findFirst({
          where: {
            locationId: location.id,
            itemId: item.id,
            isSystemItem: true
          }
        })

        if (existing) {
          await prisma.marketListing.update({
            where: { id: existing.id },
            data: {
              quantity: itemConfig.quantity,
              price: itemConfig.price
            }
          })
        } else {
          await prisma.marketListing.create({
            data: {
              locationId: location.id,
              itemId: item.id,
              quantity: itemConfig.quantity,
              price: itemConfig.price,
              isSystemItem: true
            }
          })
          marketListingsAdded++
        }
      }
    }
    console.log(`✅ Added/updated ${marketListingsAdded} market listings`)

    // Setup mining
    console.log(&#39;\n⛏️ Setting up mining resources...&#39;)
    let miningResourcesAdded = 0

    for (const location of miningLocations) {
      const config = NEW_MINING_CONFIGS[location.name as keyof typeof NEW_MINING_CONFIGS]
      if (!config) continue

      console.log(`  🗿 Adding resources to ${location.name}...`)

      for (const resourceConfig of config) {
        const item = itemMap.get(resourceConfig.name)
        if (!item) {
          console.log(`    ❌ Item &#39;${resourceConfig.name}&#39; not found`)
          continue
        }

        // Check if resource already exists
        const existing = await prisma.locationResource.findUnique({
          where: {
            locationId_itemId: {
              locationId: location.id,
              itemId: item.id
            }
          }
        })

        if (!existing) {
          await prisma.locationResource.create({
            data: {
              locationId: location.id,
              itemId: item.id,
              spawnRate: resourceConfig.spawnRate,
              maxPerDay: resourceConfig.maxPerDay,
              difficulty: resourceConfig.difficulty
            }
          })
          m
</content>
    </document>

    <document>
      <source>scripts/seed-markets.ts</source>
      <tags></tags>
      <metadata>
        <size>5711</size>
        <lastModified>2025-05-29T06:22:57.295Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/seed-markets.ts
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// Market configurations per location
const MARKET_CONFIGS = {
  &#39;Mining Plains&#39;: {
    items: [
      { name: &#39;Miners Hat&#39;, quantity: 10, price: 15 },
      { name: &#39;Work Gloves&#39;, quantity: 8, price: 12 },
      { name: &#39;Energy Drink&#39;, quantity: 20, price: 8 },
      { name: &#39;Dirty Coal&#39;, quantity: 50, price: 2 },
      { name: &#39;Iron Scraps&#39;, quantity: 25, price: 5 },
      { name: &#39;Basic Pickaxe&#39;, quantity: 5, price: 20 },
      { name: &#39;Multi-Tool&#39;, quantity: 3, price: 35 },
      { name: &#39;Repair Kit&#39;, quantity: 4, price: 25 },
    ],
  },
  &#39;Central Exchange&#39;: {
    items: [
      { name: &#39;Cyber Jacket&#39;, quantity: 3, price: 75 },
      { name: &#39;Lucky Charm&#39;, quantity: 5, price: 30 },
      { name: &#39;Health Potion&#39;, quantity: 15, price: 25 },
      { name: &#39;Energy Drink&#39;, quantity: 25, price: 10 },
      { name: &#39;Ancient Coin&#39;, quantity: 8, price: 100 },
      { name: &#39;Hacking Toolkit&#39;, quantity: 2, price: 120 },
      { name: &#39;Signal Booster&#39;, quantity: 3, price: 80 },
      { name: &#39;Quantum Processor&#39;, quantity: 1, price: 300 },
      { name: &#39;Scanning Device&#39;, quantity: 2, price: 95 },
    ],
  },
  &#39;Desert Outpost&#39;: {
    items: [
      { name: &#39;Work Gloves&#39;, quantity: 6, price: 18 },
      { name: &#39;Energy Drink&#39;, quantity: 12, price: 15 }, // Higher prices in remote areas
      { name: &#39;Health Potion&#39;, quantity: 8, price: 35 },
      { name: &#39;Crystal Shard&#39;, quantity: 2, price: 200 },
      { name: &#39;Survival Knife&#39;, quantity: 4, price: 30 },
      { name: &#39;Fire Starter&#39;, quantity: 6, price: 15 },
      { name: &#39;GPS Tracker&#39;, quantity: 2, price: 65 },
    ],
  },
}

async function seedMarkets() {
  console.log(&#39;🏪 Starting market seed...&#39;)

  try {
    // Get all locations and items for reference
    const locations = await prisma.location.findMany({
      where: { hasMarket: true },
    })

    const items = await prisma.item.findMany()
    const itemMap = new Map(items.map((item) =&gt; [item.name, item]))

    for (const location of locations) {
      const config =
        MARKET_CONFIGS[location.name as keyof typeof MARKET_CONFIGS]

      if (!config) {
        console.log(`⚠️  No market config for ${location.name}, skipping...`)
        continue
      }

      console.log(`\n🏪 Restocking ${location.name}...`)

      for (const itemConfig of config.items) {
        const item = itemMap.get(itemConfig.name)

        if (!item) {
          console.log(`  ❌ Item &#39;${itemConfig.name}&#39; not found in database`)
          continue
        }

        // Check if listing already exists
        const existingListing = await prisma.marketListing.findFirst({
          where: {
            locationId: location.id,
            itemId: item.id,
            isSystemItem: true,
          },
        })

        if (existingListing) {
          // Update existing listing
          await prisma.marketListing.update({
            where: { id: existingListing.id },
            data: {
              quantity: itemConfig.quantity,
              price: itemConfig.price,
            },
          })
          console.log(
            `  🔄 Updated ${itemConfig.name}: ${itemConfig.quantity} @ ${itemConfig.price} coins`
          )
        } else {
          // Create new listing
          await prisma.marketListing.create({
            data: {
              locationId: location.id,
              itemId: item.id,
              quantity: itemConfig.quantity,
              price: itemConfig.price,
              isSystemItem: true,
            },
          })
          console.log(
            `  ✨ Added ${itemConfig.name}: ${itemConfig.quantity} @ ${itemConfig.price} coins`
          )
        }
      }
    }

    console.log(&#39;\n🎉 Market seed completed successfully!&#39;)

    // Show summary
    const totalListings = await prisma.marketListing.count({
      where: { isSystemItem: true },
    })
    console.log(`📊 Total system market listings: ${totalListings}`)
  } catch (error) {
    console.error(&#39;❌ Market seed failed:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

// Command line options
const args = process.argv.slice(2)

if (args.includes(&#39;--help&#39;) || args.includes(&#39;-h&#39;)) {
  console.log(`
🏪 Market Listing Seed Script

Usage:
  npm run seed:markets              # Restock all markets
  npm run seed:markets --clear      # Clear all system listings first
  npm run seed:markets --location &quot;Central Exchange&quot;  # Restock specific location

Options:
  --clear                           Clear all system listings before restocking
  --location &lt;name&gt;                 Only restock specific location
  --help, -h                        Show this help message
`)
  process.exit(0)
}

// Handle clear option
if (args.includes(&#39;--clear&#39;)) {
  console.log(&#39;🧹 Clearing existing system market listings...&#39;)
  await prisma.marketListing.deleteMany({
    where: { isSystemItem: true },
  })
  console.log(&#39;✅ Cleared all system listings&#39;)
}

// Handle specific location
const locationArg = args.indexOf(&#39;--location&#39;)
if (locationArg !== -1 &amp;&amp; args[locationArg + 1]) {
  const targetLocation = args[locationArg + 1]
  console.log(`🎯 Targeting specific location: ${targetLocation}`)

  // Filter MARKET_CONFIGS to only include the target location
  const filteredConfig = {
    [targetLocation]:
      MARKET_CONFIGS[targetLocation as keyof typeof MARKET_CONFIGS],
  }
  Object.assign(MARKET_CONFIGS, filteredConfig)

  // Clear all other configs
  for (const key in MARKET_CONFIGS) {
    if (key !== targetLocation) {
      delete MARKET_CONFIGS[key as keyof typeof MARKET_CONFIGS]
    }
  }
}

// Run the seed
seedMarkets()
</content>
    </document>

    <document>
      <source>scripts/debug-market-locations.ts</source>
      <tags></tags>
      <metadata>
        <size>2544</size>
        <lastModified>2025-05-29T06:00:54.267Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/debug-market-locations.ts - Check which locations have markets
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

async function debugMarketLocations() {
  console.log(&#39;🔍 Debugging market locations...\n&#39;)

  try {
    const allLocations = await prisma.location.findMany({
      orderBy: [{ parentLocationId: &#39;asc&#39; }, { name: &#39;asc&#39; }],
    })

    const marketLocations = await prisma.location.findMany({
      where: { hasMarket: true },
      orderBy: [{ parentLocationId: &#39;asc&#39; }, { name: &#39;asc&#39; }],
    })

    console.log(&#39;📍 ALL LOCATIONS:&#39;)
    allLocations.forEach((location) =&gt; {
      const isParent = !location.parentLocationId
      const hasMarket = location.hasMarket
      const marketIcon = hasMarket ? &#39;🏪&#39; : &#39;❌&#39;
      const parentIcon = isParent ? &#39;🏛️&#39; : &#39;  └─&#39;

      console.log(
        `${parentIcon} ${marketIcon} ${location.name} (${location.locationType})`
      )
    })

    console.log(&#39;\n🏪 MARKET LOCATIONS ONLY:&#39;)
    marketLocations.forEach((location) =&gt; {
      const isParent = !location.parentLocationId
      const parentIcon = isParent ? &#39;🏛️&#39; : &#39;  └─&#39;
      console.log(`${parentIcon} ${location.name} (${location.locationType})`)
    })

    console.log(&#39;\n📊 SUMMARY:&#39;)
    console.log(`Total locations: ${allLocations.length}`)
    console.log(`Market locations: ${marketLocations.length}`)

    const parentMarkets = marketLocations.filter((loc) =&gt; !loc.parentLocationId)
    const childMarkets = marketLocations.filter((loc) =&gt; loc.parentLocationId)

    console.log(`  └─ Parent locations with markets: ${parentMarkets.length}`)
    console.log(`  └─ Sub-locations with markets: ${childMarkets.length}`)

    // Check existing market listings
    const existingListings = await prisma.marketListing.count({
      where: { isSystemItem: true },
    })

    console.log(`\n💰 EXISTING MARKET DATA:`)
    console.log(`System market listings: ${existingListings}`)

    if (existingListings &gt; 0) {
      const listingsByLocation = await prisma.marketListing.groupBy({
        by: [&#39;locationId&#39;],
        where: { isSystemItem: true },
        _count: { id: true },
      })

      for (const group of listingsByLocation) {
        const location = await prisma.location.findUnique({
          where: { id: group.locationId },
        })
        console.log(`  └─ ${location?.name}: ${group._count.id} items`)
      }
    }
  } catch (error) {
    console.error(&#39;❌ Debug failed:&#39;, error)
  } finally {
    await prisma.$disconnect()
  }
}

debugMarketLocations()
</content>
    </document>

    <document>
      <source>scripts/ultimate-world-setup.ts</source>
      <tags></tags>
      <metadata>
        <size>40705</size>
        <lastModified>2025-05-29T10:08:28.693Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/ultimate-world-setup.ts - Complete Wojak Earth World Builder
import {
  PrismaClient,
  ItemCategory,
  LayerType,
  Rarity,
  LocationType,
  ChatScope,
  Gender,
  CharacterType,
  ChatMessageType,
} from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// ============================================================================
// WORLD CONFIGURATION - Adjust these values to customize your world
// ============================================================================

const WORLD_CONFIG = {
  // World Settings
  WORLD_NAME: &#39;Wojak Earth&#39;,
  MAX_TOTAL_CHARACTERS: 100,
  STARTING_LOCATION_NAME: &#39;Mining Plains&#39;,

  // Character Settings
  DEFAULT_HEALTH: 100,
  DEFAULT_ENERGY: 100,
  ENERGY_VARIATION: 20, // Characters start with 80-100 energy
  HEALTH_VARIATION: 10, // Characters start with 90-100 health

  // Economy Settings
  BASE_MINING_ENERGY_COST: 10,
  PRICE_MULTIPLIERS: {
    &#39;Mining Plains&#39;: 1.0,
    &#39;Desert Outpost&#39;: 1.2,
    &#39;Cyber City&#39;: 1.1,
    &#39;Central Exchange&#39;: 1.15,
    &#39;The Glitch Club&#39;: 0.9,
    &#39;Rusty Pickaxe Inn&#39;: 0.95,
    &#39;Crystal Caves&#39;: 1.1,
    &#39;The Glitch Wastes&#39;: 1.3,
    &#39;Fungi Networks&#39;: 1.1,
    &#39;Temporal Rift Zone&#39;: 1.5,
    &#39;The Bone Markets&#39;: 1.0,
    &#39;Static Fields&#39;: 1.2,
  },

  // Mining Settings
  BASE_SPAWN_RATES: {
    COMMON: 0.4,
    UNCOMMON: 0.2,
    RARE: 0.1,
    EPIC: 0.05,
    LEGENDARY: 0.01,
  },

  // Features to Enable/Disable
  FEATURES: {
    CREATE_LOCATIONS: true,
    CREATE_ITEMS: true,
    CREATE_CHARACTERS: true,
    SETUP_MARKETS: true,
    SETUP_MINING: true,
    CREATE_CHAT_HISTORY: true,
    CLEAR_EXISTING_DATA: true,
  },
}

// ============================================================================
// WORLD DATA DEFINITIONS
// ============================================================================

const WORLD_LOCATIONS = [
  // Original Regions
  {
    name: &#39;Mining Plains&#39;,
    description: &#39;Rich in basic materials and perfect for newcomers&#39;,
    locationType: LocationType.REGION,
    biome: &#39;plains&#39;,
    difficulty: 1,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: ChatScope.REGIONAL,
    welcomeMessage: &#39;The wind carries the sound of pickaxes striking stone.&#39;,
    lore: &#39;Once a vast battlefield, these plains now serve as the primary mining grounds for new arrivals.&#39;,
    mapX: 100,
    mapY: 200,
    subLocations: [
      {
        name: &#39;Rusty Pickaxe Inn&#39;,
        description: &#39;A cozy tavern where miners share stories and ale&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 1,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        chatScope: ChatScope.LOCAL,
        welcomeMessage: &#39;The smell of ale and roasted meat fills the air.&#39;,
      },
      {
        name: &#39;Crystal Caves&#39;,
        description: &#39;Deep underground shafts where rare crystals grow&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 2,
        hasMarket: true,
        hasMining: true,
        hasChat: true,
        chatScope: ChatScope.LOCAL,
        welcomeMessage: &#39;Crystalline formations sparkle in your torchlight.&#39;,
      },
    ],
  },

  {
    name: &#39;Desert Outpost&#39;,
    description: &#39;Harsh but rewarding terrain for experienced miners&#39;,
    locationType: LocationType.REGION,
    biome: &#39;desert&#39;,
    difficulty: 3,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: ChatScope.REGIONAL,
    welcomeMessage: &#39;The scorching sun beats down mercilessly.&#39;,
    lore: &#39;A remote trading post built around an ancient oasis.&#39;,
    mapX: 400,
    mapY: 100,
  },

  {
    name: &#39;Cyber City&#39;,
    description: &#39;The technological heart of wojak civilization&#39;,
    locationType: LocationType.CITY,
    biome: &#39;urban&#39;,
    difficulty: 2,
    hasMarket: true,
    hasMining: false,
    hasChat: true,
    chatScope: ChatScope.LOCAL,
    welcomeMessage: &#39;Neon lights flicker in the perpetual twilight.&#39;,
    lore: &#39;The beating heart of wojak civilization.&#39;,
    mapX: 300,
    mapY: 300,
    subLocations: [
      {
        name: &#39;Central Exchange&#39;,
        description: &#39;The main financial district and trading hub&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 2,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        chatScope: ChatScope.LOCAL,
        welcomeMessage:
          &#39;Holographic displays show market prices from across the world.&#39;,
      },
      {
        name: &#39;The Glitch Club&#39;,
        description: &#39;Underground social hub for hackers and rebels&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 2,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        chatScope: ChatScope.LOCAL,
        welcomeMessage: &#39;Bass-heavy music thumps through the smoky atmosphere.&#39;,
      },
    ],
  },

  // Weird New Regions
  {
    name: &#39;The Glitch Wastes&#39;,
    description:
      &#39;Digital desert where reality breaks down into pixelated fragments&#39;,
    locationType: LocationType.REGION,
    biome: &#39;digital&#39;,
    difficulty: 4,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: ChatScope.REGIONAL,
    welcomeMessage: &#39;ERROR_404: WELCOME_MESSAGE_NOT_FOUND&#39;,
    lore: &#39;Once a stable data center, this region was corrupted by a massive system failure.&#39;,
    mapX: 600,
    mapY: 150,
    subLocations: [
      {
        name: &#39;Error 404 Oasis&#39;,
        description: &#39;A rest stop that may or may not actually exist&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 4,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;null reference exception: comfort not found&#39;,
      },
      {
        name: &#39;Corrupted Data Mines&#39;,
        description: &#39;Extract valuable code fragments from broken databases&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 5,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;Warning: Memory corruption detected&#39;,
      },
    ],
  },

  {
    name: &#39;Fungi Networks&#39;,
    description: &#39;Underground mycelium city where everything is connected&#39;,
    locationType: LocationType.REGION,
    biome: &#39;underground&#39;,
    difficulty: 3,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: ChatScope.REGIONAL,
    welcomeMessage: &#39;The network acknowledges your presence.&#39;,
    lore: &#39;A vast underground organism that has achieved collective consciousness.&#39;,
    mapX: 200,
    mapY: 400,
    subLocations: [
      {
        name: &#39;Spore Exchange&#39;,
        description: &#39;Trading post where biological resources are shared&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 3,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Breathe deeply. The spores will show you the way.&#39;,
      },
      {
        name: &#39;The Great Mycelium&#39;,
        description: &#39;Central nervous system of the fungal network&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 4,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;You are now part of something greater.&#39;,
      },
    ],
  },

  {
    name: &#39;Temporal Rift Zone&#39;,
    description: &#39;Time moves strangely here, past and future bleeding together&#39;,
    locationType: LocationType.REGION,
    biome: &#39;temporal&#39;,
    difficulty: 5,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: ChatScope.REGIONAL,
    welcomeMessage: &#39;When are you?&#39;,
    lore: &#39;A scientific experiment gone wrong tore holes in spacetime.&#39;,
    mapX: 500,
    mapY: 350,
    subLocations: [
      {
        name: &quot;Yesterday&#39;s Tomorrow&quot;,
        description:
          &#39;A marketplace selling items from timelines that never were&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 5,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;This conversation happened before you arrived.&#39;,
      },
      {
        name: &#39;Clock Tower Ruins&#39;,
        description:
          &#39;Collapsed timekeeper where temporal fragments can be mined&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 6,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;Time is broken here. Proceed with caution.&#39;,
      },
    ],
  },

  {
    name: &#39;The Bone Markets&#39;,
    description:
      &#39;Skeletal merchants trade in organic technology and calcium currency&#39;,
    locationType: LocationType.REGION,
    biome: &#39;ossuary&#39;,
    difficulty: 3,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: ChatScope.REGIONAL,
    welcomeMessage: &#39;Welcome, flesh-bearer. What bones do you bring?&#39;,
    lore: &#39;An ancient cemetery evolved into a thriving market.&#39;,
    mapX: 150,
    mapY: 300,
    subLocations: [
      {
        name: &#39;Calcium Exchange&#39;,
        description: &#39;Primary trading floor for bone-based materials&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 3,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Rattle your coins, the dealers are listening.&#39;,
      },
      {
        name: &#39;Ossuary Club&#39;,
        description:
          &#39;Social gathering place decorated with artistic bone arrangements&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 2,
        hasMarket: false,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Dance among the ancestors.&#39;,
      },
    ],
  },

  {
    name: &#39;Static Fields&#39;,
    description:
      &#39;Everything covered in TV static, reality unclear and shifting&#39;,
    locationType: LocationType.REGION,
    biome: &#39;electromagnetic&#39;,
    difficulty: 4,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: ChatScope.REGIONAL,
    welcomeMessage: &#39;████████ ██ ████ ███ ████&#39;,
    lore: &#39;A massive electromagnetic anomaly interferes with all signals.&#39;,
    mapX: 450,
    mapY: 250,
    subLocations: [
      {
        name: &#39;Channel 0&#39;,
        description:
          &#39;Broadcasting station for frequencies that should not exist&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 4,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;█ow ██ █ing?&#39;,
      },
      {
        name: &#39;Dead Air Tavern&#39;,
        description:
          &#39;Social hub where the static is slightly less overwhelming&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 3,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Can you hear me now? Good.&#39;,
      },
    ],
  },
]

const WORLD_ITEMS = [
  // Basic Materials
  {
    name: &#39;Dirty Coal&#39;,
    description: &#39;Basic fuel found in shallow mines&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
  },
  {
    name: &#39;Iron Scraps&#39;,
    description: &#39;Rusty metal pieces, still useful&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
  },
  {
    name: &#39;Ancient Coin&#39;,
    description: &#39;Currency from a forgotten civilization&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.RARE,
  },
  {
    name: &#39;Crystal Shard&#39;,
    description: &#39;Glowing fragment with mysterious properties&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.EPIC,
  },

  // Basic Equipment
  {
    name: &#39;Miners Hat&#39;,
    description: &#39;Worn leather hat with a dim headlamp&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.COMMON,
    durability: 100,
    energyEffect: 5,
  },
  {
    name: &#39;Work Gloves&#39;,
    description: &#39;Tough gloves for manual labor&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 80,
  },
  {
    name: &#39;Lucky Charm&#39;,
    description: &quot;A rabbit&#39;s foot that might bring fortune&quot;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.UNCOMMON,
  },
  {
    name: &#39;Cyber Jacket&#39;,
    description: &#39;High-tech jacket with built-in displays&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.RARE,
    energyEffect: 15,
  },

  // Basic Consumables
  {
    name: &#39;Energy Drink&#39;,
    description: &#39;Restores energy and keeps you alert&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.COMMON,
    energyEffect: 25,
  },
  {
    name: &#39;Health Potion&#39;,
    description: &#39;Mysterious red liquid that heals wounds&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.UNCOMMON,
    healthEffect: 30,
  },

  // Tools
  {
    name: &#39;Basic Pickaxe&#39;,
    description: &#39;Standard mining tool for beginners&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 50,
  },
  {
    name: &#39;Multi-Tool&#39;,
    description: &#39;Swiss army knife of the digital age&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 100,
  },
  {
    name: &#39;Hacking Toolkit&#39;,
    description: &#39;Portable device for digital infiltration&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 150,
  },
  {
    name: &#39;Omni-Tool&#39;,
    description: &#39;Legendary device that adapts to any situation&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.LEGENDARY,
    durability: 1000,
    energyEffect: 20,
    healthEffect: 10,
  },

  // Themed Items - Cyber
  {
    name: &#39;Rare Floppy Disk&#39;,
    description: &#39;Contains legendary source code from the early net&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.LEGENDARY,
  },
  {
    name: &#39;Cyberpunk Shades&#39;,
    description: &#39;AR-enhanced sunglasses with data overlay&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    energyEffect: 10,
  },
  {
    name: &#39;Neon Visor&#39;,
    description: &#39;Glowing headgear that screams &quot;I hack the planet&quot;&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.EPIC,
    energyEffect: 15,
  },

  // Themed Items - Desert
  {
    name: &#39;Desert Wrap&#39;,
    description: &#39;Traditional headwrap that protects from sandstorms&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.UNCOMMON,
    healthEffect: 8,
  },
  {
    name: &#39;Ancient Artifact&#39;,
    description: &#39;Mysterious relic from a lost desert civilization&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.LEGENDARY,
  },

  // Weird Items - Glitch
  {
    name: &#39;Fragmented Code&#39;,
    description: &#39;Broken data fragments that shimmer with digital energy&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.RARE,
  },
  {
    name: &#39;Pixel Dust&#39;,
    description: &#39;Granular reality particles from corrupted textures&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
  },
  {
    name: &#39;Buffer Overflow Potion&#39;,
    description:
      &#39;Dangerous digital brew that crashes your system... in a good way&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.EPIC,
    energyEffect: 150,
  },
  {
    name: &#39;Glitch Goggles&#39;,
    description: &#39;See through the matrix with corrupted vision&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    energyEffect: 10,
  },

  // Weird Items - Fungi
  {
    name: &#39;Neural Spores&#39;,
    description: &#39;Microscopic fungal networks that enhance thought&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.UNCOMMON,
  },
  {
    name: &#39;Symbiotic Armor&#39;,
    description: &#39;Living fungal protection that grows with you&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.EPIC,
    healthEffect: 25,
  },
  {
    name: &#39;Mycelium Thread&#39;,
    description: &#39;Natural fiber that connects all living things&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
  },

  // Weird Items - Temporal
  {
    name: &#39;Temporal Flux&#39;,
    description: &#39;Crystallized time that bends around your fingers&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.LEGENDARY,
  },
  {
    name: &#39;Paradox Engine&#39;,
    description: &#39;Mechanical device that exists in multiple timelines&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.LEGENDARY,
    durability: 999,
    energyEffect: 50,
  },
  {
    name: &#39;Causality Loop&#39;,
    description: &#39;Effect becomes cause becomes effect becomes...&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.EPIC,
  },

  // Weird Items - Bone
  {
    name: &#39;Living Bone Tools&#39;,
    description: &#39;Ossified implements that grow sharper with use&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 200,
  },
  {
    name: &#39;Calcium Crystals&#39;,
    description: &#39;Mineralized bone structure with geometric perfection&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.UNCOMMON,
  },
  {
    name: &#39;Skeletal Framework&#39;,
    description: &#39;Wearable bone structure that supports heavy lifting&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.RARE,
    healthEffect: 20,
  },

  // Weird Items - Static
  {
    name: &#39;White Noise Generator&#39;,
    description: &#39;Creates interference that masks your presence&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 100,
  },
  {
    name: &#39;Static Cling&#39;,
    description: &#39;Electromagnetic adhesive that sticks to anything&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
  },
  {
    name: &#39;Frequency Modulator&#39;,
    description: &#39;Tunes reality to different channels&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.EPIC,
    energyEffect: 15,
  },
  {
    name: &#39;Signal Booster Helmet&#39;,
    description: &#39;Amplifies brainwaves through electromagnetic fields&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.RARE,
    energyEffect: 20,
  },
]

// Character templates
const CHARACTER_TEMPLATES = [
  {
    name: &#39;Wojak #1337&#39;,
    gender: Gender.MALE,
    location: &#39;Mining Plains&#39;,
    energy: 85,
    health: 100,
  },
  {
    name: &#39;Wojak #420&#39;,
    gender: Gender.MALE,
    location: &#39;Mining Plains&#39;,
    energy: 95,
    health: 100,
  },
  {
    name: &#39;Wojak #69&#39;,
    gender: Gender.FEMALE,
    location: &#39;Rusty Pickaxe Inn&#39;,
    energy: 70,
    health: 100,
  },
  {
    name: &#39;Wojak #888&#39;,
    gender: Gender.MALE,
    location: &#39;Crystal Caves&#39;,
    energy: 45,
    health: 90,
  },
  {
    name: &#39;Wojak #2077&#39;,
    gender: Gender.FEMALE,
    location: &#39;Crystal Caves&#39;,
    energy: 60,
    health: 85,
  },
  {
    name: &#39;Wojak #100&#39;,
    gender: Gender.MALE,
    location: &#39;Central Exchange&#39;,
    energy: 80,
    health: 100,
  },
  {
    name: &#39;Wojak #777&#39;,
    gender: Gender.FEMALE,
    location: &#39;Central Exchange&#39;,
    energy: 90,
    health: 95,
  },
  {
    name: &#39;Wojak #333&#39;,
    gender: Gender.MALE,
    location: &#39;The Glitch Club&#39;,
    energy: 55,
    health: 80,
  },
  {
    name: &#39;Wojak #555&#39;,
    gender: Gender.FEMALE,
    location: &#39;Desert Outpost&#39;,
    energy: 40,
    health: 75,
  },
  {
    name: &#39;Wojak #999&#39;,
    gender: Gender.MALE,
    location: &#39;Desert Outpost&#39;,
    energy: 85,
    health: 100,
  },

  // New characters for weird regions
  {
    name: &#39;Wojak #404&#39;,
    gender: Gender.MALE,
    location: &#39;The Glitch Wastes&#39;,
    energy: 50,
    health: 95,
  },
  {
    name: &#39;Wojak #101&#39;,
    gender: Gender.FEMALE,
    location: &#39;Fungi Networks&#39;,
    energy: 75,
    health: 85,
  },
  {
    name: &#39;Wojak #2025&#39;,
    gender: Gender.MALE,
    location: &#39;Temporal Rift Zone&#39;,
    energy: 90,
    health: 80,
  },
  {
    name: &#39;Wojak #666&#39;,
    gender: Gender.FEMALE,
    location: &#39;The Bone Markets&#39;,
    energy: 65,
    health: 90,
  },
  {
    name: &#39;Wojak #000&#39;,
    gender: Gender.MALE,
    location: &#39;Static Fields&#39;,
    energy: 30,
    health: 100,
  },
]

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

function randomRange(min: number, max: number): number {
  return Math.floor(Math.random() * (max - min + 1)) + min
}

function randomChoice&lt;T&gt;(arr: T[]): T {
  return arr[Math.floor(Math.random() * arr.length)]
}

function generateUniqueNumber(): number {
  return Math.floor(Math.random() * 999999) + 1
}

function applyPriceMultiplier(basePrice: number, locationName: string): number {
  const multiplier = WORLD_CONFIG.PRICE_MULTIPLIERS[locationName] || 1.0
  return Math.round(basePrice * multiplier)
}

function calculateSpawnRate(baseRate: number, rarity: Rarity): number {
  const rarityMultiplier = WORLD_CONFIG.BASE_SPAWN_RATES[rarity] || 0.1
  return Math.min(baseRate * rarityMultiplier, 0.8) // Cap at 80%
}

// ============================================================================
// MAIN SETUP FUNCTIONS
// ============================================================================

async function clearExistingData() {
  if (!WORLD_CONFIG.FEATURES.CLEAR_EXISTING_DATA) {
    console.log(&#39;⏭️ Skipping data cleanup (disabled in config)&#39;)
    return
  }

  console.log(&#39;🧹 Clearing existing world data...&#39;)

  await prisma.chatMessage.deleteMany()
  await prisma.marketListing.deleteMany()
  await prisma.locationResource.deleteMany()
  await prisma.characterInventory.deleteMany()
  await prisma.characterImage.deleteMany()
  await prisma.transaction.deleteMany()
  await prisma.character.deleteMany()
  await prisma.location.deleteMany()
  await prisma.item.deleteMany()

  console.log(&#39;✅ Existing data cleared&#39;)
}

async function createLocations() {
  if (!WORLD_CONFIG.FEATURES.CREATE_LOCATIONS) {
    console.log(&#39;⏭️ Skipping location creation (disabled in config)&#39;)
    return new Map()
  }

  console.log(&#39;🗺️ Creating world locations...&#39;)

  const locationMap = new Map()

  for (const locationData of WORLD_LOCATIONS) {
    const { subLocations, ...parentData } = locationData

    // Create parent location
    const parentLocation = await prisma.location.create({
      data: {
        ...parentData,
        playerCount: 0,
        lastActive: new Date(Date.now() - Math.random() * 30 * 60 * 1000), // Random recent activity
      },
    })

    locationMap.set(parentLocation.name, parentLocation)
    console.log(`  🏔️ ${parentLocation.name}`)

    // Create sub-locations
    if (subLocations) {
      for (const subData of subLocations) {
        const subLocation = await prisma.location.create({
          data: {
            ...subData,
            parentLocationId: parentLocation.id,
            playerCount: 0,
            lastActive: new Date(Date.now() - Math.random() * 60 * 60 * 1000),
          },
        })

        locationMap.set(subLocation.name, subLocation)
        console.log(`    └─ ${subLocation.name}`)
      }
    }
  }

  console.log(`✅ Created ${locationMap.size} locations`)
  return locationMap
}

async function createItems() {
  if (!WORLD_CONFIG.FEATURES.CREATE_ITEMS) {
    console.log(&#39;⏭️ Skipping item creation (disabled in config)&#39;)
    return new Map()
  }

  console.log(&#39;📦 Creating world items...&#39;)

  const itemMap = new Map()

  for (const itemData of WORLD_ITEMS) {
    const item = await prisma.item.create({
      data: {
        ...itemData,
        imageUrl: `/items/${itemData.name
          .toLowerCase()
          .replace(/\s+/g, &#39;-&#39;)}.png`,
      },
    })

    itemMap.set(item.name, item)
    console.log(`  ✨ ${item.name} (${item.rarity})`)
  }

  console.log(`✅ Created ${itemMap.size} items`)
  return itemMap
}

async function createCharacters(locationMap: Map&lt;string, any&gt;) {
  if (!WORLD_CONFIG.FEATURES.CREATE_CHARACTERS) {
    console.log(&#39;⏭️ Skipping character creation (disabled in config)&#39;)
    return []
  }

  console.log(&#39;👥 Creating world characters...&#39;)

  const characters = []

  for (const template of CHARACTER_TEMPLATES) {
    const location = locationMap.get(template.location)
    if (!location) {
      console.log(
        `  ❌ Location &#39;${template.location}&#39; not found for ${template.name}`
      )
      continue
    }

    const character = await prisma.character.create({
      data: {
        id: `char_${template.name.toLowerCase().replace(/[^a-z0-9]/g, &#39;_&#39;)}`,
        nftAddress: `NFT_${generateUniqueNumber()}`,
        tokenId:
          template.name.split(&#39;#&#39;)[1] || generateUniqueNumber().toString(),
        walletAddress: `WALLET_${generateUniqueNumber()}`,
        name: template.name,
        gender: template.gender,
        characterType: CharacterType.HUMAN,
        currentLocationId: location.id,
        currentVersion: 1,
        currentImageUrl: `/wojak-${
          template.name.split(&#39;#&#39;)[1] || &#39;default&#39;
        }.png`,
        energy: template.energy,
        health: template.health,
      },
    })

    characters.push(character)
    console.log(`  👤 ${character.name} in ${template.location}`)
  }

  // Update location player counts
  const locationCounts = new Map()
  for (const char of characters) {
    const count = locationCounts.get(char.currentLocationId) || 0
    locationCounts.set(char.currentLocationId, count + 1)
  }

  for (const [locationId, count] of locationCounts) {
    await prisma.location.update({
      where: { id: locationId },
      data: { playerCount: count },
    })
  }

  console.log(`✅ Created ${characters.length} characters`)
  return characters
}

async function setupMarkets(
  locationMap: Map&lt;string, any&gt;,
  itemMap: Map&lt;string, any&gt;
) {
  if (!WORLD_CONFIG.FEATURES.SETUP_MARKETS) {
    console.log(&#39;⏭️ Skipping market setup (disabled in config)&#39;)
    return
  }

  console.log(&#39;🏪 Setting up markets...&#39;)

  // Market configurations with base prices
  const MARKET_CONFIGS: Record&lt;
    string,
    Array&lt;{ name: string; quantity: number; price: number }&gt;
  &gt; = {
    &#39;Mining Plains&#39;: [
      { name: &#39;Miners Hat&#39;, quantity: 8, price: 15 },
      { name: &#39;Basic Pickaxe&#39;, quantity: 5, price: 20 },
      { name: &#39;Multi-Tool&#39;, quantity: 3, price: 35 },
      { name: &#39;Energy Drink&#39;, quantity: 15, price: 8 },
      { name: &#39;Work Gloves&#39;, quantity: 6, price: 12 },
    ],

    &#39;Rusty Pickaxe Inn&#39;: [
      { name: &#39;Energy Drink&#39;, quantity: 20, price: 10 },
      { name: &#39;Health Potion&#39;, quantity: 15, price: 22 },
      { name: &#39;Basic Pickaxe&#39;, quantity: 8, price: 18 },
      { name: &#39;Lucky Charm&#39;, quantity: 4, price: 28 },
    ],

    &#39;Crystal Caves&#39;: [
      { name: &#39;Energy Drink&#39;, quantity: 12, price: 12 },
      { name: &#39;Health Potion&#39;, quantity: 8, price: 28 },
      { name: &#39;Crystal Shard&#39;, quantity: 8, price: 50 },
      { name: &#39;Omni-Tool&#39;, quantity: 1, price: 3500 },
    ],

    &#39;Central Exchange&#39;: [
      { name: &#39;Cyberpunk Shades&#39;, quantity: 3, price: 65 },
      { name: &#39;Neon Visor&#39;, quantity: 1, price: 150 },
      { name: &#39;Hacking Toolkit&#39;, quantity: 2, price: 120 },
      { name: &#39;Rare Floppy Disk&#39;, quantity: 1, price: 500 },
      { name: &#39;Cyber Jacket&#39;, quantity: 2, price: 85 },
    ],

    &#39;The Glitch Club&#39;: [
      { name: &#39;Cyberpunk Shades&#39;, quantity: 4, price: 55 },
      { name: &#39;Hacking Toolkit&#39;, quantity: 3, price: 100 },
      { name: &#39;Multi-Tool&#39;, quantity: 4, price: 30 },
    ],

    &#39;Desert Outpost&#39;: [
      { name: &#39;Desert Wrap&#39;, quantity: 4, price: 35 },
      { name: &#39;Energy Drink&#39;, quantity: 6, price: 15 },
      { name: &#39;Health Potion&#39;, quantity: 4, price: 35 },
      { name: &#39;Ancient Artifact&#39;, quantity: 1, price: 1000 },
    ],

    &#39;The Glitch Wastes&#39;: [
      { name: &#39;Glitch Goggles&#39;, quantity: 2, price: 120 },
      { name: &#39;Buffer Overflow Potion&#39;, quantity: 1, price: 200 },
      { name: &#39;Pixel Dust&#39;, quantity: 15, price: 8 },
      { name: &#39;Fragmented Code&#39;, quantity: 5, price: 45 },
    ],

    &#39;Fungi Networks&#39;: [
      { name: &#39;Symbiotic Armor&#39;, quantity: 1, price: 300 },
      { name: &#39;Neural Spores&#39;, quantity: 12, price: 25 },
      { name: &#39;Mycelium Thread&#39;, quantity: 20, price: 5 },
    ],

    &#39;Temporal Rift Zone&#39;: [
      { name: &#39;Paradox Engine&#39;, quantity: 1, price: 5000 },
      { name: &#39;Temporal Flux&#39;, quantity: 2, price: 1000 },
      { name: &#39;Causality Loop&#39;, quantity: 3, price: 400 },
    ],

    &#39;The Bone Markets&#39;: [
      { name: &#39;Living Bone Tools&#39;, quantity: 4, price: 160 },
      { name: &#39;Skeletal Framework&#39;, quantity: 2, price: 220 },
      { name: &#39;Calcium Crystals&#39;, quantity: 20, price: 15 },
    ],

    &#39;Static Fields&#39;: [
      { name: &#39;Signal Booster Helmet&#39;, quantity: 2, price: 180 },
      { name: &#39;White Noise Generator&#39;, quantity: 3, price: 130 },
      { name: &#39;Frequency Modulator&#39;, quantity: 2, price: 200 },
      { name: &#39;Static Cling&#39;, quantity: 25, price: 6 },
    ],
  }

  let totalListingsCreated = 0

  for (const [locationName, configs] of Object.entries(MARKET_CONFIGS)) {
    const location = locationMap.get(locationName)
    if (!location || !location.hasMarket) continue

    console.log(`  🛒 Stocking ${locationName}...`)

    for (const config of configs) {
      const item = itemMap.get(config.name)
      if (!item) {
        console.log(`    ❌ Item &#39;${config.name}&#39; not found`)
        continue
      }

      const adjustedPrice = applyPriceMultiplier(config.price, locationName)

      await prisma.marketListing.create({
        data: {
          locationId: location.id,
          itemId: item.id,
          quantity: config.quantity,
          price: adjustedPrice,
          isSystemItem: true,
        },
      })

      totalListingsCreated++
    }
  }

  console.log(`✅ Created ${totalListingsCreated} market listings`)
}

async function setupMining(
  locationMap: Map&lt;string, any&gt;,
  itemMap: Map&lt;string, any&gt;
) {
  if (!WORLD_CONFIG.FEATURES.SETUP_MINING) {
    console.log(&#39;⏭️ Skipping mining setup (disabled in config)&#39;)
    return
  }

  console.log(&#39;⛏️ Setting up mining resources...&#39;)

  // Mining configurations
  const MINING_CONFIGS: Record&lt;
    string,
    Array&lt;{
      name: string
      spawnRate: number
      maxPerDay: number
      difficulty: number
    }&gt;
  &gt; = {
    &#39;Mining Plains&#39;: [
      { name: &#39;Dirty Coal&#39;, spawnRate: 0.5, maxPerDay: 25, difficulty: 1 },
      { name: &#39;Iron Scraps&#39;, spawnRate: 0.35, maxPerDay: 15, difficulty: 1 },
      { name: &#39;Basic Pickaxe&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 1 },
    ],

    &#39;Crystal Caves&#39;: [
      { name: &#39;Crystal Shard&#39;, spawnRate: 0.15, maxPerDay: 5, difficulty: 3 },
      { name: &#39;Ancient Coin&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 2 },
      { name: &#39;Omni-Tool&#39;, spawnRate: 0.002, maxPerDay: 1, difficulty: 5 },
    ],

    &#39;Desert Outpost&#39;: [
      { name: &#39;Ancient Coin&#39;, spawnRate: 0.18, maxPerDay: 8, difficulty: 3 },
      { name: &#39;Crystal Shard&#39;, spawnRate: 0.06, maxPerDay: 2, difficulty: 4 },
      {
        name: &#39;Ancient Artifact&#39;,
        spawnRate: 0.01,
        maxPerDay: 1,
        difficulty: 5,
      },
    ],

    &#39;The Glitch Wastes&#39;: [
      { name: &#39;Pixel Dust&#39;, spawnRate: 0.4, maxPerDay: 20, difficulty: 4 },
      { name: &#39;Fragmented Code&#39;, spawnRate: 0.12, maxPerDay: 6, difficulty: 5 },
      { name: &#39;Glitch Goggles&#39;, spawnRate: 0.02, maxPerDay: 1, difficulty: 6 },
    ],

    &#39;Corrupted Data Mines&#39;: [
      { name: &#39;Fragmented Code&#39;, spawnRate: 0.3, maxPerDay: 10, difficulty: 5 },
      {
        name: &#39;Buffer Overflow Potion&#39;,
        spawnRate: 0.008,
        maxPerDay: 1,
        difficulty: 7,
      },
    ],

    &#39;Fungi Networks&#39;: [
      { name: &#39;Mycelium Thread&#39;, spawnRate: 0.5, maxPerDay: 30, difficulty: 3 },
      { name: &#39;Neural Spores&#39;, spawnRate: 0.25, maxPerDay: 15, difficulty: 3 },
    ],

    &#39;The Great Mycelium&#39;: [
      { name: &#39;Neural Spores&#39;, spawnRate: 0.4, maxPerDay: 20, difficulty: 4 },
      {
        name: &#39;Symbiotic Armor&#39;,
        spawnRate: 0.015,
        maxPerDay: 1,
        difficulty: 5,
      },
    ],

    &#39;Temporal Rift Zone&#39;: [
      { name: &#39;Temporal Flux&#39;, spawnRate: 0.05, maxPerDay: 2, difficulty: 6 },
      { name: &#39;Causality Loop&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 5 },
    ],

    &#39;Clock Tower Ruins&#39;: [
      { name: &#39;Temporal Flux&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 6 },
      { name: &#39;Paradox Engine&#39;, spawnRate: 0.001, maxPerDay: 1, difficulty: 8 },
    ],

    &#39;The Bone Markets&#39;: [
      {
        name: &#39;Calcium Crystals&#39;,
        spawnRate: 0.35,
        maxPerDay: 18,
        difficulty: 3,
      },
      {
        name: &#39;Living Bone Tools&#39;,
        spawnRate: 0.06,
        maxPerDay: 3,
        difficulty: 4,
      },
    ],

    &#39;Static Fields&#39;: [
      { name: &#39;Static Cling&#39;, spawnRate: 0.45, maxPerDay: 22, difficulty: 4 },
      {
        name: &#39;White Noise Generator&#39;,
        spawnRate: 0.07,
        maxPerDay: 3,
        difficulty: 5,
      },
    ],

    &#39;Channel 0&#39;: [
      { name: &#39;Static Cling&#39;, spawnRate: 0.6, maxPerDay: 30, difficulty: 4 },
      {
        name: &#39;Signal Booster Helmet&#39;,
        spawnRate: 0.02,
        maxPerDay: 1,
        difficulty: 6,
      },
    ],
  }

  let totalResourcesCreated = 0

  for (const [locationName, configs] of Object.entries(MINING_CONFIGS)) {
    const location = locationMap.get(locationName)
    if (!location || !location.hasMining) continue

    console.log(`  ⚒️ Adding resources to ${locationName}...`)

    for (const config of configs) {
      const item = itemMap.get(config.name)
      if (!item) {
        console.log(`    ❌ Item &#39;${config.name}&#39; not found`)
        continue
      }

      await prisma.locationResource.create({
        data: {
          locationId: location.id,
          itemId: item.id,
          spawnRate: config.spawnRate,
          maxPerDay: config.maxPerDay,
          difficulty: config.difficulty,
        },
      })

      totalResourcesCreated++
    }
  }

  console.log(`✅ Created ${totalResourcesCreated} mining resources`)
}

async function createChatHistory(
  locationMap: Map&lt;string, any&gt;,
  characters: any[]
) {
  if (!WORLD_CONFIG.FEATURES.CREATE_CHAT_HISTORY) {
    console.log(&#39;⏭️ Skipping chat history creation (disabled in config)&#39;)
    return
  }

  console.log(&#39;💬 Creating chat history...&#39;)

  // Sample chat messages
  const CHAT_TEMPLATES = [
    {
      location: &#39;Mining Plains&#39;,
      character: &#39;Wojak #420&#39;,
      message: &#39;Anyone know where the best iron deposits are?&#39;,
      timeAgo: 3,
    },
    {
      location: &#39;Mining Plains&#39;,
      character: &#39;Wojak #1337&#39;,
      message: &#39;Try the eastern slopes, found some good scraps there yesterday&#39;,
      timeAgo: 2,
    },
    {
      location: &#39;Crystal Caves&#39;,
      character: &#39;Wojak #888&#39;,
      message: &#39;Whoa! Just found a crystal shard in the deep tunnel!&#39;,
      timeAgo: 5,
    },
    {
      location: &#39;Crystal Caves&#39;,
      character: &#39;Wojak #2077&#39;,
      message: &#39;Nice! What rarity?&#39;,
      timeAgo: 4,
    },
    {
      location: &#39;The Glitch Club&#39;,
      character: &#39;Wojak #333&#39;,
      message: &#39;*nods to the beat* This track is fire 🔥&#39;,
      timeAgo: 20,
      type: &#39;EMOTE&#39;,
    },
    {
      location: &#39;Desert Outpost&#39;,
      character: &#39;Wojak #555&#39;,
      message: &#39;Water supplies running low... need to find the oasis&#39;,
      timeAgo: 25,
    },
    {
      location: &#39;The Glitch Wastes&#39;,
      character: &#39;Wojak #404&#39;,
      message: &#39;Reality.exe has stopped working&#39;,
      timeAgo: 15,
    },
    {
      location: &#39;Fungi Networks&#39;,
      character: &#39;Wojak #101&#39;,
      message: &#39;The network speaks to me... it wants to help&#39;,
      timeAgo: 10,
    },
    {
      location: &#39;Temporal Rift Zone&#39;,
      character: &#39;Wojak #2025&#39;,
      message: &#39;I was here tomorrow, but now I am yesterday&#39;,
      timeAgo: -5,
    }, // Time is weird
    {
      location: &#39;The Bone Markets&#39;,
      character: &#39;Wojak #666&#39;,
      message: &#39;Fresh calcium! Get your fresh calcium here!&#39;,
      timeAgo: 8,
    },
    {
      location: &#39;Static Fields&#39;,
      character: &#39;Wojak #000&#39;,
      message: &#39;██████ ████ █████ ████ fine&#39;,
      timeAgo: 12,
    },
  ]

  let messagesCreated = 0

  for (const template of CHAT_TEMPLATES) {
    const location = locationMap.get(template.location)
    const character = characters.find((c) =&gt; c.name === template.character)

    if (!location || !character) continue

    await prisma.chatMessage.create({
      data: {
        locationId: location.id,
        characterId: character.id,
        message: template.message,
        messageType: (template.type as ChatMessageType) || ChatMessageType.CHAT,
        isSystem: false,
        createdAt: new Date(Date.now() - template.timeAgo * 60 * 1000),
      },
    })

    messagesCreated++
  }

  console.log(`✅ Created ${messagesCreated} chat messages`)
}

async function validateSetup() {
  console.log(&#39;🔍 Validating world setup...&#39;)

  const stats = {
    locations: await prisma.location.count(),
    items: await prisma.item.count(),
    characters: await prisma.character.count(),
    marketListings: await prisma.marketListing.count({
      where: { isSystemItem: true },
    }),
    miningResources: await prisma.locationResource.count(),
    chatMessages: await prisma.chatMessage.count(),
  }

  console.log(&#39;\n📊 WORLD STATISTICS&#39;)
  console.log(&#39;=&#39;.repeat(50))
  console.log(`🗺️ Locations: ${stats.locations}`)
  console.log(`📦 Items: ${stats.items}`)
  console.log(`👥 Characters: ${stats.characters}`)
  console.log(`🏪 Market Listings: ${stats.marketListings}`)
  console.log(`⛏️ Mining Resources: ${stats.miningResources}`)
  console.log(`💬 Chat Messages: ${stats.chatMessages}`)

  // Validation checks
  const issues = []

  // Check for locations without markets or mining
  const emptyMarkets = await prisma.location.count({
    where: {
      hasMarket: true,
      marketListings: { none: {} },
    },
  })
  if (emptyMarkets &gt; 0)
    issues.push(`${emptyMarkets} market locations have no items`)

  const emptyMining = await prisma.location.count({
    where: {
      hasMining: true,
      resources: { none: {} },
    },
  })
  if (emptyMining &gt; 0)
    issues.push(`${emptyMining} mining locations have no resources`)

  // Check for characters without locations
  const orphanedCharacters = await prisma.character.count({
    where: { currentLocation: null },
  })
  if (orphanedCharacters &gt; 0)
    issues.push(`${orphanedCharacters} characters have no location`)

  if (issues.length &gt; 0) {
    console.log(&#39;\n⚠️ VALIDATION ISSUES:&#39;)
    issues.forEach((issue) =&gt; console.log(`  • ${issue}`))
  } else {
    console.log(&#39;\n✅ All validation checks passed!&#39;)
  }

  return stats
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

async function setupUltimateWorld() {
  console.log(`🌍 ${WORLD_CONFIG.WORLD_NAME} - Ultimate World Setup`)
  console.log(&#39;=&#39;.repeat(60))
  console.log(
    `⚙️ Configuration loaded - ${
      Object.values(WORLD_CONFIG.FEATURES).filter(Boolean).length
    }/${Object.keys(WORLD_CONFIG.FEATURES).length} features enabled`
  )
  console.log(&#39;&#39;)

  try {
    // Execute setup phases
    await clearExistingData()
    const locationMap = await createLocations()
    const itemMap = await createItems()
    const characters = await createCharacters(locationMap)
    await setupMarkets(locationMap, itemMap)
    await setupMining(locationMap, itemMap)
    await createChatHistory(locationMap, characters)

    // Final validation and reporting
    const stats = await validateSetup()

    console.log(&#39;\n🎉 ULTIMATE WORLD SETUP COMPLETE!&#39;)
    console.log(&#39;=&#39;.repeat(50))
    console.log(&#39;🚀 Your world is ready for players!&#39;)
    console.log(&#39;&#39;)
    console.log(&#39;🎯 Key Features:&#39;)
    console.log(&#39;  • 12 unique locations across 8 regions&#39;)
    console.log(&#39;  • 30+ items spanning all categories and rarities&#39;)
    console.log(&#39;  • 15+ characters distributed across the world&#39;)
    console.log(&#39;  • Dynamic markets with location-based pricing&#39;)
    console.log(&#39;  • Resource-rich mining system&#39;)
    console.log(&#39;  • Living chat history and social features&#39;)
    console.log(&#39;&#39;)
    console.log(&#39;📖 Next Steps:&#39;)
    console.log(&#39;  1. Run `npm run dev` to start your game&#39;)
    console.log(&#39;  2. Test wallet connection and character selection&#39;)
    console.log(&#39;  3. Explore all the weird new regions!&#39;)
    console.log(&#39;  4. Consider adding NFT minting functionality&#39;)
  } catch (error) {
    console.error(&#39;❌ Ultimate world setup failed:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

// Run the ultimate setup
setupUltimateWorld()
</content>
    </document>

    <document>
      <source>scripts/add-themed-items.ts</source>
      <tags></tags>
      <metadata>
        <size>7176</size>
        <lastModified>2025-05-29T05:47:45.577Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/add-themed-items.ts - New items for different locations
import { PrismaClient, ItemCategory, LayerType, Rarity } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

const NEW_ITEMS = [
  // === CYBER CITY / GLITCH CLUB HACKER ITEMS ===
  {
    name: &#39;Rare Floppy Disk&#39;,
    description: &#39;Contains legendary source code from the early net&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.LEGENDARY,
    imageUrl: &#39;/items/rare-floppy-disk.png&#39;,
  },
  {
    name: &#39;Cyberpunk Shades&#39;,
    description: &#39;AR-enhanced sunglasses with data overlay&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    energyEffect: 10,
    imageUrl: &#39;/items/cyberpunk-shades.png&#39;,
  },
  {
    name: &#39;Neon Visor&#39;,
    description: &#39;Glowing headgear that screams &quot;I hack the planet&quot;&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.EPIC,
    energyEffect: 15,
    imageUrl: &#39;/items/neon-visor.png&#39;,
  },
  {
    name: &#39;Data Spike&#39;,
    description: &#39;Neural interface tool for direct data access&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    imageUrl: &#39;/items/data-spike.png&#39;,
  },
  {
    name: &#39;Code Energy Drink&#39;,
    description: &#39;Caffeinated fuel for all-night coding sessions&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.COMMON,
    energyEffect: 35,
    imageUrl: &#39;/items/code-energy-drink.png&#39;,
  },
  {
    name: &#39;Bitcoin Fragment&#39;,
    description: &#39;Corrupted cryptocurrency data from the old web&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.EPIC,
    imageUrl: &#39;/items/bitcoin-fragment.png&#39;,
  },

  // === MINING PLAINS INDUSTRIAL ITEMS ===
  {
    name: &#39;Heavy Duty Boots&#39;,
    description: &#39;Steel-toed boots for serious mining work&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.UNCOMMON,
    healthEffect: 10,
    imageUrl: &#39;/items/heavy-duty-boots.png&#39;,
  },
  {
    name: &#39;Reinforced Pickaxe&#39;,
    description: &#39;Professional mining tool with titanium edge&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 200,
    imageUrl: &#39;/items/reinforced-pickaxe.png&#39;,
  },
  {
    name: &#39;Safety Goggles&#39;,
    description: &#39;Protects eyes from flying debris and dust&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    healthEffect: 5,
    imageUrl: &#39;/items/safety-goggles.png&#39;,
  },
  {
    name: &#39;Protein Bar&#39;,
    description: &#39;High-energy snack for hardworking miners&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.COMMON,
    energyEffect: 15,
    healthEffect: 5,
    imageUrl: &#39;/items/protein-bar.png&#39;,
  },
  {
    name: &#39;Rare Earth Metal&#39;,
    description: &#39;Valuable minerals used in advanced technology&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.RARE,
    imageUrl: &#39;/items/rare-earth-metal.png&#39;,
  },

  // === DESERT OUTPOST SURVIVAL ITEMS ===
  {
    name: &#39;Desert Wrap&#39;,
    description: &#39;Traditional headwrap that protects from sandstorms&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.UNCOMMON,
    healthEffect: 8,
    imageUrl: &#39;/items/desert-wrap.png&#39;,
  },
  {
    name: &#39;Survival Cloak&#39;,
    description: &#39;Weather-resistant cloak for harsh desert conditions&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.RARE,
    healthEffect: 15,
    energyEffect: 5,
    imageUrl: &#39;/items/survival-cloak.png&#39;,
  },
  {
    name: &#39;Water Purifier&#39;,
    description: &#39;Portable device that makes any water safe to drink&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.UNCOMMON,
    imageUrl: &#39;/items/water-purifier.png&#39;,
  },
  {
    name: &#39;Cactus Juice&#39;,
    description: &#39;Refreshing desert drink with healing properties&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.UNCOMMON,
    healthEffect: 25,
    energyEffect: 10,
    imageUrl: &#39;/items/cactus-juice.png&#39;,
  },
  {
    name: &#39;Ancient Artifact&#39;,
    description: &#39;Mysterious relic from a lost desert civilization&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.LEGENDARY,
    imageUrl: &#39;/items/ancient-artifact.png&#39;,
  },

  // === UNIVERSAL RARE ITEMS ===
  {
    name: &#39;Golden Pickaxe&#39;,
    description: &#39;Legendary mining tool said to find impossible treasures&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.LEGENDARY,
    durability: 500,
    imageUrl: &#39;/items/golden-pickaxe.png&#39;,
  },
  {
    name: &#39;Wojak Mask&#39;,
    description: &#39;Iconic meme face mask - the ultimate flex&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.FACE_COVERING,
    rarity: Rarity.EPIC,
    imageUrl: &#39;/items/wojak-mask.png&#39;,
  },
  {
    name: &#39;Rainbow Hoodie&#39;,
    description: &#39;Psychedelic hoodie that shifts colors in the light&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.EPIC,
    energyEffect: 20,
    imageUrl: &#39;/items/rainbow-hoodie.png&#39;,
  },
  {
    name: &#39;Pepe Charm&#39;,
    description: &#39;Rare companion charm - brings good luck in mining&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    imageUrl: &#39;/items/pepe-charm.png&#39;,
  },
  {
    name: &#39;Super Energy Potion&#39;,
    description: &#39;Ultimate energy restoration - fully charged!&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.EPIC,
    energyEffect: 100, // Full restore
    imageUrl: &#39;/items/super-energy-potion.png&#39;,
  },
]

async function addThemedItems() {
  console.log(&#39;🎮 Adding themed items to Wojak Earth...&#39;)

  try {
    for (const itemData of NEW_ITEMS) {
      // Check if item already exists
      const existingItem = await prisma.item.findUnique({
        where: { name: itemData.name },
      })

      if (existingItem) {
        console.log(`  ⚠️  Item &#39;${itemData.name}&#39; already exists, skipping...`)
        continue
      }

      // Create new item
      await prisma.item.create({
        data: itemData,
      })

      console.log(`  ✨ Added ${itemData.name} (${itemData.rarity})`)
    }

    console.log(&#39;\n🎉 Themed items added successfully!&#39;)

    // Show summary by category
    const itemsByCategory = NEW_ITEMS.reduce((acc, item) =&gt; {
      acc[item.category] = (acc[item.category] || 0) + 1
      return acc
    }, {} as Record&lt;string, number&gt;)

    console.log(&#39;\n📊 Items Added by Category:&#39;)
    Object.entries(itemsByCategory).forEach(([category, count]) =&gt; {
      console.log(`  ${category}: ${count} items`)
    })

    // Show summary by rarity
    const itemsByRarity = NEW_ITEMS.reduce((acc, item) =&gt; {
      acc[item.rarity] = (acc[item.rarity] || 0) + 1
      return acc
    }, {} as Record&lt;string, number&gt;)

    console.log(&#39;\n🌟 Items Added by Rarity:&#39;)
    Object.entries(itemsByRarity).forEach(([rarity, count]) =&gt; {
      console.log(`  ${rarity}: ${count} items`)
    })
  } catch (error) {
    console.error(&#39;❌ Failed to add themed items:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

addThemedItems()
</content>
    </document>

    <document>
      <source>scripts/add-new-regions.ts</source>
      <tags></tags>
      <metadata>
        <size>14509</size>
        <lastModified>2025-05-29T08:48:57.681Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/add-new-regions.ts - Add 5 weird new locations
import {
  PrismaClient,
  ItemCategory,
  LayerType,
  Rarity,
  LocationType,
} from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// New Items for the weird regions
const NEW_ITEMS = [
  // === GLITCH WASTES ITEMS ===
  {
    name: &#39;Fragmented Code&#39;,
    description: &#39;Broken data fragments that shimmer with digital energy&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.RARE,
    imageUrl: &#39;/items/fragmented-code.png&#39;,
  },
  {
    name: &#39;Pixel Dust&#39;,
    description: &#39;Granular reality particles from corrupted textures&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
    imageUrl: &#39;/items/pixel-dust.png&#39;,
  },
  {
    name: &#39;Buffer Overflow Potion&#39;,
    description:
      &#39;Dangerous digital brew that crashes your system... in a good way&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.EPIC,
    energyEffect: 150, // Overpowered but risky
    imageUrl: &#39;/items/buffer-overflow-potion.png&#39;,
  },
  {
    name: &#39;Glitch Goggles&#39;,
    description: &#39;See through the matrix with corrupted vision&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    energyEffect: 10,
    imageUrl: &#39;/items/glitch-goggles.png&#39;,
  },

  // === FUNGI NETWORKS ITEMS ===
  {
    name: &#39;Neural Spores&#39;,
    description: &#39;Microscopic fungal networks that enhance thought&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.UNCOMMON,
    imageUrl: &#39;/items/neural-spores.png&#39;,
  },
  {
    name: &#39;Decay Catalyst&#39;,
    description: &#39;Accelerates decomposition for rapid resource cycling&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 75,
    imageUrl: &#39;/items/decay-catalyst.png&#39;,
  },
  {
    name: &#39;Symbiotic Armor&#39;,
    description: &#39;Living fungal protection that grows with you&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.EPIC,
    healthEffect: 25,
    imageUrl: &#39;/items/symbiotic-armor.png&#39;,
  },
  {
    name: &#39;Mycelium Thread&#39;,
    description: &#39;Natural fiber that connects all living things&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
    imageUrl: &#39;/items/mycelium-thread.png&#39;,
  },

  // === TEMPORAL RIFT ZONE ITEMS ===
  {
    name: &#39;Temporal Flux&#39;,
    description: &#39;Crystallized time that bends around your fingers&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.LEGENDARY,
    imageUrl: &#39;/items/temporal-flux.png&#39;,
  },
  {
    name: &#39;Paradox Engine&#39;,
    description: &#39;Mechanical device that exists in multiple timelines&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.LEGENDARY,
    durability: 999,
    energyEffect: 50,
    imageUrl: &#39;/items/paradox-engine.png&#39;,
  },
  {
    name: &#39;Causality Loop&#39;,
    description: &#39;Effect becomes cause becomes effect becomes...&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.EPIC,
    imageUrl: &#39;/items/causality-loop.png&#39;,
  },
  {
    name: &#39;Temporal Stabilizer&#39;,
    description: &#39;Keeps you anchored to the present moment&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.RARE,
    healthEffect: 50,
    imageUrl: &#39;/items/temporal-stabilizer.png&#39;,
  },

  // === BONE MARKETS ITEMS ===
  {
    name: &#39;Living Bone Tools&#39;,
    description: &#39;Ossified implements that grow sharper with use&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 200,
    imageUrl: &#39;/items/living-bone-tools.png&#39;,
  },
  {
    name: &#39;Calcium Crystals&#39;,
    description: &#39;Mineralized bone structure with geometric perfection&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.UNCOMMON,
    imageUrl: &#39;/items/calcium-crystals.png&#39;,
  },
  {
    name: &#39;Skeletal Framework&#39;,
    description: &#39;Wearable bone structure that supports heavy lifting&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.RARE,
    healthEffect: 20,
    imageUrl: &#39;/items/skeletal-framework.png&#39;,
  },
  {
    name: &#39;Bone Marrow Elixir&#39;,
    description: &#39;Rich, life-giving essence extracted from ancient bones&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.UNCOMMON,
    healthEffect: 40,
    energyEffect: 10,
    imageUrl: &#39;/items/bone-marrow-elixir.png&#39;,
  },

  // === STATIC FIELDS ITEMS ===
  {
    name: &#39;White Noise Generator&#39;,
    description: &#39;Creates interference that masks your presence&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 100,
    imageUrl: &#39;/items/white-noise-generator.png&#39;,
  },
  {
    name: &#39;Static Cling&#39;,
    description: &#39;Electromagnetic adhesive that sticks to anything&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
    imageUrl: &#39;/items/static-cling.png&#39;,
  },
  {
    name: &#39;Frequency Modulator&#39;,
    description: &#39;Tunes reality to different channels&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.EPIC,
    energyEffect: 15,
    imageUrl: &#39;/items/frequency-modulator.png&#39;,
  },
  {
    name: &#39;Signal Booster Helmet&#39;,
    description: &#39;Amplifies brainwaves through electromagnetic fields&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.RARE,
    energyEffect: 20,
    imageUrl: &#39;/items/signal-booster-helmet.png&#39;,
  },
]

// New Locations
const NEW_LOCATIONS = [
  // === THE GLITCH WASTES ===
  {
    name: &#39;The Glitch Wastes&#39;,
    description:
      &#39;Digital desert where reality breaks down into pixelated fragments&#39;,
    locationType: LocationType.REGION,
    biome: &#39;digital&#39;,
    difficulty: 4,
    playerCount: 0,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: &#39;REGIONAL&#39;,
    welcomeMessage: &#39;ERROR_404: WELCOME_MESSAGE_NOT_FOUND&#39;,
    lore: &#39;Once a stable data center, this region was corrupted by a massive system failure that left reality itself glitched.&#39;,
    mapX: 600,
    mapY: 150,
    subLocations: [
      {
        name: &#39;Error 404 Oasis&#39;,
        description: &#39;A rest stop that may or may not actually exist&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 4,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;null reference exception: comfort not found&#39;,
      },
      {
        name: &#39;Corrupted Data Mines&#39;,
        description: &#39;Extract valuable code fragments from broken databases&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 5,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;Warning: Memory corruption detected&#39;,
      },
    ],
  },

  // === FUNGI NETWORKS ===
  {
    name: &#39;Fungi Networks&#39;,
    description: &#39;Underground mycelium city where everything is connected&#39;,
    locationType: LocationType.REGION,
    biome: &#39;underground&#39;,
    difficulty: 3,
    playerCount: 0,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: &#39;REGIONAL&#39;,
    welcomeMessage: &#39;The network acknowledges your presence.&#39;,
    lore: &#39;A vast underground organism that has achieved collective consciousness, welcoming symbiotic relationships with surface dwellers.&#39;,
    mapX: 200,
    mapY: 400,
    subLocations: [
      {
        name: &#39;Spore Exchange&#39;,
        description: &#39;Trading post where biological resources are shared&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 3,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Breathe deeply. The spores will show you the way.&#39;,
      },
      {
        name: &#39;The Great Mycelium&#39;,
        description: &#39;Central nervous system of the fungal network&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 4,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;You are now part of something greater.&#39;,
      },
    ],
  },

  // === TEMPORAL RIFT ZONE ===
  {
    name: &#39;Temporal Rift Zone&#39;,
    description: &#39;Time moves strangely here, past and future bleeding together&#39;,
    locationType: LocationType.REGION,
    biome: &#39;temporal&#39;,
    difficulty: 5,
    playerCount: 0,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: &#39;REGIONAL&#39;,
    welcomeMessage: &#39;When are you?&#39;,
    lore: &#39;A scientific experiment gone wrong tore holes in spacetime, creating a region where causality itself is unstable.&#39;,
    mapX: 500,
    mapY: 350,
    subLocations: [
      {
        name: &quot;Yesterday&#39;s Tomorrow&quot;,
        description:
          &#39;A marketplace selling items from timelines that never were&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 5,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;This conversation happened before you arrived.&#39;,
      },
      {
        name: &#39;Clock Tower Ruins&#39;,
        description:
          &#39;Collapsed timekeeper where temporal fragments can be mined&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 6,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;Time is broken here. Proceed with caution.&#39;,
      },
    ],
  },

  // === THE BONE MARKETS ===
  {
    name: &#39;The Bone Markets&#39;,
    description:
      &#39;Skeletal merchants trade in organic technology and calcium currency&#39;,
    locationType: LocationType.REGION,
    biome: &#39;ossuary&#39;,
    difficulty: 3,
    playerCount: 0,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: &#39;REGIONAL&#39;,
    welcomeMessage: &#39;Welcome, flesh-bearer. What bones do you bring?&#39;,
    lore: &#39;An ancient cemetery evolved into a thriving market where death is just another resource to be traded.&#39;,
    mapX: 150,
    mapY: 300,
    subLocations: [
      {
        name: &#39;Calcium Exchange&#39;,
        description: &#39;Primary trading floor for bone-based materials&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 3,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Rattle your coins, the dealers are listening.&#39;,
      },
      {
        name: &#39;Ossuary Club&#39;,
        description:
          &#39;Social gathering place decorated with artistic bone arrangements&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 2,
        hasMarket: false,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Dance among the ancestors.&#39;,
      },
    ],
  },

  // === STATIC FIELDS ===
  {
    name: &#39;Static Fields&#39;,
    description:
      &#39;Everything covered in TV static, reality unclear and shifting&#39;,
    locationType: LocationType.REGION,
    biome: &#39;electromagnetic&#39;,
    difficulty: 4,
    playerCount: 0,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: &#39;REGIONAL&#39;,
    welcomeMessage: &#39;████████ ██ ████ ███ ████&#39;,
    lore: &#39;A massive electromagnetic anomaly interferes with all signals, creating a region where reality itself seems to be broadcasting on dead channels.&#39;,
    mapX: 450,
    mapY: 250,
    subLocations: [
      {
        name: &#39;Channel 0&#39;,
        description:
          &#39;Broadcasting station for frequencies that should not exist&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 4,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;█ow ██ █ing?&#39;,
      },
      {
        name: &#39;Dead Air Tavern&#39;,
        description:
          &#39;Social hub where the static is slightly less overwhelming&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 3,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Can you hear me now? Good.&#39;,
      },
    ],
  },
]

async function addNewRegions() {
  console.log(&#39;🌍 Adding 5 new weird regions to Wojak Earth...\n&#39;)

  try {
    // 1. Add all new items
    console.log(&#39;📦 Adding themed items...&#39;)
    let itemsAdded = 0

    for (const itemData of NEW_ITEMS) {
      const existing = await prisma.item.findUnique({
        where: { name: itemData.name },
      })

      if (!existing) {
        await prisma.item.create({ data: itemData })
        console.log(`  ✨ Added ${itemData.name} (${itemData.rarity})`)
        itemsAdded++
      }
    }
    console.log(`✅ Added ${itemsAdded} new items\n`)

    // 2. Add locations and sub-locations
    console.log(&#39;🗺️ Adding locations...&#39;)
    let locationsAdded = 0

    for (const locationData of NEW_LOCATIONS) {
      const { subLocations, ...parentData } = locationData

      // Create parent location
      const parentLocation = await prisma.location.create({
        data: parentData,
      })
      console.log(`  🏔️ Added ${parentLocation.name}`)
      locationsAdded++

      // Create sub-locations
      if (subLocations) {
        for (const subData of subLocations) {
          const subLocation = await prisma.location.create({
            data: {
              ...subData,
              parentLocationId: parentLocation.id,
            },
          })
          console.log(`    └─ ${subLocation.name}`)
          locationsAdded++
        }
      }
    }
    console.log(`✅ Added ${locationsAdded} new locations\n`)

    console.log(&#39;🎉 NEW REGIONS ADDED SUCCESSFULLY!&#39;)
    console.log(&#39;=&#39;.repeat(50))
    console.log(&#39;New regions available:&#39;)
    console.log(&#39;• The Glitch Wastes - Digital chaos and corrupted reality&#39;)
    console.log(&#39;• Fungi Networks - Underground mycelium civilization&#39;)
    console.log(&#39;• Temporal Rift Zone - Time anomalies and paradoxes&#39;)
    console.log(&#39;• The Bone Markets - Skeletal merchants and calcium economy&#39;)
    console.log(&#39;• Static Fields - Electromagnetic interference zone&#39;)

    console.log(&#39;\n🎯 Next steps:&#39;)
    console.log(&#39;1. Run market seeding to stock these locations&#39;)
    console.log(&#39;2. Add mining resources for these regions&#39;)
    console.log(&#39;3. Test travel to the new locations&#39;)
    console.log(&#39;4. Update your map view to show the new regions&#39;)

    // Show total game content
    const totalItems = await prisma.item.count()
    const totalLocations = await prisma.location.count()
    console.log(
      `\n📊 Game now has ${totalItems} items and ${totalLocations} locations!`
    )
  } catch (error) {
    console.error(&#39;❌ Failed to add new regions:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

addNewRegions()
</content>
    </document>

    <document>
      <source>scripts/seed-enhanced-markets.ts</source>
      <tags></tags>
      <metadata>
        <size>14122</size>
        <lastModified>2025-05-29T06:25:23.751Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/seed-enhanced-markets.ts - Complete version with ALL locations
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// Enhanced market configurations with new themed items - ALL LOCATIONS COVERED
const ENHANCED_MARKET_CONFIGS = {
  &#39;Mining Plains&#39;: {
    items: [
      // Basic mining gear (cheap and common)
      { name: &#39;Miners Hat&#39;, quantity: 8, price: 15 },
      { name: &#39;Work Gloves&#39;, quantity: 6, price: 12 },
      { name: &#39;Safety Goggles&#39;, quantity: 5, price: 8 },
      { name: &#39;Heavy Duty Boots&#39;, quantity: 3, price: 25 },

      // Consumables
      { name: &#39;Energy Drink&#39;, quantity: 15, price: 8 },
      { name: &#39;Protein Bar&#39;, quantity: 12, price: 6 },

      // Materials (system buys these from players too)
      { name: &#39;Dirty Coal&#39;, quantity: 30, price: 2 },
      { name: &#39;Iron Scraps&#39;, quantity: 20, price: 4 },
      { name: &#39;Rare Earth Metal&#39;, quantity: 5, price: 15 },

      // Rare equipment occasionally available
      { name: &#39;Reinforced Pickaxe&#39;, quantity: 1, price: 120 },

      { name: &#39;Basic Pickaxe&#39;, quantity: 5, price: 20 },
      { name: &#39;Multi-Tool&#39;, quantity: 3, price: 35 },
      { name: &#39;Repair Kit&#39;, quantity: 4, price: 25 },
    ],
  },

  &#39;Central Exchange&#39;: {
    items: [
      // High-tech gear
      { name: &#39;Cyber Jacket&#39;, quantity: 2, price: 85 },
      { name: &#39;Cyberpunk Shades&#39;, quantity: 3, price: 65 },
      { name: &#39;Neon Visor&#39;, quantity: 1, price: 150 },
      { name: &#39;Data Spike&#39;, quantity: 2, price: 95 },

      // Premium consumables
      { name: &#39;Health Potion&#39;, quantity: 10, price: 25 },
      { name: &#39;Code Energy Drink&#39;, quantity: 8, price: 18 },
      { name: &#39;Super Energy Potion&#39;, quantity: 2, price: 180 }, // Epic consumable

      // Digital materials
      { name: &#39;Bitcoin Fragment&#39;, quantity: 4, price: 45 },
      { name: &#39;Ancient Coin&#39;, quantity: 6, price: 35 },

      // Ultra rare items (very limited stock)
      { name: &#39;Rare Floppy Disk&#39;, quantity: 1, price: 500 }, // Legendary item
      { name: &#39;Rainbow Hoodie&#39;, quantity: 1, price: 200 },

      { name: &#39;Hacking Toolkit&#39;, quantity: 2, price: 120 },
      { name: &#39;Signal Booster&#39;, quantity: 3, price: 80 },
      { name: &#39;Quantum Processor&#39;, quantity: 1, price: 300 },
      { name: &#39;Scanning Device&#39;, quantity: 2, price: 95 },
    ],
  },

  &#39;Desert Outpost&#39;: {
    items: [
      // Survival gear (higher prices due to remote location)
      { name: &#39;Desert Wrap&#39;, quantity: 4, price: 35 },
      { name: &#39;Survival Cloak&#39;, quantity: 2, price: 120 },
      { name: &#39;Water Purifier&#39;, quantity: 3, price: 55 },

      // Desert consumables
      { name: &#39;Cactus Juice&#39;, quantity: 8, price: 20 },
      { name: &#39;Energy Drink&#39;, quantity: 6, price: 15 }, // More expensive here
      { name: &#39;Health Potion&#39;, quantity: 4, price: 35 },

      // Desert specialties
      { name: &#39;Ancient Coin&#39;, quantity: 12, price: 25 }, // Cheaper here (local specialty)
      { name: &#39;Crystal Shard&#39;, quantity: 3, price: 80 },

      // Ultra rare desert find
      { name: &#39;Ancient Artifact&#39;, quantity: 1, price: 1000 }, // Legendary desert item

      { name: &#39;Survival Knife&#39;, quantity: 4, price: 30 },
      { name: &#39;Fire Starter&#39;, quantity: 6, price: 15 },
      { name: &#39;GPS Tracker&#39;, quantity: 2, price: 65 },
    ],
  },

  &#39;The Glitch Club&#39;: {
    items: [
      // Underground hacker gear
      { name: &#39;Cyberpunk Shades&#39;, quantity: 4, price: 55 }, // Cheaper in underground
      { name: &#39;Neon Visor&#39;, quantity: 2, price: 130 },
      { name: &#39;Data Spike&#39;, quantity: 3, price: 85 },

      // Meme culture items
      { name: &#39;Wojak Mask&#39;, quantity: 1, price: 250 }, // Epic meme item
      { name: &#39;Pepe Charm&#39;, quantity: 2, price: 75 },
      { name: &#39;Rainbow Hoodie&#39;, quantity: 1, price: 180 },

      // Hacker consumables
      { name: &#39;Code Energy Drink&#39;, quantity: 12, price: 15 }, // Club specialty
      { name: &#39;Super Energy Potion&#39;, quantity: 1, price: 160 },

      // Digital contraband
      { name: &#39;Bitcoin Fragment&#39;, quantity: 6, price: 40 }, // Better price underground
      { name: &#39;Rare Floppy Disk&#39;, quantity: 1, price: 450 }, // Slightly cheaper than exchange

      // Lucky charms
      { name: &#39;Lucky Charm&#39;, quantity: 3, price: 30 },

      { name: &#39;Hacking Toolkit&#39;, quantity: 3, price: 100 }, // Cheaper underground
      { name: &#39;Multi-Tool&#39;, quantity: 4, price: 30 },

      { name: &#39;Reality Wrench&#39;, quantity: 1, price: 4000 },
    ],
  },

  &#39;Rusty Pickaxe Inn&#39;: {
    items: [
      // Tavern basics
      { name: &#39;Energy Drink&#39;, quantity: 20, price: 10 },
      { name: &#39;Health Potion&#39;, quantity: 15, price: 22 },
      { name: &#39;Protein Bar&#39;, quantity: 25, price: 5 },

      // Basic gear for newbies
      { name: &#39;Miners Hat&#39;, quantity: 10, price: 12 }, // Cheaper at the inn
      { name: &#39;Work Gloves&#39;, quantity: 8, price: 10 },
      { name: &#39;Safety Goggles&#39;, quantity: 6, price: 6 },

      // Tavern specials
      { name: &#39;Lucky Charm&#39;, quantity: 4, price: 28 },
      { name: &#39;Pepe Charm&#39;, quantity: 1, price: 65 }, // Rare tavern find

      // Materials (inn keeper buys from miners)
      { name: &#39;Dirty Coal&#39;, quantity: 50, price: 1 }, // Cheap bulk buy
      { name: &#39;Iron Scraps&#39;, quantity: 30, price: 3 },

      { name: &#39;Basic Pickaxe&#39;, quantity: 8, price: 18 }, // Slightly cheaper
      { name: &#39;Multi-Tool&#39;, quantity: 5, price: 32 },
      { name: &#39;Repair Kit&#39;, quantity: 6, price: 22 },
    ],
  },

  &#39;Crystal Caves&#39;: {
    items: [
      // Specialized mining equipment
      { name: &#39;Reinforced Pickaxe&#39;, quantity: 2, price: 100 }, // Better price in caves
      { name: &#39;Safety Goggles&#39;, quantity: 8, price: 10 },
      { name: &#39;Heavy Duty Boots&#39;, quantity: 3, price: 22 },

      // Cave-specific consumables
      { name: &#39;Energy Drink&#39;, quantity: 12, price: 12 },
      { name: &#39;Health Potion&#39;, quantity: 8, price: 28 },

      // Crystal trade
      { name: &#39;Crystal Shard&#39;, quantity: 8, price: 50 }, // Cave specialty
      { name: &#39;Ancient Coin&#39;, quantity: 4, price: 40 },

      // Ultra rare mining tool
      { name: &#39;Golden Pickaxe&#39;, quantity: 1, price: 2500 }, // Legendary mining tool

      { name: &#39;Drill Hammer&#39;, quantity: 2, price: 90 },
      { name: &#39;Laser Cutter&#39;, quantity: 1, price: 180 },
      { name: &#39;Scanning Device&#39;, quantity: 3, price: 85 }, // Better price in caves

      { name: &#39;Omni-Tool&#39;, quantity: 1, price: 3500 },
    ],
  },

  // Parent location config (basic urban supplies)
  &#39;Cyber City&#39;: {
    items: [
      // Basic urban supplies - encourage users to visit specialized sub-locations
      { name: &#39;Energy Drink&#39;, quantity: 10, price: 15 },
      { name: &#39;Health Potion&#39;, quantity: 8, price: 30 },
      { name: &#39;Code Energy Drink&#39;, quantity: 5, price: 20 },
      { name: &#39;Lucky Charm&#39;, quantity: 2, price: 35 },

      // Note: Best items are in Central Exchange and Glitch Club
    ],
  },
}

async function seedEnhancedMarkets() {
  console.log(&#39;🏪 Starting enhanced market seed with new themed items...&#39;)

  try {
    // Get all locations that have markets (including sub-locations)
    const locations = await prisma.location.findMany({
      where: { hasMarket: true },
    })

    const items = await prisma.item.findMany()
    const itemMap = new Map(items.map((item) =&gt; [item.name, item]))

    console.log(`📍 Found ${locations.length} market locations`)
    console.log(`📦 Found ${items.length} items available`)

    // Filter locations to only those we have configs for
    const configuredLocations = locations.filter((location) =&gt;
      ENHANCED_MARKET_CONFIGS.hasOwnProperty(location.name)
    )

    console.log(
      `🎯 Processing ${configuredLocations.length} configured market locations:`
    )
    configuredLocations.forEach((loc) =&gt; console.log(`   • ${loc.name}`))

    if (configuredLocations.length !== locations.length) {
      const unconfiguredLocations = locations.filter(
        (location) =&gt; !ENHANCED_MARKET_CONFIGS.hasOwnProperty(location.name)
      )
      console.log(
        `⚠️  Skipping ${unconfiguredLocations.length} unconfigured locations:`
      )
      unconfiguredLocations.forEach((loc) =&gt;
        console.log(`   • ${loc.name} (no market config)`)
      )
    }

    let totalListingsCreated = 0
    let totalListingsUpdated = 0

    for (const location of configuredLocations) {
      const config =
        ENHANCED_MARKET_CONFIGS[
          location.name as keyof typeof ENHANCED_MARKET_CONFIGS
        ]

      console.log(`\n🏪 Restocking ${location.name}...`)

      for (const itemConfig of config.items) {
        const item = itemMap.get(itemConfig.name)

        if (!item) {
          console.log(`  ❌ Item &#39;${itemConfig.name}&#39; not found in database`)
          continue
        }

        // Check if listing already exists
        const existingListing = await prisma.marketListing.findFirst({
          where: {
            locationId: location.id,
            itemId: item.id,
            isSystemItem: true,
          },
        })

        if (existingListing) {
          // Update existing listing
          await prisma.marketListing.update({
            where: { id: existingListing.id },
            data: {
              quantity: itemConfig.quantity,
              price: itemConfig.price,
            },
          })
          console.log(
            `  🔄 Updated ${itemConfig.name}: ${itemConfig.quantity} @ ${itemConfig.price} coins`
          )
          totalListingsUpdated++
        } else {
          // Create new listing
          await prisma.marketListing.create({
            data: {
              locationId: location.id,
              itemId: item.id,
              quantity: itemConfig.quantity,
              price: itemConfig.price,
              isSystemItem: true,
            },
          })
          console.log(
            `  ✨ Added ${itemConfig.name}: ${itemConfig.quantity} @ ${itemConfig.price} coins`
          )
          totalListingsCreated++
        }
      }
    }

    console.log(&#39;\n🎉 Enhanced market seed completed successfully!&#39;)
    console.log(
      `📊 Created ${totalListingsCreated} new listings, updated ${totalListingsUpdated} existing`
    )

    // Show summary by location
    console.log(&#39;\n🏪 Market Summary by Location:&#39;)
    for (const location of configuredLocations) {
      const locationListings = await prisma.marketListing.count({
        where: {
          locationId: location.id,
          isSystemItem: true,
        },
      })

      if (locationListings &gt; 0) {
        console.log(`  ${location.name}: ${locationListings} items available`)
      }
    }

    // Show legendary/epic items available
    console.log(&#39;\n⭐ Premium Items Available:&#39;)
    const premiumListings = await prisma.marketListing.findMany({
      where: {
        isSystemItem: true,
        item: {
          rarity: {
            in: [&#39;EPIC&#39;, &#39;LEGENDARY&#39;],
          },
        },
      },
      include: {
        item: true,
        location: true,
      },
      orderBy: { price: &#39;desc&#39; },
    })

    premiumListings.forEach((listing) =&gt; {
      console.log(
        `  ${listing.item.name} (${listing.item.rarity}) - ${listing.price} coins at ${listing.location.name}`
      )
    })

    // Show total market value
    const totalMarketValue = await prisma.marketListing.aggregate({
      where: { isSystemItem: true },
      _sum: {
        price: true,
      },
    })

    console.log(
      `\n💰 Total Market Value: ${totalMarketValue._sum.price || 0} coins`
    )
  } catch (error) {
    console.error(&#39;❌ Enhanced market seed failed:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

// Command line options
const args = process.argv.slice(2)

if (args.includes(&#39;--help&#39;) || args.includes(&#39;-h&#39;)) {
  console.log(`
🏪 Enhanced Market Seeding Script

Usage:
  npm run seed:enhanced-markets          # Restock all markets with new items
  npm run seed:enhanced-markets --clear  # Clear all system listings first
  npm run seed:enhanced-markets --location &quot;Central Exchange&quot;  # Specific location

Features:
  ✨ All 7 locations covered with themed items
  💰 Location-appropriate pricing strategy
  🎯 Rarity-based availability system
  🏪 Each location has unique specialties

Locations Covered:
  🏭 Mining Plains - Industrial mining gear
  🏢 Central Exchange - High-tech cyber gear + legendaries
  🏜️ Desert Outpost - Survival gear + ancient artifacts
  🎮 The Glitch Club - Underground hacker gear + memes
  🍺 Rusty Pickaxe Inn - Newbie basics + tavern specials
  💎 Crystal Caves - Professional mining tools
  🏙️ Cyber City - Basic urban supplies

Premium Items:
  🔥 Golden Pickaxe (2500 coins at Crystal Caves)
  💾 Rare Floppy Disk (500 coins at Central Exchange)
  🏺 Ancient Artifact (1000 coins at Desert Outpost)
  🌈 Rainbow Hoodie (200 coins at Central Exchange)
  🎭 Wojak Mask (250 coins at The Glitch Club)
`)
  process.exit(0)
}

// Handle clear option
if (args.includes(&#39;--clear&#39;)) {
  console.log(&#39;🧹 Clearing existing system market listings...&#39;)
  await prisma.marketListing.deleteMany({
    where: { isSystemItem: true },
  })
  console.log(&#39;✅ Cleared all system listings&#39;)
}

// Handle specific location
const locationArg = args.indexOf(&#39;--location&#39;)
if (locationArg !== -1 &amp;&amp; args[locationArg + 1]) {
  const targetLocation = args[locationArg + 1]
  console.log(`🎯 Targeting specific location: ${targetLocation}`)

  // Filter configs to only include the target location
  const filteredConfig = {
    [targetLocation]:
      ENHANCED_MARKET_CONFIGS[
        targetLocation as keyof typeof ENHANCED_MARKET_CONFIGS
      ],
  }

  if (!filteredConfig[targetLocation]) {
    console.error(`❌ No market config found for location: ${targetLocation}`)
    console.log(
      &#39;Available locations:&#39;,
      Object.keys(ENHANCED_MARKET_CONFIGS).join(&#39;, &#39;)
    )
    process.exit(1)
  }

  // Clear all other configs
  Object.keys(ENHANCED_MARKET_CONFIGS).forEach((key) =&gt; {
    if (key !== targetLocation) {
      delete ENHANCED_MARKET_CONFIGS[
        key as keyof typeof ENHANCED_MARKET_CONFIGS
      ]
    }
  })
}

// Run the seed
seedEnhancedMarkets()
</content>
    </document>

    <document>
      <source>scripts/setup-complete-game.ts</source>
      <tags></tags>
      <metadata>
        <size>9691</size>
        <lastModified>2025-05-29T06:32:31.722Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/setup-complete-game.ts - One script to rule them all
import { PrismaClient, ItemCategory, LayerType, Rarity } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// All items combined (themed + tools)
const ALL_NEW_ITEMS = [
  // === THEMED ITEMS ===
  {
    name: &#39;Rare Floppy Disk&#39;,
    description: &#39;Contains legendary source code from the early net&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.LEGENDARY,
    imageUrl: &#39;/items/rare-floppy-disk.png&#39;,
  },
  {
    name: &#39;Cyberpunk Shades&#39;,
    description: &#39;AR-enhanced sunglasses with data overlay&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    energyEffect: 10,
    imageUrl: &#39;/items/cyberpunk-shades.png&#39;,
  },
  {
    name: &#39;Neon Visor&#39;,
    description: &#39;Glowing headgear that screams &quot;I hack the planet&quot;&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.EPIC,
    energyEffect: 15,
    imageUrl: &#39;/items/neon-visor.png&#39;,
  },
  {
    name: &#39;Heavy Duty Boots&#39;,
    description: &#39;Steel-toed boots for serious mining work&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.UNCOMMON,
    healthEffect: 10,
    imageUrl: &#39;/items/heavy-duty-boots.png&#39;,
  },
  {
    name: &#39;Desert Wrap&#39;,
    description: &#39;Traditional headwrap that protects from sandstorms&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.UNCOMMON,
    healthEffect: 8,
    imageUrl: &#39;/items/desert-wrap.png&#39;,
  },
  {
    name: &#39;Rainbow Hoodie&#39;,
    description: &#39;Psychedelic hoodie that shifts colors in the light&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.EPIC,
    energyEffect: 20,
    imageUrl: &#39;/items/rainbow-hoodie.png&#39;,
  },

  // === TOOL ITEMS ===
  {
    name: &#39;Basic Pickaxe&#39;,
    description: &#39;Standard mining tool for beginners&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 50,
    imageUrl: &#39;/items/basic-pickaxe.png&#39;,
  },
  {
    name: &#39;Multi-Tool&#39;,
    description: &#39;Swiss army knife of the digital age&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 100,
    imageUrl: &#39;/items/multi-tool.png&#39;,
  },
  {
    name: &#39;Hacking Toolkit&#39;,
    description: &#39;Portable device for digital infiltration&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 150,
    imageUrl: &#39;/items/hacking-toolkit.png&#39;,
  },
  {
    name: &#39;Omni-Tool&#39;,
    description: &#39;Legendary device that adapts to any situation&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.LEGENDARY,
    durability: 1000,
    energyEffect: 20,
    healthEffect: 10,
    imageUrl: &#39;/items/omni-tool.png&#39;,
  },
]

// Enhanced market configs (simplified - core items only)
const MARKET_CONFIGS = {
  &#39;Mining Plains&#39;: [
    { name: &#39;Miners Hat&#39;, quantity: 8, price: 15 },
    { name: &#39;Basic Pickaxe&#39;, quantity: 5, price: 20 },
    { name: &#39;Multi-Tool&#39;, quantity: 3, price: 35 },
    { name: &#39;Energy Drink&#39;, quantity: 15, price: 8 },
    { name: &#39;Heavy Duty Boots&#39;, quantity: 2, price: 45 },
  ],
  &#39;Central Exchange&#39;: [
    { name: &#39;Cyberpunk Shades&#39;, quantity: 3, price: 65 },
    { name: &#39;Neon Visor&#39;, quantity: 1, price: 150 },
    { name: &#39;Hacking Toolkit&#39;, quantity: 2, price: 120 },
    { name: &#39;Rainbow Hoodie&#39;, quantity: 1, price: 200 },
    { name: &#39;Rare Floppy Disk&#39;, quantity: 1, price: 500 },
  ],
  &#39;Desert Outpost&#39;: [
    { name: &#39;Desert Wrap&#39;, quantity: 4, price: 35 },
    { name: &#39;Energy Drink&#39;, quantity: 6, price: 15 },
    { name: &#39;Health Potion&#39;, quantity: 4, price: 35 },
  ],
  &#39;The Glitch Club&#39;: [
    { name: &#39;Cyberpunk Shades&#39;, quantity: 4, price: 55 },
    { name: &#39;Hacking Toolkit&#39;, quantity: 3, price: 100 },
    { name: &#39;Multi-Tool&#39;, quantity: 4, price: 30 },
  ],
  &#39;Rusty Pickaxe Inn&#39;: [
    { name: &#39;Energy Drink&#39;, quantity: 20, price: 10 },
    { name: &#39;Basic Pickaxe&#39;, quantity: 8, price: 18 },
    { name: &#39;Multi-Tool&#39;, quantity: 5, price: 32 },
  ],
  &#39;Crystal Caves&#39;: [
    { name: &#39;Energy Drink&#39;, quantity: 12, price: 12 },
    { name: &#39;Health Potion&#39;, quantity: 8, price: 28 },
    { name: &#39;Omni-Tool&#39;, quantity: 1, price: 3500 },
  ],
  &#39;Cyber City&#39;: [
    { name: &#39;Energy Drink&#39;, quantity: 10, price: 15 },
    { name: &#39;Health Potion&#39;, quantity: 8, price: 30 },
  ],
}

// Mining configs (simplified)
const MINING_CONFIGS = {
  &#39;Mining Plains&#39;: [
    { name: &#39;Dirty Coal&#39;, spawnRate: 0.5, maxPerDay: 25, difficulty: 1 },
    { name: &#39;Iron Scraps&#39;, spawnRate: 0.35, maxPerDay: 15, difficulty: 1 },
    { name: &#39;Basic Pickaxe&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 1 },
  ],
  &#39;Crystal Caves&#39;: [
    { name: &#39;Crystal Shard&#39;, spawnRate: 0.15, maxPerDay: 5, difficulty: 3 },
    { name: &#39;Ancient Coin&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 2 },
    { name: &#39;Omni-Tool&#39;, spawnRate: 0.002, maxPerDay: 1, difficulty: 5 },
  ],
  &#39;Desert Outpost&#39;: [
    { name: &#39;Ancient Coin&#39;, spawnRate: 0.18, maxPerDay: 8, difficulty: 3 },
    { name: &#39;Crystal Shard&#39;, spawnRate: 0.06, maxPerDay: 2, difficulty: 4 },
  ],
  &#39;Central Exchange&#39;: [
    { name: &#39;Hacking Toolkit&#39;, spawnRate: 0.02, maxPerDay: 1, difficulty: 4 },
  ],
  &#39;The Glitch Club&#39;: [
    { name: &#39;Hacking Toolkit&#39;, spawnRate: 0.035, maxPerDay: 2, difficulty: 3 },
  ],
}

async function setupCompleteGame() {
  console.log(&#39;🎮 Setting up complete Wojak Earth game...\n&#39;)

  try {
    // Step 1: Add all items
    console.log(&#39;📦 STEP 1: Adding items...&#39;)
    let itemsAdded = 0

    for (const itemData of ALL_NEW_ITEMS) {
      const existingItem = await prisma.item.findUnique({
        where: { name: itemData.name },
      })

      if (!existingItem) {
        await prisma.item.create({ data: itemData })
        console.log(`  ✨ Added ${itemData.name} (${itemData.rarity})`)
        itemsAdded++
      }
    }
    console.log(`✅ Added ${itemsAdded} new items\n`)

    // Step 2: Fix market locations
    console.log(&#39;🏪 STEP 2: Fixing market locations...&#39;)
    await prisma.location.updateMany({
      where: {
        name: { in: [&#39;Crystal Caves&#39;, &#39;The Glitch Club&#39;, &#39;Cyber City&#39;] },
      },
      data: { hasMarket: true },
    })
    console.log(&#39;✅ Market locations fixed\n&#39;)

    // Step 3: Setup mining resources
    console.log(&#39;⛏️ STEP 3: Setting up mining resources...&#39;)
    const locations = await prisma.location.findMany({
      where: { hasMining: true },
    })
    const items = await prisma.item.findMany()
    const itemMap = new Map(items.map((item) =&gt; [item.name, item]))

    let miningResourcesAdded = 0

    for (const location of locations) {
      const configs =
        MINING_CONFIGS[location.name as keyof typeof MINING_CONFIGS]
      if (!configs) continue

      for (const config of configs) {
        const item = itemMap.get(config.name)
        if (!item) continue

        const existing = await prisma.locationResource.findUnique({
          where: {
            locationId_itemId: { locationId: location.id, itemId: item.id },
          },
        })

        if (!existing) {
          await prisma.locationResource.create({
            data: {
              locationId: location.id,
              itemId: item.id,
              spawnRate: config.spawnRate,
              maxPerDay: config.maxPerDay,
              difficulty: config.difficulty,
            },
          })
          miningResourcesAdded++
        }
      }
    }
    console.log(`✅ Added ${miningResourcesAdded} mining resources\n`)

    // Step 4: Setup markets
    console.log(&#39;🛒 STEP 4: Setting up markets...&#39;)
    const marketLocations = await prisma.location.findMany({
      where: { hasMarket: true },
    })

    let marketListingsAdded = 0

    for (const location of marketLocations) {
      const configs =
        MARKET_CONFIGS[location.name as keyof typeof MARKET_CONFIGS]
      if (!configs) continue

      for (const config of configs) {
        const item = itemMap.get(config.name)
        if (!item) continue

        const existing = await prisma.marketListing.findFirst({
          where: {
            locationId: location.id,
            itemId: item.id,
            isSystemItem: true,
          },
        })

        if (existing) {
          await prisma.marketListing.update({
            where: { id: existing.id },
            data: { quantity: config.quantity, price: config.price },
          })
        } else {
          await prisma.marketListing.create({
            data: {
              locationId: location.id,
              itemId: item.id,
              quantity: config.quantity,
              price: config.price,
              isSystemItem: true,
            },
          })
          marketListingsAdded++
        }
      }
    }
    console.log(`✅ Added/updated ${marketListingsAdded} market listings\n`)

    // Final summary
    console.log(&#39;🎉 SETUP COMPLETE!&#39;)
    console.log(&#39;=&#39;.repeat(50))

    const totalItems = await prisma.item.count()
    const totalMiningNodes = await prisma.locationResource.count()
    const totalMarketListings = await prisma.marketListing.count({
      where: { isSystemItem: true },
    })

    console.log(`📦 Total items in database: ${totalItems}`)
    console.log(`⛏️ Total mining resource nodes: ${totalMiningNodes}`)
    console.log(`🛒 Total market listings: ${totalMarketListings}`)

    console.log(&#39;\n🚀 Your game is ready! Run `npm run dev` to start playing!&#39;)
  } catch (error) {
    console.error(&#39;❌ Setup failed:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

setupCompleteGame()
</content>
    </document>

    <document>
      <source>scripts/add-proper-tools.ts</source>
      <tags></tags>
      <metadata>
        <size>6468</size>
        <lastModified>2025-05-29T06:21:08.021Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/add-proper-tools.ts - Add more diverse tool items
import { PrismaClient, ItemCategory, LayerType, Rarity } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

const TOOL_ITEMS = [
  // === MINING TOOLS ===
  {
    name: &#39;Basic Pickaxe&#39;,
    description: &#39;Standard mining tool for beginners&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY, // Tools render as accessories for now
    rarity: Rarity.COMMON,
    durability: 50,
    imageUrl: &#39;/items/basic-pickaxe.png&#39;,
  },
  {
    name: &#39;Drill Hammer&#39;,
    description: &#39;Pneumatic drilling tool for tough rocks&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.UNCOMMON,
    durability: 120,
    energyEffect: -5, // Tools can cost energy to use
    imageUrl: &#39;/items/drill-hammer.png&#39;,
  },
  {
    name: &#39;Laser Cutter&#39;,
    description: &#39;High-tech precision cutting tool&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 80,
    energyEffect: -10, // High energy cost
    imageUrl: &#39;/items/laser-cutter.png&#39;,
  },

  // === UTILITY TOOLS ===
  {
    name: &#39;Multi-Tool&#39;,
    description: &#39;Swiss army knife of the digital age&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 100,
    imageUrl: &#39;/items/multi-tool.png&#39;,
  },
  {
    name: &#39;Repair Kit&#39;,
    description: &#39;Essential tool for fixing equipment on the go&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.UNCOMMON,
    durability: 25, // Limited uses
    imageUrl: &#39;/items/repair-kit.png&#39;,
  },
  {
    name: &#39;Scanning Device&#39;,
    description: &#39;Detects rare materials and hidden resources&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 200,
    energyEffect: -3, // Small energy cost per scan
    imageUrl: &#39;/items/scanning-device.png&#39;,
  },

  // === CYBER TOOLS ===
  {
    name: &#39;Hacking Toolkit&#39;,
    description: &#39;Portable device for digital infiltration&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 150,
    imageUrl: &#39;/items/hacking-toolkit.png&#39;,
  },
  {
    name: &#39;Signal Booster&#39;,
    description: &#39;Amplifies wireless connections and data transfers&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.UNCOMMON,
    durability: 300,
    energyEffect: 5, // Boosts energy regeneration
    imageUrl: &#39;/items/signal-booster.png&#39;,
  },
  {
    name: &#39;Quantum Processor&#39;,
    description: &#39;Cutting-edge computing tool for complex calculations&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.EPIC,
    durability: 100,
    energyEffect: 15, // Major energy boost
    imageUrl: &#39;/items/quantum-processor.png&#39;,
  },

  // === SURVIVAL TOOLS ===
  {
    name: &#39;Survival Knife&#39;,
    description: &#39;Multipurpose blade for harsh environments&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 200,
    healthEffect: 5, // Provides some protection
    imageUrl: &#39;/items/survival-knife.png&#39;,
  },
  {
    name: &#39;Fire Starter&#39;,
    description: &#39;Reliable ignition tool for cold nights&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 50,
    imageUrl: &#39;/items/fire-starter.png&#39;,
  },
  {
    name: &#39;GPS Tracker&#39;,
    description: &#39;Never get lost in the wilderness again&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.UNCOMMON,
    durability: 500, // Long-lasting
    imageUrl: &#39;/items/gps-tracker.png&#39;,
  },

  // === LEGENDARY TOOLS ===
  {
    name: &#39;Omni-Tool&#39;,
    description: &#39;Legendary device that adapts to any situation&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.LEGENDARY,
    durability: 1000,
    energyEffect: 20,
    healthEffect: 10,
    imageUrl: &#39;/items/omni-tool.png&#39;,
  },
  {
    name: &#39;Reality Wrench&#39;,
    description: &#39;Tool so advanced it seems to bend the laws of physics&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.LEGENDARY,
    durability: 777,
    energyEffect: 25,
    imageUrl: &#39;/items/reality-wrench.png&#39;,
  },
]

async function addProperTools() {
  console.log(&#39;🔧 Adding proper tool items to Wojak Earth...&#39;)

  try {
    let toolsAdded = 0

    for (const toolData of TOOL_ITEMS) {
      // Check if tool already exists
      const existingTool = await prisma.item.findUnique({
        where: { name: toolData.name },
      })

      if (existingTool) {
        console.log(`  ⚠️  Tool &#39;${toolData.name}&#39; already exists, skipping...`)
        continue
      }

      // Create new tool
      await prisma.item.create({
        data: toolData,
      })

      console.log(`  🔧 Added ${toolData.name} (${toolData.rarity})`)
      toolsAdded++
    }

    console.log(&#39;\n🎉 Tool items added successfully!&#39;)
    console.log(`📊 Added ${toolsAdded} new tools`)

    // Show summary by rarity
    const toolsByRarity = TOOL_ITEMS.reduce((acc, tool) =&gt; {
      const rarity = tool.rarity.toString()
      acc[rarity] = (acc[rarity] || 0) + 1
      return acc
    }, {} as Record&lt;string, number&gt;)

    console.log(&#39;\n🌟 Tools Added by Rarity:&#39;)
    Object.entries(toolsByRarity).forEach(([rarity, count]) =&gt; {
      console.log(`  ${rarity}: ${count} tools`)
    })

    // Show tool categories
    console.log(&#39;\n🔧 Tool Categories:&#39;)
    console.log(&#39;  ⛏️  Mining Tools: Basic Pickaxe, Drill Hammer, Laser Cutter&#39;)
    console.log(&#39;  🛠️  Utility Tools: Multi-Tool, Repair Kit, Scanning Device&#39;)
    console.log(
      &#39;  💻 Cyber Tools: Hacking Toolkit, Signal Booster, Quantum Processor&#39;
    )
    console.log(
      &#39;  🏕️  Survival Tools: Survival Knife, Fire Starter, GPS Tracker&#39;
    )
    console.log(&#39;  ⭐ Legendary: Omni-Tool, Reality Wrench&#39;)

    console.log(&#39;\n💡 Next Steps:&#39;)
    console.log(
      &#39;  1. Run npm run update:mining to add tools to mining locations&#39;
    )
    console.log(
      &#39;  2. Run npm run seed:enhanced-markets to add tools to markets&#39;
    )
    console.log(&#39;  3. Tools will appear in the TOOL equipment slot!&#39;)
  } catch (error) {
    console.error(&#39;❌ Failed to add tool items:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

addProperTools()
</content>
    </document>

    <document>
      <source>src/types/index.ts</source>
      <tags></tags>
      <metadata>
        <size>3015</size>
        <lastModified>2025-05-29T07:19:18.019Z</lastModified>
        <extension>ts</extension>
        <directory>src/types</directory>
      </metadata>
      <content>// src/types/index.ts
export type GameView =
  | &#39;main&#39;
  | &#39;map&#39;
  | &#39;location&#39;
  | &#39;mine&#39;
  | &#39;market&#39;
  | &#39;inventory&#39;
  | &#39;chat&#39;
  | &#39;gamemaster&#39;

export interface Character {
  id: string
  name: string
  gender: string
  energy: number
  health: number
  currentImageUrl: string
  currentLocation: {
    id: string
    name: string
    description: string
    locationType: string
    biome?: string
    welcomeMessage?: string
  }
  inventory: Array&lt;{
    id: string
    quantity: number
    isEquipped: boolean
    item: {
      id: string
      name: string
      description: string
      category: string
      rarity: string
      imageUrl?: string
      energyEffect?: number
      healthEffect?: number
    }
  }&gt;
  recentActivity: Array&lt;{
    id: string
    type: string
    description: string
    item?: {
      name: string
      rarity: string
    }
  }&gt;
}

export interface Location {
  id: string
  name: string
  description: string
  locationType: string
  biome?: string
  difficulty: number
  playerCount: number
  lastActive?: string
  hasMarket: boolean
  hasMining: boolean
  hasChat: boolean
  welcomeMessage?: string
  lore?: string
  subLocations?: Location[]
}

export interface MarketItem {
  id: string
  price: number
  quantity: number
  isSystemItem: boolean
  isLocalSpecialty?: boolean
  seller?: {
    id: string
    name: string
  }
  item: {
    id: string
    name: string
    description: string
    category: string
    rarity: string
    imageUrl?: string
  }
}

export interface ChatMessage {
  id: string
  message: string
  messageType: &#39;CHAT&#39; | &#39;EMOTE&#39; | &#39;SYSTEM&#39;
  isSystem: boolean
  timeAgo: string
  createdAt: string
  character?: {
    id: string
    name: string
    characterType: string
    imageUrl?: string
  }
  location: {
    id: string
    name: string
    locationType: string
  }
}

export interface Player {
  id: string
  name: string
  gender: string
  characterType: string
  level: number
  energy: number
  health: number
  status: string
  currentImageUrl?: string
  equippedItems: Array&lt;{
    name: string
    category: string
    rarity: string
  }&gt;
}

export type EquipmentSlot = &#39;head&#39; | &#39;body&#39; | &#39;accessory&#39; | &#39;tool&#39;

export interface EquipmentSlotInfo {
  name: string
  slot: EquipmentSlot
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  icon: any // Lucide icon component
  equipped?: {
    id: string
    name: string
    rarity: string
  }
}

export interface EnhancedCharacter extends Character {
  equipmentSlots?: {
    [K in EquipmentSlot]?: {
      itemId: string
      itemName: string
      rarity: string
    }
  }
}

// Equipment slot conflicts - for future slot-specific logic
export const SLOT_CONFLICTS: Record&lt;string, EquipmentSlot[]&gt; = {
  HAT: [&#39;head&#39;],
  CLOTHING: [&#39;body&#39;],
  ACCESSORY: [&#39;accessory&#39;],
  TOOL: [&#39;tool&#39;],
}

// Equipment bonuses by slot - for future enhancement
export interface SlotBonuses {
  energyBonus: number
  healthBonus: number
  miningBonus: number
  luckBonus: number
}
</content>
    </document>

    <document>
      <source>src/components/ui/tabs.tsx</source>
      <tags></tags>
      <metadata>
        <size>1955</size>
        <lastModified>2025-05-29T11:14:29.295Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as TabsPrimitive from &quot;@radix-ui/react-tabs&quot;

import { cn } from &quot;@/lib/utils&quot;

function Tabs({
  className,
  ...props
}: React.ComponentProps&lt;typeof TabsPrimitive.Root&gt;) {
  return (
    &lt;TabsPrimitive.Root
      data-slot=&quot;tabs&quot;
      className={cn(&quot;flex flex-col gap-2&quot;, className)}
      {...props}
    /&gt;
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps&lt;typeof TabsPrimitive.List&gt;) {
  return (
    &lt;TabsPrimitive.List
      data-slot=&quot;tabs-list&quot;
      className={cn(
        &quot;bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps&lt;typeof TabsPrimitive.Trigger&gt;) {
  return (
    &lt;TabsPrimitive.Trigger
      data-slot=&quot;tabs-trigger&quot;
      className={cn(
        &quot;data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps&lt;typeof TabsPrimitive.Content&gt;) {
  return (
    &lt;TabsPrimitive.Content
      data-slot=&quot;tabs-content&quot;
      className={cn(&quot;flex-1 outline-none&quot;, className)}
      {...props}
    /&gt;
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
</content>
    </document>

    <document>
      <source>src/components/ui/tooltip.tsx</source>
      <tags></tags>
      <metadata>
        <size>1877</size>
        <lastModified>2025-05-29T11:09:24.963Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as TooltipPrimitive from &quot;@radix-ui/react-tooltip&quot;

import { cn } from &quot;@/lib/utils&quot;

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps&lt;typeof TooltipPrimitive.Provider&gt;) {
  return (
    &lt;TooltipPrimitive.Provider
      data-slot=&quot;tooltip-provider&quot;
      delayDuration={delayDuration}
      {...props}
    /&gt;
  )
}

function Tooltip({
  ...props
}: React.ComponentProps&lt;typeof TooltipPrimitive.Root&gt;) {
  return (
    &lt;TooltipProvider&gt;
      &lt;TooltipPrimitive.Root data-slot=&quot;tooltip&quot; {...props} /&gt;
    &lt;/TooltipProvider&gt;
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps&lt;typeof TooltipPrimitive.Trigger&gt;) {
  return &lt;TooltipPrimitive.Trigger data-slot=&quot;tooltip-trigger&quot; {...props} /&gt;
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps&lt;typeof TooltipPrimitive.Content&gt;) {
  return (
    &lt;TooltipPrimitive.Portal&gt;
      &lt;TooltipPrimitive.Content
        data-slot=&quot;tooltip-content&quot;
        sideOffset={sideOffset}
        className={cn(
          &quot;bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance&quot;,
          className
        )}
        {...props}
      &gt;
        {children}
        &lt;TooltipPrimitive.Arrow className=&quot;bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]&quot; /&gt;
      &lt;/TooltipPrimitive.Content&gt;
    &lt;/TooltipPrimitive.Portal&gt;
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</content>
    </document>

    <document>
      <source>src/components/ui/sonner.tsx</source>
      <tags></tags>
      <metadata>
        <size>627</size>
        <lastModified>2025-05-29T04:28:51.400Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>// src/components/ui/sonner.tsx - Fixed version
import { useTheme } from &quot;next-themes&quot;
import { Toaster as Sonner } from &quot;sonner&quot;
import type { ToasterProps } from &quot;sonner&quot;

const Toaster = ({ ...props }: ToasterProps) =&gt; {
  const { theme = &quot;system&quot; } = useTheme()

  return (
    &lt;Sonner
      theme={theme as ToasterProps[&quot;theme&quot;]}
      className=&quot;toaster group&quot;
      style={
        {
          &quot;--normal-bg&quot;: &quot;var(--popover)&quot;,
          &quot;--normal-text&quot;: &quot;var(--popover-foreground)&quot;,
          &quot;--normal-border&quot;: &quot;var(--border)&quot;,
        } as React.CSSProperties
      }
      {...props}
    /&gt;
  )
}

export { Toaster }
</content>
    </document>

    <document>
      <source>src/components/ui/dialog.tsx</source>
      <tags></tags>
      <metadata>
        <size>3813</size>
        <lastModified>2025-05-29T08:13:25.281Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>&quot;use client&quot;

import * as React from &quot;react&quot;
import * as DialogPrimitive from &quot;@radix-ui/react-dialog&quot;
import { XIcon } from &quot;lucide-react&quot;

import { cn } from &quot;@/lib/utils&quot;

function Dialog({
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Root&gt;) {
  return &lt;DialogPrimitive.Root data-slot=&quot;dialog&quot; {...props} /&gt;
}

function DialogTrigger({
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Trigger&gt;) {
  return &lt;DialogPrimitive.Trigger data-slot=&quot;dialog-trigger&quot; {...props} /&gt;
}

function DialogPortal({
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Portal&gt;) {
  return &lt;DialogPrimitive.Portal data-slot=&quot;dialog-portal&quot; {...props} /&gt;
}

function DialogClose({
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Close&gt;) {
  return &lt;DialogPrimitive.Close data-slot=&quot;dialog-close&quot; {...props} /&gt;
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Overlay&gt;) {
  return (
    &lt;DialogPrimitive.Overlay
      data-slot=&quot;dialog-overlay&quot;
      className={cn(
        &quot;data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Content&gt;) {
  return (
    &lt;DialogPortal data-slot=&quot;dialog-portal&quot;&gt;
      &lt;DialogOverlay /&gt;
      &lt;DialogPrimitive.Content
        data-slot=&quot;dialog-content&quot;
        className={cn(
          &quot;bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg&quot;,
          className
        )}
        {...props}
      &gt;
        {children}
        &lt;DialogPrimitive.Close className=&quot;ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4&quot;&gt;
          &lt;XIcon /&gt;
          &lt;span className=&quot;sr-only&quot;&gt;Close&lt;/span&gt;
        &lt;/DialogPrimitive.Close&gt;
      &lt;/DialogPrimitive.Content&gt;
    &lt;/DialogPortal&gt;
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps&lt;&quot;div&quot;&gt;) {
  return (
    &lt;div
      data-slot=&quot;dialog-header&quot;
      className={cn(&quot;flex flex-col gap-2 text-center sm:text-left&quot;, className)}
      {...props}
    /&gt;
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps&lt;&quot;div&quot;&gt;) {
  return (
    &lt;div
      data-slot=&quot;dialog-footer&quot;
      className={cn(
        &quot;flex flex-col-reverse gap-2 sm:flex-row sm:justify-end&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Title&gt;) {
  return (
    &lt;DialogPrimitive.Title
      data-slot=&quot;dialog-title&quot;
      className={cn(&quot;text-lg leading-none font-semibold&quot;, className)}
      {...props}
    /&gt;
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Description&gt;) {
  return (
    &lt;DialogPrimitive.Description
      data-slot=&quot;dialog-description&quot;
      className={cn(&quot;text-muted-foreground text-sm&quot;, className)}
      {...props}
    /&gt;
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</content>
    </document>

    <document>
      <source>src/components/ui/dropdown-menu.tsx</source>
      <tags></tags>
      <metadata>
        <size>8270</size>
        <lastModified>2025-05-29T00:35:27.082Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as DropdownMenuPrimitive from &quot;@radix-ui/react-dropdown-menu&quot;
import { CheckIcon, ChevronRightIcon, CircleIcon } from &quot;lucide-react&quot;

import { cn } from &quot;@/lib/utils&quot;

function DropdownMenu({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Root&gt;) {
  return &lt;DropdownMenuPrimitive.Root data-slot=&quot;dropdown-menu&quot; {...props} /&gt;
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Portal&gt;) {
  return (
    &lt;DropdownMenuPrimitive.Portal data-slot=&quot;dropdown-menu-portal&quot; {...props} /&gt;
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Trigger&gt;) {
  return (
    &lt;DropdownMenuPrimitive.Trigger
      data-slot=&quot;dropdown-menu-trigger&quot;
      {...props}
    /&gt;
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Content&gt;) {
  return (
    &lt;DropdownMenuPrimitive.Portal&gt;
      &lt;DropdownMenuPrimitive.Content
        data-slot=&quot;dropdown-menu-content&quot;
        sideOffset={sideOffset}
        className={cn(
          &quot;bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md&quot;,
          className
        )}
        {...props}
      /&gt;
    &lt;/DropdownMenuPrimitive.Portal&gt;
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Group&gt;) {
  return (
    &lt;DropdownMenuPrimitive.Group data-slot=&quot;dropdown-menu-group&quot; {...props} /&gt;
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = &quot;default&quot;,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Item&gt; &amp; {
  inset?: boolean
  variant?: &quot;default&quot; | &quot;destructive&quot;
}) {
  return (
    &lt;DropdownMenuPrimitive.Item
      data-slot=&quot;dropdown-menu-item&quot;
      data-inset={inset}
      data-variant={variant}
      className={cn(
        &quot;focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&amp;_svg:not([class*=&#39;text-&#39;])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.CheckboxItem&gt;) {
  return (
    &lt;DropdownMenuPrimitive.CheckboxItem
      data-slot=&quot;dropdown-menu-checkbox-item&quot;
      className={cn(
        &quot;focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4&quot;,
        className
      )}
      checked={checked}
      {...props}
    &gt;
      &lt;span className=&quot;pointer-events-none absolute left-2 flex size-3.5 items-center justify-center&quot;&gt;
        &lt;DropdownMenuPrimitive.ItemIndicator&gt;
          &lt;CheckIcon className=&quot;size-4&quot; /&gt;
        &lt;/DropdownMenuPrimitive.ItemIndicator&gt;
      &lt;/span&gt;
      {children}
    &lt;/DropdownMenuPrimitive.CheckboxItem&gt;
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.RadioGroup&gt;) {
  return (
    &lt;DropdownMenuPrimitive.RadioGroup
      data-slot=&quot;dropdown-menu-radio-group&quot;
      {...props}
    /&gt;
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.RadioItem&gt;) {
  return (
    &lt;DropdownMenuPrimitive.RadioItem
      data-slot=&quot;dropdown-menu-radio-item&quot;
      className={cn(
        &quot;focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4&quot;,
        className
      )}
      {...props}
    &gt;
      &lt;span className=&quot;pointer-events-none absolute left-2 flex size-3.5 items-center justify-center&quot;&gt;
        &lt;DropdownMenuPrimitive.ItemIndicator&gt;
          &lt;CircleIcon className=&quot;size-2 fill-current&quot; /&gt;
        &lt;/DropdownMenuPrimitive.ItemIndicator&gt;
      &lt;/span&gt;
      {children}
    &lt;/DropdownMenuPrimitive.RadioItem&gt;
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Label&gt; &amp; {
  inset?: boolean
}) {
  return (
    &lt;DropdownMenuPrimitive.Label
      data-slot=&quot;dropdown-menu-label&quot;
      data-inset={inset}
      className={cn(
        &quot;px-2 py-1.5 text-sm font-medium data-[inset]:pl-8&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Separator&gt;) {
  return (
    &lt;DropdownMenuPrimitive.Separator
      data-slot=&quot;dropdown-menu-separator&quot;
      className={cn(&quot;bg-border -mx-1 my-1 h-px&quot;, className)}
      {...props}
    /&gt;
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps&lt;&quot;span&quot;&gt;) {
  return (
    &lt;span
      data-slot=&quot;dropdown-menu-shortcut&quot;
      className={cn(
        &quot;text-muted-foreground ml-auto text-xs tracking-widest&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Sub&gt;) {
  return &lt;DropdownMenuPrimitive.Sub data-slot=&quot;dropdown-menu-sub&quot; {...props} /&gt;
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.SubTrigger&gt; &amp; {
  inset?: boolean
}) {
  return (
    &lt;DropdownMenuPrimitive.SubTrigger
      data-slot=&quot;dropdown-menu-sub-trigger&quot;
      data-inset={inset}
      className={cn(
        &quot;focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8&quot;,
        className
      )}
      {...props}
    &gt;
      {children}
      &lt;ChevronRightIcon className=&quot;ml-auto size-4&quot; /&gt;
    &lt;/DropdownMenuPrimitive.SubTrigger&gt;
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.SubContent&gt;) {
  return (
    &lt;DropdownMenuPrimitive.SubContent
      data-slot=&quot;dropdown-menu-sub-content&quot;
      className={cn(
        &quot;bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</content>
    </document>

    <document>
      <source>src/components/ui/button.tsx</source>
      <tags></tags>
      <metadata>
        <size>2123</size>
        <lastModified>2025-05-28T21:47:16.145Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import { Slot } from &quot;@radix-ui/react-slot&quot;
import { cva, type VariantProps } from &quot;class-variance-authority&quot;

import { cn } from &quot;@/lib/utils&quot;

const buttonVariants = cva(
  &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive&quot;,
  {
    variants: {
      variant: {
        default:
          &quot;bg-primary text-primary-foreground shadow-xs hover:bg-primary/90&quot;,
        destructive:
          &quot;bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60&quot;,
        outline:
          &quot;border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50&quot;,
        secondary:
          &quot;bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80&quot;,
        ghost:
          &quot;hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50&quot;,
        link: &quot;text-primary underline-offset-4 hover:underline&quot;,
      },
      size: {
        default: &quot;h-9 px-4 py-2 has-[&gt;svg]:px-3&quot;,
        sm: &quot;h-8 rounded-md gap-1.5 px-3 has-[&gt;svg]:px-2.5&quot;,
        lg: &quot;h-10 rounded-md px-6 has-[&gt;svg]:px-4&quot;,
        icon: &quot;size-9&quot;,
      },
    },
    defaultVariants: {
      variant: &quot;default&quot;,
      size: &quot;default&quot;,
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps&lt;&quot;button&quot;&gt; &amp;
  VariantProps&lt;typeof buttonVariants&gt; &amp; {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : &quot;button&quot;

  return (
    &lt;Comp
      data-slot=&quot;button&quot;
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    /&gt;
  )
}

export { Button, buttonVariants }
</content>
    </document>

    <document>
      <source>src/components/ui/badge.tsx</source>
      <tags></tags>
      <metadata>
        <size>1631</size>
        <lastModified>2025-05-29T08:13:25.456Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import { Slot } from &quot;@radix-ui/react-slot&quot;
import { cva, type VariantProps } from &quot;class-variance-authority&quot;

import { cn } from &quot;@/lib/utils&quot;

const badgeVariants = cva(
  &quot;inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&amp;&gt;svg]:size-3 gap-1 [&amp;&gt;svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden&quot;,
  {
    variants: {
      variant: {
        default:
          &quot;border-transparent bg-primary text-primary-foreground [a&amp;]:hover:bg-primary/90&quot;,
        secondary:
          &quot;border-transparent bg-secondary text-secondary-foreground [a&amp;]:hover:bg-secondary/90&quot;,
        destructive:
          &quot;border-transparent bg-destructive text-white [a&amp;]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60&quot;,
        outline:
          &quot;text-foreground [a&amp;]:hover:bg-accent [a&amp;]:hover:text-accent-foreground&quot;,
      },
    },
    defaultVariants: {
      variant: &quot;default&quot;,
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps&lt;&quot;span&quot;&gt; &amp;
  VariantProps&lt;typeof badgeVariants&gt; &amp; { asChild?: boolean }) {
  const Comp = asChild ? Slot : &quot;span&quot;

  return (
    &lt;Comp
      data-slot=&quot;badge&quot;
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    /&gt;
  )
}

export { Badge, badgeVariants }
</content>
    </document>

    <document>
      <source>src/components/ui/avatar.tsx</source>
      <tags></tags>
      <metadata>
        <size>1097</size>
        <lastModified>2025-05-29T08:13:25.444Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>&quot;use client&quot;

import * as React from &quot;react&quot;
import * as AvatarPrimitive from &quot;@radix-ui/react-avatar&quot;

import { cn } from &quot;@/lib/utils&quot;

function Avatar({
  className,
  ...props
}: React.ComponentProps&lt;typeof AvatarPrimitive.Root&gt;) {
  return (
    &lt;AvatarPrimitive.Root
      data-slot=&quot;avatar&quot;
      className={cn(
        &quot;relative flex size-8 shrink-0 overflow-hidden rounded-full&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps&lt;typeof AvatarPrimitive.Image&gt;) {
  return (
    &lt;AvatarPrimitive.Image
      data-slot=&quot;avatar-image&quot;
      className={cn(&quot;aspect-square size-full&quot;, className)}
      {...props}
    /&gt;
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps&lt;typeof AvatarPrimitive.Fallback&gt;) {
  return (
    &lt;AvatarPrimitive.Fallback
      data-slot=&quot;avatar-fallback&quot;
      className={cn(
        &quot;bg-muted flex size-full items-center justify-center rounded-full&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

export { Avatar, AvatarImage, AvatarFallback }
</content>
    </document>

    <document>
      <source>src/components/ui/scroll-area.tsx</source>
      <tags></tags>
      <metadata>
        <size>1631</size>
        <lastModified>2025-05-29T08:13:25.435Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as ScrollAreaPrimitive from &quot;@radix-ui/react-scroll-area&quot;

import { cn } from &quot;@/lib/utils&quot;

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps&lt;typeof ScrollAreaPrimitive.Root&gt;) {
  return (
    &lt;ScrollAreaPrimitive.Root
      data-slot=&quot;scroll-area&quot;
      className={cn(&quot;relative&quot;, className)}
      {...props}
    &gt;
      &lt;ScrollAreaPrimitive.Viewport
        data-slot=&quot;scroll-area-viewport&quot;
        className=&quot;focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1&quot;
      &gt;
        {children}
      &lt;/ScrollAreaPrimitive.Viewport&gt;
      &lt;ScrollBar /&gt;
      &lt;ScrollAreaPrimitive.Corner /&gt;
    &lt;/ScrollAreaPrimitive.Root&gt;
  )
}

function ScrollBar({
  className,
  orientation = &quot;vertical&quot;,
  ...props
}: React.ComponentProps&lt;typeof ScrollAreaPrimitive.ScrollAreaScrollbar&gt;) {
  return (
    &lt;ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot=&quot;scroll-area-scrollbar&quot;
      orientation={orientation}
      className={cn(
        &quot;flex touch-none p-px transition-colors select-none&quot;,
        orientation === &quot;vertical&quot; &amp;&amp;
          &quot;h-full w-2.5 border-l border-l-transparent&quot;,
        orientation === &quot;horizontal&quot; &amp;&amp;
          &quot;h-2.5 flex-col border-t border-t-transparent&quot;,
        className
      )}
      {...props}
    &gt;
      &lt;ScrollAreaPrimitive.ScrollAreaThumb
        data-slot=&quot;scroll-area-thumb&quot;
        className=&quot;bg-border relative flex-1 rounded-full&quot;
      /&gt;
    &lt;/ScrollAreaPrimitive.ScrollAreaScrollbar&gt;
  )
}

export { ScrollArea, ScrollBar }
</content>
    </document>

    <document>
      <source>src/components/views/MiningView.tsx</source>
      <tags></tags>
      <metadata>
        <size>1724</size>
        <lastModified>2025-05-29T05:11:37.300Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/views</directory>
      </metadata>
      <content>// src/components/views/MiningView.tsx
import { Button } from &#39;@/components/ui/button&#39;
import { ArrowLeft, Pickaxe, Loader2 } from &#39;lucide-react&#39;
import type { Character } from &#39;@/types&#39;

interface MiningViewProps {
  character: Character
  loadingItems: Set&lt;string&gt;
  onBack: () =&gt; void
  onMine: () =&gt; void
}

export function MiningView({ character, loadingItems, onBack, onMine }: MiningViewProps) {
  const isMining = loadingItems.has(&#39;mining-action&#39;)
  const canMine = character.energy &gt;= 10 &amp;&amp; !isMining

  return (
    &lt;div className=&quot;space-y-4&quot;&gt;
      &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;Mining in {character.currentLocation.name}&lt;/h3&gt;
      &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;
        Search for resources. Each attempt costs 10 energy.
      &lt;/p&gt;

      &lt;div className=&quot;bg-muted/50 p-4 rounded-lg&quot;&gt;
        &lt;h4 className=&quot;font-medium mb-2&quot;&gt;Available Resources:&lt;/h4&gt;
        &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;
          Resources vary by location. Try your luck!
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;Button onClick={onMine} className=&quot;w-full&quot; disabled={!canMine}&gt;
        {isMining ? (
          &lt;&gt;
            &lt;Loader2 className=&quot;w-4 h-4 mr-2 animate-spin&quot; /&gt;
            Mining...
          &lt;/&gt;
        ) : (
          &lt;&gt;
            &lt;Pickaxe className=&quot;w-4 h-4 mr-2&quot; /&gt;
            Mine for Resources
          &lt;/&gt;
        )}
      &lt;/Button&gt;

      {character.energy &lt; 10 &amp;&amp; !isMining &amp;&amp; (
        &lt;p className=&quot;text-sm text-center text-muted-foreground&quot;&gt;
          Not enough energy! Use an Energy Drink to restore energy.
        &lt;/p&gt;
      )}

      &lt;Button onClick={onBack} variant=&quot;ghost&quot;&gt;
        &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
        Back
      &lt;/Button&gt;
    &lt;/div&gt;
  )
}
</content>
    </document>

    <document>
      <source>src/components/views/MarketView.tsx</source>
      <tags></tags>
      <metadata>
        <size>6173</size>
        <lastModified>2025-05-29T04:43:00.072Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/views</directory>
      </metadata>
      <content>// src/components/views/MarketView.tsx
import { useState } from &#39;react&#39;
import { Button } from &#39;@/components/ui/button&#39;
import { ArrowLeft, Store, Coins, Loader2 } from &#39;lucide-react&#39;
import type { Character, Location, MarketItem } from &#39;@/types&#39;

interface MarketViewProps {
  character: Character
  selectedLocation: Location | null
  locations: Location[]
  marketItems: MarketItem[]
  loadingItems: Set&lt;string&gt;
  onBack: () =&gt; void
  onPurchase: (marketListingId: string, price: number, itemName: string) =&gt; void
}

export function MarketView({
  character,
  selectedLocation,
  locations,
  marketItems,
  loadingItems,
  onBack,
  onPurchase
}: MarketViewProps) {
  const [activeTab, setActiveTab] = useState&lt;&#39;local&#39; | &#39;global&#39;&gt;(&#39;local&#39;)

  // Determine if we&#39;re at a child location (has parent location)
  const currentLoc = selectedLocation || character?.currentLocation
  const isChildLocation = currentLoc &amp;&amp; locations.find(loc =&gt;
    loc.subLocations?.some(sub =&gt; sub.id === currentLoc.id)
  )

  // Filter market items by tab
  const localItems = marketItems.filter(item =&gt; item.isLocalSpecialty || false)
  const globalItems = marketItems.filter(item =&gt; !item.isLocalSpecialty)

  const activeItems = activeTab === &#39;local&#39; ? localItems : globalItems

  return (
    &lt;div className=&quot;space-y-4&quot;&gt;
      &lt;div className=&quot;text-center&quot;&gt;
        &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;Market - {currentLoc?.name}&lt;/h3&gt;
        {isChildLocation &amp;&amp; (
          &lt;p className=&quot;text-xs text-muted-foreground&quot;&gt;
            Unique local items + supplies from the main settlement
          &lt;/p&gt;
        )}
      &lt;/div&gt;

      {/* Tab Navigation - only show if child location */}
      {isChildLocation &amp;&amp; (
        &lt;div className=&quot;flex border-b&quot;&gt;
          &lt;button
            className={`flex-1 py-2 px-4 text-sm font-medium border-b-2 transition-colors ${activeTab === &#39;local&#39;
              ? &#39;border-primary text-primary bg-primary/5&#39;
              : &#39;border-transparent text-muted-foreground hover:text-foreground&#39;
              }`}
            onClick={() =&gt; setActiveTab(&#39;local&#39;)}
          &gt;
            Local Specialties
            {localItems.length &gt; 0 &amp;&amp; (
              &lt;span className=&quot;ml-1 text-xs bg-primary/20 text-primary px-1.5 py-0.5 rounded-full&quot;&gt;
                {localItems.length}
              &lt;/span&gt;
            )}
          &lt;/button&gt;
          &lt;button
            className={`flex-1 py-2 px-4 text-sm font-medium border-b-2 transition-colors ${activeTab === &#39;global&#39;
              ? &#39;border-primary text-primary bg-primary/5&#39;
              : &#39;border-transparent text-muted-foreground hover:text-foreground&#39;
              }`}
            onClick={() =&gt; setActiveTab(&#39;global&#39;)}
          &gt;
            Global Market
            {globalItems.length &gt; 0 &amp;&amp; (
              &lt;span className=&quot;ml-1 text-xs bg-muted text-muted-foreground px-1.5 py-0.5 rounded-full&quot;&gt;
                {globalItems.length}
              &lt;/span&gt;
            )}
          &lt;/button&gt;
        &lt;/div&gt;
      )}

      {/* Market Items */}
      &lt;div className=&quot;space-y-2&quot;&gt;
        {activeItems.length &gt; 0 ? (
          activeItems.map((marketItem) =&gt; {
            const isLoading = loadingItems.has(marketItem.id)

            return (
              &lt;div key={marketItem.id} className=&quot;flex items-center justify-between p-3 bg-muted/50 rounded-lg&quot;&gt;
                &lt;div className=&quot;flex items-center gap-3&quot;&gt;
                  &lt;div className=&quot;w-8 h-8 bg-muted rounded flex items-center justify-center text-xs&quot;&gt;
                    {marketItem.item.category === &#39;HAT&#39; ? &#39;🎩&#39; :
                      marketItem.item.category === &#39;CONSUMABLE&#39; ? &#39;🥤&#39; :
                        marketItem.isLocalSpecialty ? &#39;✨&#39; : &#39;📦&#39;}
                  &lt;/div&gt;
                  &lt;div&gt;
                    &lt;div className=&quot;font-medium flex items-center gap-2&quot;&gt;
                      {marketItem.item.name}
                      {marketItem.isLocalSpecialty &amp;&amp; (
                        &lt;span className=&quot;text-xs bg-amber-100 text-amber-800 px-1.5 py-0.5 rounded-full&quot;&gt;
                          Local
                        &lt;/span&gt;
                      )}
                    &lt;/div&gt;
                    &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;{marketItem.item.description}&lt;/div&gt;
                    &lt;div className=&quot;text-xs text-muted-foreground capitalize&quot;&gt;
                      {marketItem.item.rarity} • Sold by {marketItem.isSystemItem ? &#39;System&#39; : marketItem.seller?.name}
                    &lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=&quot;text-right&quot;&gt;
                  &lt;div className=&quot;font-bold flex items-center gap-1&quot;&gt;
                    &lt;Coins className=&quot;w-3 h-3&quot; /&gt;
                    {marketItem.price}
                  &lt;/div&gt;
                  &lt;div className=&quot;text-xs text-muted-foreground mb-1&quot;&gt;
                    Qty: {marketItem.quantity &gt; 0 ? marketItem.quantity : &#39;Out of Stock&#39;}
                  &lt;/div&gt;
                  &lt;Button
                    size=&quot;sm&quot;
                    onClick={() =&gt; onPurchase(marketItem.id, marketItem.price, marketItem.item.name)}
                    disabled={marketItem.quantity === 0 || isLoading}
                  &gt;
                    {isLoading ? (
                      &lt;Loader2 className=&quot;w-3 h-3 animate-spin&quot; /&gt;
                    ) : marketItem.quantity &gt; 0 ? &#39;Buy&#39; : &#39;Sold Out&#39;}
                  &lt;/Button&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            )
          })
        ) : (
          &lt;div className=&quot;bg-muted/30 p-8 rounded-lg text-center text-muted-foreground&quot;&gt;
            &lt;Store className=&quot;w-12 h-12 mx-auto mb-2&quot; /&gt;
            {activeTab === &#39;local&#39; ? (
              &lt;&gt;
                No local specialties available.&lt;br /&gt;
                Check back later or try the global market.
              &lt;/&gt;
            ) : (
              &lt;&gt;
                No items available in the global market.&lt;br /&gt;
                The merchants might be restocking.
              &lt;/&gt;
            )}
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;Button onClick={onBack} variant=&quot;ghost&quot;&gt;
        &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
        Back
      &lt;/Button&gt;
    &lt;/div&gt;
  )
}
</content>
    </document>

    <document>
      <source>src/components/views/InventoryView.tsx</source>
      <tags></tags>
      <metadata>
        <size>10404</size>
        <lastModified>2025-05-29T11:14:50.302Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/views</directory>
      </metadata>
      <content>// src/components/views/InventoryView.tsx - Enhanced version
import { useState } from &#39;react&#39;
import { Button } from &#39;@/components/ui/button&#39;
import { ArrowLeft, Backpack, Loader2, Shield, Crown, Shirt, Gem, Package, Zap, Heart } from &#39;lucide-react&#39;
import type { Character } from &#39;@/types&#39;

interface InventoryViewProps {
  character: Character
  loadingItems: Set&lt;string&gt;
  onBack: () =&gt; void
  onUseItem: (inventoryId: string, itemName: string, energyEffect?: number, healthEffect?: number) =&gt; void
  onEquipItem: (inventoryId: string, isEquipped: boolean) =&gt; void
}

type InventoryTab = &#39;equipment&#39; | &#39;consumables&#39; | &#39;materials&#39; | &#39;all&#39;

// Equipment slot mapping
const EQUIPMENT_SLOTS = {
  HAT: { name: &#39;Head&#39;, icon: Crown, slot: &#39;head&#39; },
  CLOTHING: { name: &#39;Body&#39;, icon: Shirt, slot: &#39;body&#39; },
  ACCESSORY: { name: &#39;Accessory&#39;, icon: Gem, slot: &#39;accessory&#39; },
  TOOL: { name: &#39;Tool&#39;, icon: Shield, slot: &#39;tool&#39; },
} as const

export function InventoryView({
  character,
  loadingItems,
  onBack,
  onUseItem,
  onEquipItem
}: InventoryViewProps) {
  const [activeTab, setActiveTab] = useState&lt;InventoryTab&gt;(&#39;all&#39;)

  // Categorize inventory items
  const equipmentItems = character.inventory?.filter(inv =&gt;
    [&#39;HAT&#39;, &#39;CLOTHING&#39;, &#39;ACCESSORY&#39;, &#39;TOOL&#39;].includes(inv.item.category)
  ) || []

  const consumableItems = character.inventory?.filter(inv =&gt;
    inv.item.category === &#39;CONSUMABLE&#39;
  ) || []

  const materialItems = character.inventory?.filter(inv =&gt;
    inv.item.category === &#39;MATERIAL&#39;
  ) || []

  // Get items based on active tab
  const getActiveItems = () =&gt; {
    switch (activeTab) {
      case &#39;equipment&#39;: return equipmentItems
      case &#39;consumables&#39;: return consumableItems
      case &#39;materials&#39;: return materialItems
      case &#39;all&#39;: return character.inventory || []
      default: return character.inventory || []
    }
  }

  // Get equipped items by slot
  const getEquippedBySlot = (slot: string) =&gt; {
    return equipmentItems.find(inv =&gt;
      inv.isEquipped &amp;&amp; EQUIPMENT_SLOTS[inv.item.category as keyof typeof EQUIPMENT_SLOTS]?.slot === slot
    )
  }

  const renderEquipmentSlots = () =&gt; (
    &lt;div className=&quot;bg-muted/30 p-4 rounded-lg mb-4&quot;&gt;
      &lt;h4 className=&quot;font-medium mb-3 text-sm&quot;&gt;Equipment Slots&lt;/h4&gt;
      &lt;div className=&quot;grid grid-cols-2 gap-3&quot;&gt;
        {Object.entries(EQUIPMENT_SLOTS).map(([category, config]) =&gt; {
          const equippedItem = getEquippedBySlot(config.slot)
          const IconComponent = config.icon

          return (
            &lt;div
              key={config.slot}
              className={`border-2 border-dashed rounded-lg p-3 text-center transition-colors ${equippedItem
                ? &#39;border-primary bg-primary/5&#39;
                : &#39;border-muted-foreground/30 bg-muted/20&#39;
                }`}
            &gt;
              &lt;div className=&quot;flex flex-col items-center gap-1&quot;&gt;
                &lt;IconComponent className={`w-6 h-6 ${equippedItem ? &#39;text-primary&#39; : &#39;text-muted-foreground&#39;}`} /&gt;
                &lt;div className=&quot;text-xs font-medium&quot;&gt;{config.name}&lt;/div&gt;
                {equippedItem ? (
                  &lt;div className=&quot;text-xs text-center&quot;&gt;
                    &lt;div className=&quot;font-medium text-primary&quot;&gt;{equippedItem.item.name}&lt;/div&gt;
                    &lt;div className=&quot;text-muted-foreground capitalize&quot;&gt;{equippedItem.item.rarity}&lt;/div&gt;
                  &lt;/div&gt;
                ) : (
                  &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;Empty&lt;/div&gt;
                )}
              &lt;/div&gt;
            &lt;/div&gt;
          )
        })}
      &lt;/div&gt;
    &lt;/div&gt;
  )

  const renderInventoryItem = (inv: Character[&#39;inventory&#39;][0]) =&gt; {
    const isConsumable = inv.item.category === &#39;CONSUMABLE&#39;
    const energyEffect = inv.item.energyEffect || 0
    const healthEffect = inv.item.healthEffect || 0

    const wouldWasteEnergy = energyEffect &gt; 0 &amp;&amp; character.energy &gt;= 100
    const wouldWasteHealth = healthEffect &gt; 0 &amp;&amp; character.health &gt;= 100
    const wouldBeWasted = isConsumable &amp;&amp; (
      (energyEffect &gt; 0 &amp;&amp; wouldWasteEnergy) ||
      (healthEffect &gt; 0 &amp;&amp; wouldWasteHealth)
    )

    const isLoading = loadingItems.has(inv.id)

    return (
      &lt;div key={inv.id} className=&quot;flex items-center justify-between p-3 bg-muted/50 rounded-lg&quot;&gt;
        &lt;div className=&quot;flex items-center gap-3&quot;&gt;
          &lt;div className=&quot;w-10 h-10 bg-muted rounded-lg flex items-center justify-center text-sm&quot;&gt;
            {inv.item.category === &#39;HAT&#39; ? &#39;🎩&#39; :
              inv.item.category === &#39;CLOTHING&#39; ? &#39;👕&#39; :
                inv.item.category === &#39;ACCESSORY&#39; ? &#39;💎&#39; :
                  inv.item.category === &#39;TOOL&#39; ? &#39;🔧&#39; :
                    inv.item.category === &#39;MATERIAL&#39; ? &#39;⚡&#39; :
                      inv.item.category === &#39;CONSUMABLE&#39; ? &#39;🥤&#39; : &#39;📦&#39;}
          &lt;/div&gt;
          &lt;div className=&quot;flex-1&quot;&gt;
            &lt;div className=&quot;font-medium flex items-center gap-2&quot;&gt;
              {inv.item.name}
              {inv.isEquipped &amp;&amp; (
                &lt;span className=&quot;text-xs bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-100 px-1.5 py-0.5 rounded-full&quot;&gt;
                  Equipped
                &lt;/span&gt;
              )}
            &lt;/div&gt;
            &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;{inv.item.description}&lt;/div&gt;

            {/* Show consumable effects */}
            {isConsumable &amp;&amp; (energyEffect &gt; 0 || healthEffect &gt; 0) &amp;&amp; (
              &lt;div className=&quot;text-xs text-green-600 mt-1 flex items-center gap-2&quot;&gt;
                {energyEffect &gt; 0 &amp;&amp; (
                  &lt;span className=&quot;flex items-center gap-1&quot;&gt;
                    &lt;Zap className=&quot;w-3 h-3&quot; /&gt;
                    +{energyEffect}
                  &lt;/span&gt;
                )}
                {healthEffect &gt; 0 &amp;&amp; (
                  &lt;span className=&quot;flex items-center gap-1&quot;&gt;
                    &lt;Heart className=&quot;w-3 h-3&quot; /&gt;
                    +{healthEffect}
                  &lt;/span&gt;
                )}
              &lt;/div&gt;
            )}

            &lt;div className=&quot;text-xs text-muted-foreground capitalize mt-1&quot;&gt;
              {inv.item.rarity} • Qty: {inv.quantity}
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
          {/* Equipment Button */}
          {[&#39;HAT&#39;, &#39;CLOTHING&#39;, &#39;ACCESSORY&#39;, &#39;TOOL&#39;].includes(inv.item.category) &amp;&amp; (
            &lt;Button
              size=&quot;sm&quot;
              variant={inv.isEquipped ? &quot;default&quot; : &quot;outline&quot;}
              onClick={() =&gt; onEquipItem(inv.id, inv.isEquipped)}
              disabled={isLoading}
              className=&quot;text-xs px-2 py-1&quot;
            &gt;
              {isLoading ? (
                &lt;Loader2 className=&quot;w-3 h-3 animate-spin&quot; /&gt;
              ) : (
                inv.isEquipped ? &#39;Unequip&#39; : &#39;Equip&#39;
              )}
            &lt;/Button&gt;
          )}

          {/* Use Button for Consumables */}
          {isConsumable &amp;&amp; (
            &lt;Button
              size=&quot;sm&quot;
              variant=&quot;outline&quot;
              onClick={() =&gt; onUseItem(
                inv.id,
                inv.item.name,
                inv.item.energyEffect,
                inv.item.healthEffect
              )}
              disabled={wouldBeWasted || isLoading}
              title={wouldBeWasted ?
                `Already at full ${wouldWasteEnergy ? &#39;energy&#39; : &#39;health&#39;}` :
                `Use ${inv.item.name}`
              }
              className=&quot;text-xs px-2 py-1&quot;
            &gt;
              {isLoading ? (
                &lt;Loader2 className=&quot;w-3 h-3 animate-spin&quot; /&gt;
              ) : wouldBeWasted ? &#39;Full&#39; : &#39;Use&#39;}
            &lt;/Button&gt;
          )}
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }

  return (
    &lt;div className=&quot;space-y-4&quot;&gt;
      &lt;div className=&quot;flex items-center justify-between&quot;&gt;
        &lt;h3 className=&quot;text-lg font-semibold flex items-center gap-2&quot;&gt;
          &lt;Backpack className=&quot;w-5 h-5&quot; /&gt;
          Inventory
        &lt;/h3&gt;
        &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;
          {character.inventory?.length || 0} items
        &lt;/div&gt;
      &lt;/div&gt;

      {/* Equipment Slots - only show on equipment tab or all tab */}
      {(activeTab === &#39;equipment&#39; || activeTab === &#39;all&#39;) &amp;&amp; equipmentItems.length &gt; 0 &amp;&amp; renderEquipmentSlots()}

      {/* Tab Navigation */}
      &lt;div className=&quot;overflow-x-auto border-b&quot;&gt;
        &lt;div className=&quot;flex min-w-max&quot;&gt;
          {[
            { id: &#39;all&#39; as const, label: &#39;All&#39;, count: character.inventory?.length || 0, icon: Package },
            { id: &#39;equipment&#39; as const, label: &#39;Equipment&#39;, count: equipmentItems.length, icon: Shield },
            { id: &#39;consumables&#39; as const, label: &#39;Consumables&#39;, count: consumableItems.length, icon: Zap },
            { id: &#39;materials&#39; as const, label: &#39;Materials&#39;, count: materialItems.length, icon: Gem },
          ].map(tab =&gt; {
            const IconComponent = tab.icon
            return (
              &lt;button
                key={tab.id}
                className={`py-2 px-4 text-sm font-medium border-b-2 transition-colors flex items-center gap-1 whitespace-nowrap ${activeTab === tab.id
                  ? &#39;border-primary text-primary bg-primary/5&#39;
                  : &#39;border-transparent text-muted-foreground hover:text-foreground&#39;
                  }`}
                onClick={() =&gt; setActiveTab(tab.id)}
              &gt;
                &lt;IconComponent className=&quot;w-4 h-4&quot; /&gt;
                &lt;span&gt;{tab.label}&lt;/span&gt;
                {tab.count &gt; 0 &amp;&amp; (
                  &lt;span className=&quot;ml-1 text-xs bg-muted text-muted-foreground px-1.5 py-0.5 rounded-full&quot;&gt;
                    {tab.count}
                  &lt;/span&gt;
                )}
              &lt;/button&gt;
            )
          })}
        &lt;/div&gt;
      &lt;/div&gt;

      {/* Inventory Items */}
      &lt;div className=&quot;space-y-2&quot;&gt;
        {getActiveItems().length &gt; 0 ? (
          getActiveItems().map(renderInventoryItem)
        ) : (
          &lt;div className=&quot;bg-muted/50 p-8 rounded-lg text-center text-muted-foreground&quot;&gt;
            &lt;Package className=&quot;w-12 h-12 mx-auto mb-2&quot; /&gt;
            {activeTab === &#39;all&#39; ? (
              &lt;&gt;Your bag is empty.&lt;br /&gt;Start mining or visit the market!&lt;/&gt;
            ) : (
              &lt;&gt;No {activeTab} items found.&lt;br /&gt;Try a different tab or go mining!&lt;/&gt;
            )}
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;Button onClick={onBack} variant=&quot;ghost&quot;&gt;
        &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
        Back
      &lt;/Button&gt;
    &lt;/div&gt;
  )
}
</content>
    </document>

    <document>
      <source>src/components/views/WorldMapView.tsx</source>
      <tags></tags>
      <metadata>
        <size>22798</size>
        <lastModified>2025-05-29T12:27:30.500Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/views</directory>
      </metadata>
      <content>import { useState, useRef, useEffect } from &#39;react&#39;
import { Tooltip, TooltipTrigger, TooltipContent } from &quot;@/components/ui/tooltip&quot;
import { Users, MapPin, Star } from &#39;lucide-react&#39;

interface Location {
  id: string
  name: string
  description?: string
  mapX?: number
  mapY?: number
  biome?: string
  difficulty: number
  playerCount: number
  locationType: string
  subLocations?: Location[]
  parentLocationId?: string
}

interface WorldMapViewProps {
  locations: Location[]
  onLocationSelect?: (location: Location) =&gt; void
  currentLocationId?: string
}

// Enhanced coordinate system - normalized to 0-100 for responsive scaling
const LOCATION_COORDINATES = {
  &#39;Mining Plains&#39;: { x: 20, y: 40 },
  &#39;Desert Outpost&#39;: { x: 80, y: 20 },
  &#39;Cyber City&#39;: { x: 60, y: 60 },
  &#39;The Glitch Wastes&#39;: { x: 85, y: 75 },
  &#39;Fungi Networks&#39;: { x: 15, y: 75 },
  &#39;Temporal Rift Zone&#39;: { x: 75, y: 45 },
  &#39;The Bone Markets&#39;: { x: 25, y: 15 },
  &#39;Static Fields&#39;: { x: 45, y: 25 },
}

// Sub-location offsets relative to parent (in percentage points)
const SUB_LOCATION_OFFSETS = {
  &#39;Rusty Pickaxe Inn&#39;: { x: -8, y: -5 },
  &#39;Crystal Caves&#39;: { x: 5, y: 8 },
  &#39;Central Exchange&#39;: { x: -6, y: -8 },
  &#39;The Glitch Club&#39;: { x: 8, y: 6 },
  &#39;Error 404 Oasis&#39;: { x: -10, y: 8 },
  &#39;Corrupted Data Mines&#39;: { x: 6, y: -6 },
  &#39;Spore Exchange&#39;: { x: -7, y: 10 },
  &#39;The Great Mycelium&#39;: { x: 9, y: -4 },
  &quot;Yesterday&#39;s Tomorrow&quot;: { x: -9, y: 7 },
  &#39;Clock Tower Ruins&#39;: { x: 7, y: -9 },
  &#39;Calcium Exchange&#39;: { x: -6, y: 9 },
  &#39;Ossuary Club&#39;: { x: 8, y: -5 },
  &#39;Channel 0&#39;: { x: -8, y: 8 },
  &#39;Dead Air Tavern&#39;: { x: 6, y: -7 },
}

function getBiomeColor(biome?: string) {
  switch (biome) {
    case &#39;plains&#39;: return &#39;#eee&#39;
    case &#39;desert&#39;: return &#39;#ddd&#39;
    case &#39;urban&#39;: return &#39;#4a90e2&#39;
    case &#39;digital&#39;: return &#39;#ff6b9d&#39;
    case &#39;underground&#39;: return &#39;#8b4513&#39;
    case &#39;temporal&#39;: return &#39;#9370db&#39;
    case &#39;ossuary&#39;: return &#39;#dcdcdc&#39;
    case &#39;electromagnetic&#39;: return &#39;#00ffff&#39;
    default: return &#39;#888888&#39;
  }
}

function getDifficultyIcon(difficulty: number) {
  if (difficulty &lt;= 2) return &#39;🟢&#39;
  if (difficulty &lt;= 4) return &#39;🟡&#39;
  return &#39;🔴&#39;
}

export function WorldMapView({ locations, onLocationSelect, currentLocationId }: WorldMapViewProps) {
  const [mapDimensions, setMapDimensions] = useState({ width: 800, height: 600 })
  const mapRef = useRef&lt;HTMLDivElement&gt;(null)

  useEffect(() =&gt; {
    const updateDimensions = () =&gt; {
      if (mapRef.current) {
        const container = mapRef.current.parentElement
        if (container) {
          const width = Math.min(container.clientWidth - 32, 1000) // Max width with padding
          const height = Math.max(width * 0.6, 400) // Maintain aspect ratio with minimum height
          setMapDimensions({ width, height })
        }
      }
    }

    updateDimensions()
    window.addEventListener(&#39;resize&#39;, updateDimensions)
    return () =&gt; window.removeEventListener(&#39;resize&#39;, updateDimensions)
  }, [])

  // Separate parent and child locations
  const parentLocations = locations.filter(loc =&gt; !loc.parentLocationId)

  const getLocationPosition = (location: Location) =&gt; {
    const coords = LOCATION_COORDINATES[location.name as keyof typeof LOCATION_COORDINATES]
    if (coords) {
      return {
        x: (coords.x / 100) * mapDimensions.width,
        y: (coords.y / 100) * mapDimensions.height
      }
    }

    // Fallback to original coordinates if available
    if (location.mapX &amp;&amp; location.mapY) {
      return {
        x: Math.min(location.mapX, mapDimensions.width - 20),
        y: Math.min(location.mapY, mapDimensions.height - 20)
      }
    }

    // Random fallback
    return {
      x: Math.random() * (mapDimensions.width - 40) + 20,
      y: Math.random() * (mapDimensions.height - 40) + 20
    }
  }

  const getSubLocationPosition = (subLocation: Location, parentPosition: { x: number, y: number }) =&gt; {
    const offset = SUB_LOCATION_OFFSETS[subLocation.name as keyof typeof SUB_LOCATION_OFFSETS]
    if (offset) {
      return {
        x: parentPosition.x + (offset.x / 100) * mapDimensions.width,
        y: parentPosition.y + (offset.y / 100) * mapDimensions.height
      }
    }

    // Fallback: random position around parent
    const angle = Math.random() * 2 * Math.PI
    const distance = 40 + Math.random() * 20
    return {
      x: parentPosition.x + Math.cos(angle) * distance,
      y: parentPosition.y + Math.sin(angle) * distance
    }
  }

  const renderConnectingLine = (parent: { x: number, y: number }, child: { x: number, y: number }) =&gt; (
    &lt;line
      key={`line-${parent.x}-${parent.y}-${child.x}-${child.y}`}
      x1={parent.x}
      y1={parent.y}
      x2={child.x}
      y2={child.y}
      stroke=&quot;rgba(148, 163, 184, 0.4)&quot;
      strokeWidth=&quot;2&quot;
      strokeDasharray=&quot;4,4&quot;
    /&gt;
  )

  // Custom landmass shapes for each major location
  const getLandmassPath = (locationName: string, position: { x: number, y: number }) =&gt; {
    const { x, y } = position
    const scale = 1.2 // Make landmasses a bit larger

    switch (locationName) {
      case &#39;Mining Plains&#39;:
        // Rolling hills shape
        return `M ${x - 40 * scale} ${y + 10 * scale} 
                Q ${x - 30 * scale} ${y - 20 * scale} ${x - 10 * scale} ${y - 15 * scale}
                Q ${x + 5 * scale} ${y - 25 * scale} ${x + 25 * scale} ${y - 10 * scale}
                Q ${x + 35 * scale} ${y + 5 * scale} ${x + 30 * scale} ${y + 20 * scale}
                Q ${x + 10 * scale} ${y + 25 * scale} ${x - 15 * scale} ${y + 15 * scale}
                Q ${x - 35 * scale} ${y + 20 * scale} ${x - 40 * scale} ${y + 10 * scale} Z`

      case &#39;Desert Outpost&#39;:
        // Jagged desert shape
        return `M ${x - 35 * scale} ${y - 5 * scale}
                L ${x - 20 * scale} ${y - 25 * scale}
                L ${x - 5 * scale} ${y - 20 * scale}
                L ${x + 10 * scale} ${y - 30 * scale}
                L ${x + 30 * scale} ${y - 15 * scale}
                L ${x + 35 * scale} ${y + 5 * scale}
                L ${x + 25 * scale} ${y + 20 * scale}
                L ${x + 5 * scale} ${y + 25 * scale}
                L ${x - 20 * scale} ${y + 15 * scale}
                L ${x - 35 * scale} ${y - 5 * scale} Z`

      case &#39;Cyber City&#39;:
        // Geometric city shape
        return `M ${x - 30 * scale} ${y - 20 * scale}
                L ${x - 15 * scale} ${y - 25 * scale}
                L ${x + 15 * scale} ${y - 25 * scale}
                L ${x + 30 * scale} ${y - 20 * scale}
                L ${x + 35 * scale} ${y - 5 * scale}
                L ${x + 30 * scale} ${y + 15 * scale}
                L ${x + 10 * scale} ${y + 25 * scale}
                L ${x - 10 * scale} ${y + 25 * scale}
                L ${x - 30 * scale} ${y + 15 * scale}
                L ${x - 35 * scale} ${y - 5 * scale}
                L ${x - 30 * scale} ${y - 20 * scale} Z`

      case &#39;The Glitch Wastes&#39;:
        // Fragmented, corrupted shape
        return `M ${x - 25 * scale} ${y - 15 * scale}
                L ${x - 10 * scale} ${y - 30 * scale}
                L ${x + 5 * scale} ${y - 25 * scale}
                L ${x + 20 * scale} ${y - 35 * scale}
                L ${x + 35 * scale} ${y - 10 * scale}
                L ${x + 30 * scale} ${y + 10 * scale}
                L ${x + 15 * scale} ${y + 25 * scale}
                L ${x - 5 * scale} ${y + 30 * scale}
                L ${x - 25 * scale} ${y + 20 * scale}
                L ${x - 35 * scale} ${y + 5 * scale}
                L ${x - 25 * scale} ${y - 15 * scale} Z`

      case &#39;Fungi Networks&#39;:
        // Organic, mushroom-like shape
        return `M ${x - 20 * scale} ${y - 10 * scale}
                Q ${x - 35 * scale} ${y - 20 * scale} ${x - 30 * scale} ${y - 5 * scale}
                Q ${x - 40 * scale} ${y + 10 * scale} ${x - 25 * scale} ${y + 15 * scale}
                Q ${x - 15 * scale} ${y + 30 * scale} ${x + 5 * scale} ${y + 25 * scale}
                Q ${x + 25 * scale} ${y + 20 * scale} ${x + 30 * scale} ${y + 5 * scale}
                Q ${x + 35 * scale} ${y - 15 * scale} ${x + 15 * scale} ${y - 20 * scale}
                Q ${x - 5 * scale} ${y - 25 * scale} ${x - 20 * scale} ${y - 10 * scale} Z`

      case &#39;Temporal Rift Zone&#39;:
        // Twisted, time-distorted shape
        return `M ${x - 30 * scale} ${y - 10 * scale}
                Q ${x - 20 * scale} ${y - 30 * scale} ${x + 5 * scale} ${y - 25 * scale}
                Q ${x + 25 * scale} ${y - 35 * scale} ${x + 35 * scale} ${y - 5 * scale}
                Q ${x + 40 * scale} ${y + 15 * scale} ${x + 20 * scale} ${y + 25 * scale}
                Q ${x - 5 * scale} ${y + 35 * scale} ${x - 25 * scale} ${y + 20 * scale}
                Q ${x - 40 * scale} ${y + 5 * scale} ${x - 30 * scale} ${y - 10 * scale} Z`

      case &#39;The Bone Markets&#39;:
        // Skull-like shape
        return `M ${x - 25 * scale} ${y - 20 * scale}
                Q ${x - 35 * scale} ${y - 25 * scale} ${x - 30 * scale} ${y - 5 * scale}
                Q ${x - 35 * scale} ${y + 15 * scale} ${x - 15 * scale} ${y + 25 * scale}
                L ${x + 15 * scale} ${y + 25 * scale}
                Q ${x + 35 * scale} ${y + 15 * scale} ${x + 30 * scale} ${y - 5 * scale}
                Q ${x + 35 * scale} ${y - 25 * scale} ${x + 25 * scale} ${y - 20 * scale}
                Q ${x} ${y - 30 * scale} ${x - 25 * scale} ${y - 20 * scale} Z`

      case &#39;Static Fields&#39;:
        // Jagged, electric shape
        return `M ${x - 30 * scale} ${y - 15 * scale}
                L ${x - 15 * scale} ${y - 30 * scale}
                L ${x - 5 * scale} ${y - 20 * scale}
                L ${x + 10 * scale} ${y - 35 * scale}
                L ${x + 25 * scale} ${y - 25 * scale}
                L ${x + 35 * scale} ${y - 10 * scale}
                L ${x + 25 * scale} ${y + 5 * scale}
                L ${x + 35 * scale} ${y + 20 * scale}
                L ${x + 15 * scale} ${y + 30 * scale}
                L ${x - 5 * scale} ${y + 20 * scale}
                L ${x - 20 * scale} ${y + 25 * scale}
                L ${x - 35 * scale} ${y + 10 * scale}
                L ${x - 30 * scale} ${y - 15 * scale} Z`

      default:
        // Fallback generic landmass
        return `M ${x - 30 * scale} ${y - 15 * scale}
                Q ${x - 15 * scale} ${y - 25 * scale} ${x + 15 * scale} ${y - 25 * scale}
                Q ${x + 30 * scale} ${y - 15 * scale} ${x + 30 * scale} ${y + 15 * scale}
                Q ${x + 15 * scale} ${y + 25 * scale} ${x - 15 * scale} ${y + 25 * scale}
                Q ${x - 30 * scale} ${y + 15 * scale} ${x - 30 * scale} ${y - 15 * scale} Z`
    }
  }

  const renderLocationNode = (
    location: Location,
    position: { x: number, y: number },
    isParent: boolean = false
  ) =&gt; {
    const isCurrentLocation = location.id === currentLocationId
    const color = getBiomeColor(location.biome)

    if (isParent) {
      // Render landmass for major locations
      const landmassPath = getLandmassPath(location.name, position)

      return (
        &lt;g key={location.id}&gt;
          {/* Glow effect for current location */}
          {isCurrentLocation &amp;&amp; (
            &lt;path
              d={landmassPath}
              fill=&quot;none&quot;
              stroke=&quot;#fbbf24&quot;
              strokeWidth=&quot;4&quot;
              opacity=&quot;0.8&quot;
              filter=&quot;blur(2px)&quot;
            /&gt;
          )}

          {/* Main landmass */}
          &lt;path
            d={landmassPath}
            fill={color}
            stroke={isCurrentLocation ? &quot;#fbbf24&quot; : &quot;#374151&quot;}
            strokeWidth={isCurrentLocation ? 3 : 2}
            className=&quot;cursor-pointer hover:stroke-blue-400 transition-colors&quot;
            onClick={() =&gt; onLocationSelect?.(location)}
            opacity=&quot;0.9&quot;
          /&gt;

          {/* Subtle inner shadow for depth */}
          &lt;path
            d={landmassPath}
            fill=&quot;none&quot;
            stroke=&quot;rgba(0,0,0,0.2)&quot;
            strokeWidth=&quot;1&quot;
            strokeDasharray=&quot;2,2&quot;
            opacity=&quot;0.3&quot;
          /&gt;

          {/* Location name label */}
          &lt;text
            x={position.x}
            y={position.y - 35}
            textAnchor=&quot;middle&quot;
            fontSize=&quot;12&quot;
            fontWeight=&quot;bold&quot;
            fill=&quot;#374151&quot;
            className=&quot;pointer-events-none drop-shadow-sm&quot;
          &gt;
            {location.name}
          &lt;/text&gt;

          {/* Difficulty indicator */}
          &lt;circle
            cx={position.x + 35}
            cy={position.y - 25}
            r={10}
            fill=&quot;white&quot;
            stroke=&quot;#374151&quot;
            strokeWidth=&quot;2&quot;
          /&gt;
          &lt;text
            x={position.x + 35}
            y={position.y - 25}
            textAnchor=&quot;middle&quot;
            dominantBaseline=&quot;central&quot;
            fontSize=&quot;12&quot;
            className=&quot;pointer-events-none&quot;
          &gt;
            {getDifficultyIcon(location.difficulty)}
          &lt;/text&gt;

          {/* Player count indicator */}
          {location.playerCount &gt; 0 &amp;&amp; (
            &lt;&gt;
              &lt;circle
                cx={position.x - 35}
                cy={position.y + 25}
                r={12}
                fill=&quot;#3b82f6&quot;
                stroke=&quot;white&quot;
                strokeWidth=&quot;2&quot;
              /&gt;
              &lt;text
                x={position.x - 35}
                y={position.y + 25}
                textAnchor=&quot;middle&quot;
                dominantBaseline=&quot;central&quot;
                fontSize=&quot;10&quot;
                fill=&quot;white&quot;
                className=&quot;font-bold pointer-events-none&quot;
              &gt;
                {location.playerCount}
              &lt;/text&gt;
            &lt;/&gt;
          )}
        &lt;/g&gt;
      )
    } else {
      // Render simple square for sub-locations
      const squareSize = 16

      return (
        &lt;g key={location.id}&gt;
          {/* Glow effect for current location */}
          {isCurrentLocation &amp;&amp; (
            &lt;rect
              x={position.x - squareSize - 4}
              y={position.y - squareSize - 4}
              width={(squareSize + 4) * 2}
              height={(squareSize + 4) * 2}
              fill=&quot;none&quot;
              stroke=&quot;#fbbf24&quot;
              strokeWidth=&quot;3&quot;
              opacity=&quot;0.6&quot;
              rx=&quot;2&quot;
            /&gt;
          )}

          {/* Main square */}
          &lt;rect
            x={position.x - squareSize}
            y={position.y - squareSize}
            width={squareSize * 2}
            height={squareSize * 2}
            fill={color}
            stroke={isCurrentLocation ? &quot;#fbbf24&quot; : &quot;#374151&quot;}
            strokeWidth={isCurrentLocation ? 1 : 0}
            rx=&quot;2&quot;
            className=&quot;cursor-pointer hover:stroke-blue-400 transition-colors&quot;
            onClick={() =&gt; onLocationSelect?.(location)}
          /&gt;

          {/* Difficulty indicator */}
          &lt;circle
            cx={position.x + squareSize + 8}
            cy={position.y - squareSize - 8}
            r={4}
            fill=&quot;white&quot;
            stroke=&quot;#374151&quot;
            strokeWidth=&quot;0&quot;
          /&gt;
          &lt;text
            x={position.x + squareSize + 8}
            y={position.y - squareSize - 8}
            textAnchor=&quot;middle&quot;
            dominantBaseline=&quot;central&quot;
            fontSize=&quot;10&quot;
            className=&quot;pointer-events-none&quot;
          &gt;
            {getDifficultyIcon(location.difficulty)}
          &lt;/text&gt;

          {/* Player count indicator */}
          {location.playerCount &gt; 0 &amp;&amp; (
            &lt;&gt;
              &lt;circle
                cx={position.x - squareSize - 8}
                cy={position.y + squareSize + 8}
                r={8}
                fill=&quot;#3b82f6&quot;
                stroke=&quot;white&quot;
                strokeWidth=&quot;2&quot;
              /&gt;
              &lt;text
                x={position.x - squareSize - 8}
                y={position.y + squareSize + 8}
                textAnchor=&quot;middle&quot;
                dominantBaseline=&quot;central&quot;
                fontSize=&quot;8&quot;
                fill=&quot;white&quot;
                className=&quot;font-bold pointer-events-none&quot;
              &gt;
                {location.playerCount}
              &lt;/text&gt;
            &lt;/&gt;
          )}
        &lt;/g&gt;
      )
    }
  }

  return (
    &lt;div className=&quot;w-full&quot;&gt;
      &lt;div
        ref={mapRef}
        className=&quot;relative w-full bg-gradient-to-br from-slate-100 to-slate-200 dark:from-slate-800 dark:to-slate-900 rounded-lg border overflow-hidden&quot;
        style={{ height: mapDimensions.height }}
      &gt;
        {/* Background pattern */}
        &lt;div
          className=&quot;absolute inset-0 opacity-10&quot;
          style={{
            backgroundImage: `radial-gradient(circle at 2px 2px, rgba(148, 163, 184, 0.3) 1px, transparent 0)`,
            backgroundSize: &#39;20px 20px&#39;
          }}
        /&gt;

        &lt;svg
          width={mapDimensions.width}
          height={mapDimensions.height}
          className=&quot;absolute inset-0&quot;
        &gt;
          &lt;defs&gt;
            &lt;filter id=&quot;glow&quot;&gt;
              &lt;feGaussianBlur stdDeviation=&quot;3&quot; result=&quot;coloredBlur&quot; /&gt;
              &lt;feMerge&gt;
                &lt;feMergeNode in=&quot;coloredBlur&quot; /&gt;
                &lt;feMergeNode in=&quot;SourceGraphic&quot; /&gt;
              &lt;/feMerge&gt;
            &lt;/filter&gt;
          &lt;/defs&gt;

          {/* Connection lines */}
          {parentLocations.map(parent =&gt; {
            const parentPos = getLocationPosition(parent)
            return parent.subLocations?.map(child =&gt; {
              const childPos = getSubLocationPosition(child, parentPos)
              return renderConnectingLine(parentPos, childPos)
            })
          })}

          {/* Parent location nodes */}
          {parentLocations.map(location =&gt; {
            const position = getLocationPosition(location)
            return (
              &lt;Tooltip key={location.id}&gt;
                &lt;TooltipTrigger asChild&gt;
                  {renderLocationNode(location, position, true)}
                &lt;/TooltipTrigger&gt;
                &lt;TooltipContent side=&quot;top&quot; className=&quot;max-w-xs&quot;&gt;
                  &lt;div className=&quot;space-y-1&quot;&gt;
                    &lt;div className=&quot;font-semibold flex items-center gap-2&quot;&gt;
                      &lt;MapPin className=&quot;w-4 h-4&quot; /&gt;
                      {location.name}
                    &lt;/div&gt;
                    {location.description &amp;&amp; (
                      &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;
                        {location.description}
                      &lt;/div&gt;
                    )}
                    &lt;div className=&quot;flex items-center gap-4 text-xs&quot;&gt;
                      &lt;span className=&quot;flex items-center gap-1&quot;&gt;
                        &lt;Star className=&quot;w-3 h-3&quot; /&gt;
                        Level {location.difficulty}
                      &lt;/span&gt;
                      &lt;span className=&quot;flex items-center gap-1&quot;&gt;
                        &lt;Users className=&quot;w-3 h-3&quot; /&gt;
                        {location.playerCount} players
                      &lt;/span&gt;
                    &lt;/div&gt;
                    {location.biome &amp;&amp; (
                      &lt;div className=&quot;text-xs capitalize&quot;&gt;
                        Biome: {location.biome}
                      &lt;/div&gt;
                    )}
                    {location.subLocations &amp;&amp; location.subLocations.length &gt; 0 &amp;&amp; (
                      &lt;div className=&quot;text-xs&quot;&gt;
                        Contains {location.subLocations.length} sub-location{location.subLocations.length !== 1 ? &#39;s&#39; : &#39;&#39;}
                      &lt;/div&gt;
                    )}
                  &lt;/div&gt;
                &lt;/TooltipContent&gt;
              &lt;/Tooltip&gt;
            )
          })}

          {/* Child location nodes */}
          {parentLocations.map(parent =&gt; {
            const parentPos = getLocationPosition(parent)
            return parent.subLocations?.map(child =&gt; {
              const childPos = getSubLocationPosition(child, parentPos)
              return (
                &lt;Tooltip key={child.id}&gt;
                  &lt;TooltipTrigger asChild&gt;
                    {renderLocationNode(child, childPos, false)}
                  &lt;/TooltipTrigger&gt;
                  &lt;TooltipContent side=&quot;top&quot; className=&quot;max-w-xs&quot;&gt;
                    &lt;div className=&quot;space-y-1&quot;&gt;
                      &lt;div className=&quot;font-semibold flex items-center gap-2&quot;&gt;
                        &lt;MapPin className=&quot;w-4 h-4&quot; /&gt;
                        {child.name}
                      &lt;/div&gt;
                      {child.description &amp;&amp; (
                        &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;
                          {child.description}
                        &lt;/div&gt;
                      )}
                      &lt;div className=&quot;flex items-center gap-4 text-xs&quot;&gt;
                        &lt;span className=&quot;flex items-center gap-1&quot;&gt;
                          &lt;Star className=&quot;w-3 h-3&quot; /&gt;
                          Level {child.difficulty}
                        &lt;/span&gt;
                        &lt;span className=&quot;flex items-center gap-1&quot;&gt;
                          &lt;Users className=&quot;w-3 h-3&quot; /&gt;
                          {child.playerCount} players
                        &lt;/span&gt;
                      &lt;/div&gt;
                      &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;
                        Part of {parent.name}
                      &lt;/div&gt;
                    &lt;/div&gt;
                  &lt;/TooltipContent&gt;
                &lt;/Tooltip&gt;
              )
            })
          })}
        &lt;/svg&gt;

        {/* Legend */}
        &lt;div className=&quot;absolute bottom-4 left-4 bg-white/90 dark:bg-slate-800/90 rounded-lg p-3 text-xs space-y-2 backdrop-blur-sm&quot;&gt;
          &lt;div className=&quot;font-semibold&quot;&gt;Legend&lt;/div&gt;
          &lt;div className=&quot;flex items-center gap-2&quot;&gt;
            &lt;svg width=&quot;20&quot; height=&quot;12&quot; className=&quot;flex-shrink-0&quot;&gt;
              &lt;path
                d=&quot;M 2 6 Q 6 2 10 3 Q 14 4 18 6 Q 16 8 12 9 Q 8 10 2 6 Z&quot;
                fill=&quot;#7ec850&quot;
                stroke=&quot;#374151&quot;
                strokeWidth=&quot;1&quot;
              /&gt;
            &lt;/svg&gt;
            &lt;span&gt;Major Region&lt;/span&gt;
          &lt;/div&gt;
          &lt;div className=&quot;flex items-center gap-2&quot;&gt;
            &lt;div className=&quot;w-4 h-4 bg-gray-400 border border-gray-600 rounded-sm flex-shrink-0&quot; /&gt;
            &lt;span&gt;Sub-Location&lt;/span&gt;
          &lt;/div&gt;
          &lt;div className=&quot;flex items-center gap-2&quot;&gt;
            &lt;span&gt;🟢🟡🔴&lt;/span&gt;
            &lt;span&gt;Difficulty Level&lt;/span&gt;
          &lt;/div&gt;
          &lt;div className=&quot;flex items-center gap-2&quot;&gt;
            &lt;div className=&quot;w-4 h-4 rounded-full bg-blue-500 text-white text-[8px] flex items-center justify-center font-bold flex-shrink-0&quot;&gt;5&lt;/div&gt;
            &lt;span&gt;Players Online&lt;/span&gt;
          &lt;/div&gt;
          &lt;div className=&quot;flex items-center gap-2&quot;&gt;
            &lt;div className=&quot;w-8 h-1 border-t-2 border-dashed border-gray-400 flex-shrink-0&quot; /&gt;
            &lt;span&gt;Connection&lt;/span&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}
</content>
    </document>

    <document>
      <source>src/components/views/index.ts</source>
      <tags></tags>
      <metadata>
        <size>211</size>
        <lastModified>2025-05-29T11:12:15.786Z</lastModified>
        <extension>ts</extension>
        <directory>src/components/views</directory>
      </metadata>
      <content>// src/components/views/index.ts
export { InventoryView } from &#39;./InventoryView&#39;
export { MarketView } from &#39;./MarketView&#39;
export { MiningView } from &#39;./MiningView&#39;
export { WorldMapView } from &#39;./WorldMapView&#39;
</content>
    </document>

    <document>
      <source>src/components/wallet-select-modal.tsx</source>
      <tags></tags>
      <metadata>
        <size>4486</size>
        <lastModified>2025-05-29T08:13:25.130Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>&quot;use client&quot;;

import React from &#39;react&#39;;
import { useWallet } from &#39;@solana/wallet-adapter-react&#39;;
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from &#39;@/components/ui/dialog&#39;;
import { Button } from &#39;@/components/ui/button&#39;;
import { ScrollArea } from &#39;@/components/ui/scroll-area&#39;;
import { Badge } from &#39;@/components/ui/badge&#39;;
import { Avatar, AvatarFallback, AvatarImage } from &#39;@/components/ui/avatar&#39;;
import { ExternalLink, Wallet } from &#39;lucide-react&#39;;
import { WalletReadyState } from &#39;@solana/wallet-adapter-base&#39;;
import { toast } from &#39;sonner&#39;;

interface WalletSelectModalProps {
  open: boolean;
  onOpenChange: (open: boolean) =&gt; void;
}

export function WalletSelectModal({ open, onOpenChange }: WalletSelectModalProps) {
  const { wallets, select, connect } = useWallet();

  const handleWalletSelect = async (walletName: string) =&gt; {
    try {
      select(walletName);
      await connect();
      onOpenChange(false);
    } catch (error) {
      toast.error(&#39;Failed to connect to wallet&#39;);
    }
  };

  const installedWallets = wallets.filter(
    (wallet) =&gt; wallet.readyState === WalletReadyState.Installed
  );
  
  const notDetectedWallets = wallets.filter(
    (wallet) =&gt; wallet.readyState === WalletReadyState.NotDetected
  );

  return (
    &lt;Dialog open={open} onOpenChange={onOpenChange}&gt;
      &lt;DialogContent className=&quot;sm:max-w-md&quot;&gt;
        &lt;DialogHeader&gt;
          &lt;DialogTitle className=&quot;flex items-center gap-2&quot;&gt;
            &lt;Wallet className=&quot;w-5 h-5&quot; /&gt;
            Connect Wallet
          &lt;/DialogTitle&gt;
          &lt;DialogDescription&gt;
            Choose a wallet to connect to this application.
          &lt;/DialogDescription&gt;
        &lt;/DialogHeader&gt;
        
        &lt;ScrollArea className=&quot;max-h-[400px]&quot;&gt;
          &lt;div className=&quot;space-y-2&quot;&gt;
            {installedWallets.length &gt; 0 &amp;&amp; (
              &lt;div className=&quot;space-y-2&quot;&gt;
                &lt;h4 className=&quot;text-sm font-medium text-muted-foreground&quot;&gt;Installed Wallets&lt;/h4&gt;
                {installedWallets.map((wallet) =&gt; (
                  &lt;Button
                    key={wallet.adapter.name}
                    variant=&quot;outline&quot;
                    className=&quot;w-full justify-start h-auto p-4&quot;
                    onClick={() =&gt; handleWalletSelect(wallet.adapter.name)}
                  &gt;
                    &lt;Avatar className=&quot;w-8 h-8 mr-3&quot;&gt;
                      &lt;AvatarImage src={wallet.adapter.icon} alt={wallet.adapter.name} /&gt;
                      &lt;AvatarFallback&gt;
                        &lt;Wallet className=&quot;w-4 h-4&quot; /&gt;
                      &lt;/AvatarFallback&gt;
                    &lt;/Avatar&gt;
                    &lt;div className=&quot;flex-1 text-left&quot;&gt;
                      &lt;div className=&quot;flex items-center justify-between&quot;&gt;
                        &lt;span className=&quot;font-medium&quot;&gt;{wallet.adapter.name}&lt;/span&gt;
                        &lt;Badge variant=&quot;default&quot; className=&quot;text-xs&quot;&gt;Installed&lt;/Badge&gt;
                      &lt;/div&gt;
                    &lt;/div&gt;
                  &lt;/Button&gt;
                ))}
              &lt;/div&gt;
            )}
            
            {notDetectedWallets.length &gt; 0 &amp;&amp; (
              &lt;div className=&quot;space-y-2&quot;&gt;
                &lt;h4 className=&quot;text-sm font-medium text-muted-foreground&quot;&gt;Available Wallets&lt;/h4&gt;
                {notDetectedWallets.map((wallet) =&gt; (
                  &lt;div
                    key={wallet.adapter.name}
                    className=&quot;flex items-center justify-between p-4 border rounded-lg&quot;
                  &gt;
                    &lt;div className=&quot;flex items-center&quot;&gt;
                      &lt;Avatar className=&quot;w-8 h-8 mr-3&quot;&gt;
                        &lt;AvatarImage src={wallet.adapter.icon} alt={wallet.adapter.name} /&gt;
                        &lt;AvatarFallback&gt;
                          &lt;Wallet className=&quot;w-4 h-4&quot; /&gt;
                        &lt;/AvatarFallback&gt;
                      &lt;/Avatar&gt;
                      &lt;span className=&quot;font-medium&quot;&gt;{wallet.adapter.name}&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;Button
                      variant=&quot;outline&quot;
                      size=&quot;sm&quot;
                      onClick={() =&gt; window.open(wallet.adapter.url, &#39;_blank&#39;)}
                    &gt;
                      &lt;ExternalLink className=&quot;w-4 h-4 mr-1&quot; /&gt;
                      Install
                    &lt;/Button&gt;
                  &lt;/div&gt;
                ))}
              &lt;/div&gt;
            )}
          &lt;/div&gt;
        &lt;/ScrollArea&gt;
      &lt;/DialogContent&gt;
    &lt;/Dialog&gt;
  );
}</content>
    </document>

    <document>
      <source>src/components/theme-provider.tsx</source>
      <tags></tags>
      <metadata>
        <size>1578</size>
        <lastModified>2025-05-29T00:31:34.688Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>import { createContext, useContext, useEffect, useState } from &quot;react&quot;

type Theme = &quot;dark&quot; | &quot;light&quot; | &quot;system&quot;

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  storageKey?: string
}

type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) =&gt; void
}

const initialState: ThemeProviderState = {
  theme: &quot;system&quot;,
  setTheme: () =&gt; null,
}

const ThemeProviderContext = createContext&lt;ThemeProviderState&gt;(initialState)

export function ThemeProvider({
  children,
  defaultTheme = &quot;system&quot;,
  storageKey = &quot;vite-ui-theme&quot;,
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState&lt;Theme&gt;(
    () =&gt; (localStorage.getItem(storageKey) as Theme) || defaultTheme
  )

  useEffect(() =&gt; {
    const root = window.document.documentElement

    root.classList.remove(&quot;light&quot;, &quot;dark&quot;)

    if (theme === &quot;system&quot;) {
      const systemTheme = window.matchMedia(&quot;(prefers-color-scheme: dark)&quot;)
        .matches
        ? &quot;dark&quot;
        : &quot;light&quot;

      root.classList.add(systemTheme)
      return
    }

    root.classList.add(theme)
  }, [theme])

  const value = {
    theme,
    setTheme: (theme: Theme) =&gt; {
      localStorage.setItem(storageKey, theme)
      setTheme(theme)
    },
  }

  return (
    &lt;ThemeProviderContext.Provider {...props} value={value}&gt;
      {children}
    &lt;/ThemeProviderContext.Provider&gt;
  )
}

export const useTheme = () =&gt; {
  const context = useContext(ThemeProviderContext)

  if (context === undefined)
    throw new Error(&quot;useTheme must be used within a ThemeProvider&quot;)

  return context
}
</content>
    </document>

    <document>
      <source>src/components/wallet-connect-button.tsx</source>
      <tags></tags>
      <metadata>
        <size>4197</size>
        <lastModified>2025-05-29T08:13:24.988Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>&quot;use client&quot;;

import React, { useState } from &#39;react&#39;;
import { useWallet } from &#39;@solana/wallet-adapter-react&#39;;
import { Button } from &#39;@/components/ui/button&#39;;
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from &#39;@/components/ui/dropdown-menu&#39;;
import { Avatar, AvatarFallback, AvatarImage } from &#39;@/components/ui/avatar&#39;;
import { Badge } from &#39;@/components/ui/badge&#39;;
import { Copy, LogOut, Wallet, ChevronDown } from &#39;lucide-react&#39;;
import { toast } from &#39;sonner&#39;;
import { WalletSelectModal } from &#39;./wallet-select-modal&#39;;

interface WalletConnectButtonProps {
  className?: string;
}

export function WalletConnectButton({ className }: WalletConnectButtonProps) {
  const { publicKey, disconnect, wallet, connect, connecting, connected } = useWallet();
  const [showWalletSelect, setShowWalletSelect] = useState(false);

  const copyAddress = async () =&gt; {
    if (publicKey) {
      await navigator.clipboard.writeText(publicKey.toBase58());
      toast.success(&#39;Address copied to clipboard&#39;);
    }
  };

  const handleConnect = async () =&gt; {
    if (wallet) {
      try {
        await connect();
      } catch (error) {
        toast.error(&#39;Failed to connect wallet&#39;);
      }
    } else {
      setShowWalletSelect(true);
    }
  };

  if (!connected &amp;&amp; !connecting) {
    return (
      &lt;&gt;
        &lt;Button 
          onClick={handleConnect}
          disabled={connecting}
          className={className}
        &gt;
          &lt;Wallet className=&quot;w-4 h-4 mr-2&quot; /&gt;
          {wallet ? &#39;Connect&#39; : &#39;Select Wallet&#39;}
        &lt;/Button&gt;
        &lt;WalletSelectModal 
          open={showWalletSelect} 
          onOpenChange={setShowWalletSelect}
        /&gt;
      &lt;/&gt;
    );
  }

  if (connecting) {
    return (
      &lt;Button disabled className={className}&gt;
        &lt;div className=&quot;w-4 h-4 mr-2 animate-spin rounded-full border-2 border-current border-t-transparent&quot; /&gt;
        Connecting...
      &lt;/Button&gt;
    );
  }

  if (connected &amp;&amp; publicKey) {
    const truncatedAddress = `${publicKey.toBase58().slice(0, 4)}...${publicKey.toBase58().slice(-4)}`;

    return (
      &lt;DropdownMenu&gt;
        &lt;DropdownMenuTrigger asChild&gt;
          &lt;Button variant=&quot;outline&quot; className={`${className} flex items-center gap-2`}&gt;
            &lt;Avatar className=&quot;w-6 h-6&quot;&gt;
              &lt;AvatarImage src={wallet?.adapter.icon} alt={wallet?.adapter.name} /&gt;
              &lt;AvatarFallback&gt;
                &lt;Wallet className=&quot;w-3 h-3&quot; /&gt;
              &lt;/AvatarFallback&gt;
            &lt;/Avatar&gt;
            &lt;span className=&quot;font-mono&quot;&gt;{truncatedAddress}&lt;/span&gt;
            &lt;ChevronDown className=&quot;w-4 h-4&quot; /&gt;
          &lt;/Button&gt;
        &lt;/DropdownMenuTrigger&gt;
        &lt;DropdownMenuContent align=&quot;end&quot; className=&quot;w-64&quot;&gt;
          &lt;div className=&quot;px-2 py-1.5&quot;&gt;
            &lt;div className=&quot;flex items-center gap-2 mb-2&quot;&gt;
              &lt;Avatar className=&quot;w-8 h-8&quot;&gt;
                &lt;AvatarImage src={wallet?.adapter.icon} alt={wallet?.adapter.name} /&gt;
                &lt;AvatarFallback&gt;
                  &lt;Wallet className=&quot;w-4 h-4&quot; /&gt;
                &lt;/AvatarFallback&gt;
              &lt;/Avatar&gt;
              &lt;div&gt;
                &lt;p className=&quot;font-medium&quot;&gt;{wallet?.adapter.name}&lt;/p&gt;
                &lt;Badge variant=&quot;secondary&quot; className=&quot;text-xs&quot;&gt;
                  Connected
                &lt;/Badge&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;p className=&quot;text-sm text-muted-foreground font-mono break-all&quot;&gt;
              {publicKey.toBase58()}
            &lt;/p&gt;
          &lt;/div&gt;
          &lt;DropdownMenuSeparator /&gt;
          &lt;DropdownMenuItem onClick={copyAddress}&gt;
            &lt;Copy className=&quot;w-4 h-4 mr-2&quot; /&gt;
            Copy Address
          &lt;/DropdownMenuItem&gt;
          &lt;DropdownMenuItem onClick={() =&gt; setShowWalletSelect(true)}&gt;
            &lt;Wallet className=&quot;w-4 h-4 mr-2&quot; /&gt;
            Change Wallet
          &lt;/DropdownMenuItem&gt;
          &lt;DropdownMenuSeparator /&gt;
          &lt;DropdownMenuItem onClick={disconnect} className=&quot;text-destructive&quot;&gt;
            &lt;LogOut className=&quot;w-4 h-4 mr-2&quot; /&gt;
            Disconnect
          &lt;/DropdownMenuItem&gt;
        &lt;/DropdownMenuContent&gt;
      &lt;/DropdownMenu&gt;
    );
  }

  return null;
}</content>
    </document>

    <document>
      <source>src/components/mode-toggle.tsx</source>
      <tags></tags>
      <metadata>
        <size>1207</size>
        <lastModified>2025-05-29T00:32:40.806Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>import { Moon, Sun } from &quot;lucide-react&quot;

import { Button } from &quot;@/components/ui/button&quot;
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from &quot;@/components/ui/dropdown-menu&quot;
import { useTheme } from &quot;@/components/theme-provider&quot;

export function ModeToggle() {
  const { setTheme } = useTheme()

  return (
    &lt;DropdownMenu&gt;
      &lt;DropdownMenuTrigger asChild&gt;
        &lt;Button variant=&quot;outline&quot; size=&quot;icon&quot;&gt;
          &lt;Sun className=&quot;h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0&quot; /&gt;
          &lt;Moon className=&quot;absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100&quot; /&gt;
          &lt;span className=&quot;sr-only&quot;&gt;Toggle theme&lt;/span&gt;
        &lt;/Button&gt;
      &lt;/DropdownMenuTrigger&gt;
      &lt;DropdownMenuContent align=&quot;end&quot;&gt;
        &lt;DropdownMenuItem onClick={() =&gt; setTheme(&quot;light&quot;)}&gt;
          Light
        &lt;/DropdownMenuItem&gt;
        &lt;DropdownMenuItem onClick={() =&gt; setTheme(&quot;dark&quot;)}&gt;
          Dark
        &lt;/DropdownMenuItem&gt;
        &lt;DropdownMenuItem onClick={() =&gt; setTheme(&quot;system&quot;)}&gt;
          System
        &lt;/DropdownMenuItem&gt;
      &lt;/DropdownMenuContent&gt;
    &lt;/DropdownMenu&gt;
  )
}
</content>
    </document>

    <document>
      <source>src/components/wallet-provider.tsx</source>
      <tags></tags>
      <metadata>
        <size>1225</size>
        <lastModified>2025-05-29T08:13:24.629Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>&quot;use client&quot;;

import React, { useMemo } from &#39;react&#39;;
import { ConnectionProvider, WalletProvider } from &#39;@solana/wallet-adapter-react&#39;;
import { clusterApiUrl } from &#39;@solana/web3.js&#39;;
import { WalletAdapterNetwork } from &#39;@solana/wallet-adapter-base&#39;;
import {
  PhantomWalletAdapter,
  SolflareWalletAdapter,
  BackpackWalletAdapter,
  GlowWalletAdapter,
} from &#39;@solana/wallet-adapter-wallets&#39;;

interface SolanaWalletProviderProps {
  children: React.ReactNode;
  network?: WalletAdapterNetwork;
  endpoint?: string;
  autoConnect?: boolean;
}

export function SolanaWalletProvider({
  children,
  network = WalletAdapterNetwork.Devnet,
  endpoint,
  autoConnect = true,
}: SolanaWalletProviderProps) {
  const wallets = useMemo(
    () =&gt; [
      new PhantomWalletAdapter(),
      new SolflareWalletAdapter(),
      new BackpackWalletAdapter(),
      new GlowWalletAdapter(),
    ],
    []
  );

  const connectionEndpoint = useMemo(
    () =&gt; endpoint || clusterApiUrl(network),
    [network, endpoint]
  );

  return (
    &lt;ConnectionProvider endpoint={connectionEndpoint}&gt;
      &lt;WalletProvider wallets={wallets} autoConnect={autoConnect}&gt;
        {children}
      &lt;/WalletProvider&gt;
    &lt;/ConnectionProvider&gt;
  );
}</content>
    </document>

    <document>
      <source>src/lib/utils.ts</source>
      <tags></tags>
      <metadata>
        <size>166</size>
        <lastModified>2025-05-28T21:46:49.754Z</lastModified>
        <extension>ts</extension>
        <directory>src/lib</directory>
      </metadata>
      <content>import { clsx, type ClassValue } from &quot;clsx&quot;
import { twMerge } from &quot;tailwind-merge&quot;

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</content>
    </document>

    <document>
      <source>src/lib/layerResolver.ts</source>
      <tags></tags>
      <metadata>
        <size>8697</size>
        <lastModified>2025-05-29T02:27:27.011Z</lastModified>
        <extension>ts</extension>
        <directory>src/lib</directory>
      </metadata>
      <content>// src/utils/layerResolver.ts
export interface LayerConfig {
  type: &#39;background&#39; | &#39;base&#39; | &#39;clothing&#39; | &#39;accessory&#39; | &#39;overlay&#39;
  name: string
  zIndex: number
  visible: boolean
}

export interface VisibilityRules {
  [key: string]: {
    blocks?: string[] // What this layer blocks
    blockedBy?: string[] // What blocks this layer
    requires?: string[] // What this layer requires to be visible
  }
}

// Asset URL resolver
export function getAssetUrl(type: string, name: string): string {
  return `https://earth.ndao.computer/layers/${type}s/${name}.png`
}

// Layer visibility rules - customize based on your game logic
export const LAYER_VISIBILITY_RULES: VisibilityRules = {
  // Clothing rules
  &#39;cyber-jacket&#39;: {
    blocks: [&#39;parka-yellow&#39;, &#39;miners-jacket&#39;], // Can&#39;t wear multiple jackets
    blockedBy: [],
  },
  &#39;parka-yellow&#39;: {
    blocks: [&#39;cyber-jacket&#39;, &#39;miners-jacket&#39;],
    blockedBy: [],
  },
  &#39;miners-jacket&#39;: {
    blocks: [&#39;cyber-jacket&#39;, &#39;parka-yellow&#39;],
    blockedBy: [],
  },

  // Accessory rules
  sunglasses: {
    blocks: [], // Sunglasses don&#39;t block other accessories
    blockedBy: [],
  },
  &#39;gold-chain&#39;: {
    blocks: [],
    blockedBy: [],
  },
  &#39;lucky-charm&#39;: {
    blocks: [],
    blockedBy: [],
  },

  // Overlay rules
  &#39;glow-red&#39;: {
    blocks: [&#39;rain-fog&#39;], // Glow effects might override weather
    blockedBy: [],
  },
  &#39;rain-fog&#39;: {
    blocks: [],
    blockedBy: [&#39;glow-red&#39;],
  },
  &#39;glitch-vibe&#39;: {
    blocks: [],
    blockedBy: [],
  },
}

// Resolve which layers should be visible based on equipped items and rules
export function resolveVisibleLayers(character: {
  gender: string
  characterType: string
  currentLocation: { biome?: string; name: string }
  inventory: Array&lt;{
    item: {
      name: string
      category: string
      layerType?: string
    }
    isEquipped: boolean
  }&gt;
}): LayerConfig[] {
  const layers: LayerConfig[] = []

  // 1. Add background based on location
  const backgroundName = getBackgroundForLocation(character.currentLocation)
  if (backgroundName) {
    layers.push({
      type: &#39;background&#39;,
      name: backgroundName,
      zIndex: 0,
      visible: true,
    })
  }

  // 2. Add base layer based on character type and gender
  const baseName = getBaseForCharacter(character)
  layers.push({
    type: &#39;base&#39;,
    name: baseName,
    zIndex: 1,
    visible: true,
  })

  // 3. Add equipped items as layers
  const equippedItems = character.inventory.filter((inv) =&gt; inv.isEquipped)

  equippedItems.forEach((inv) =&gt; {
    const layerType = mapCategoryToLayerType(inv.item.category)
    const layerName = kebabCase(inv.item.name)

    if (layerType) {
      layers.push({
        type: layerType,
        name: layerName,
        zIndex: getZIndexForLayerType(layerType),
        visible: true, // Will be resolved in visibility step
      })
    }
  })

  // 4. Add contextual overlays (weather, effects, etc.)
  const overlays = getContextualOverlays(character)
  overlays.forEach((overlay) =&gt; {
    layers.push({
      type: &#39;overlay&#39;,
      name: overlay,
      zIndex: 10,
      visible: true,
    })
  })

  // 5. Apply visibility rules
  return applyVisibilityRules(layers)
}

// Helper functions
function getBackgroundForLocation(location: {
  biome?: string
  name: string
}): string | null {
  // Map location biomes to background images
  const biomeMap: { [key: string]: string } = {
    plains: &#39;mining-plains&#39;,
    desert: &#39;desert-outpost&#39;,
    urban: &#39;cyber-city&#39;,
  }

  return location.biome ? biomeMap[location.biome] || null : null
}

function getBaseForCharacter(character: {
  gender: string
  characterType: string
}): string {
  if (character.characterType === &#39;CREATURE&#39;) {
    return &#39;creature&#39;
  }
  return character.gender.toLowerCase() // &#39;male&#39; or &#39;female&#39;
}

function mapCategoryToLayerType(category: string): LayerConfig[&#39;type&#39;] | null {
  const categoryMap: { [key: string]: LayerConfig[&#39;type&#39;] } = {
    CLOTHING: &#39;clothing&#39;,
    HAT: &#39;clothing&#39;, // Hats go in clothing layer
    ACCESSORY: &#39;accessory&#39;,
    TOOL: &#39;accessory&#39;, // Tools as accessories for now
  }

  return categoryMap[category] || null
}

function getZIndexForLayerType(type: LayerConfig[&#39;type&#39;]): number {
  const zIndexMap = {
    background: 0,
    base: 1,
    clothing: 2,
    accessory: 3,
    overlay: 10,
  }
  return zIndexMap[type]
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getContextualOverlays(character: any): string[] {
  const overlays: string[] = []

  // Add overlays based on game state, time, events, etc.
  // Example: if character has low health, add a red glow
  if (character.health &amp;&amp; character.health &lt; 30) {
    overlays.push(&#39;glow-red&#39;)
  }

  // Add weather effects based on location
  if (character.currentLocation?.biome === &#39;desert&#39; &amp;&amp; Math.random() &gt; 0.7) {
    // Sometimes add heat shimmer effect in desert
    // overlays.push(&#39;heat-shimmer&#39;)
  }

  return overlays
}

function applyVisibilityRules(layers: LayerConfig[]): LayerConfig[] {
  const visibleLayers = [...layers]

  // Apply blocking rules
  layers.forEach((layer) =&gt; {
    const rules = LAYER_VISIBILITY_RULES[layer.name]
    if (rules?.blocks) {
      rules.blocks.forEach((blockedName) =&gt; {
        const blockedLayer = visibleLayers.find((l) =&gt; l.name === blockedName)
        if (blockedLayer) {
          blockedLayer.visible = false
        }
      })
    }
  })

  // Sort by z-index and filter visible layers
  return visibleLayers
    .filter((layer) =&gt; layer.visible)
    .sort((a, b) =&gt; a.zIndex - b.zIndex)
}

// Utility function to convert item names to kebab-case for file names
function kebabCase(str: string): string {
  return str
    .toLowerCase()
    .replace(/[^a-z0-9]/g, &#39;-&#39;)
    .replace(/-+/g, &#39;-&#39;)
    .replace(/^-|-$/g, &#39;&#39;)
}

// Generate metadata for NFT
export interface NFTMetadata {
  name: string
  description: string
  image: string
  attributes: Array&lt;{
    trait_type: string
    value: string
  }&gt;
  assets: {
    layers: string[]
  }
}

export function generateNFTMetadata(character: {
  id: string
  name: string
  gender: string
  characterType: string
  currentLocation: { name: string; biome?: string }
  inventory: Array&lt;{
    item: {
      name: string
      category: string
      rarity: string
      layerType?: string
    }
    isEquipped: boolean
  }&gt;
  energy: number
  health: number
}): NFTMetadata {
  const visibleLayers = resolveVisibleLayers(character)

  // Generate attributes from visible layers and character stats
  const attributes = [
    { trait_type: &#39;Gender&#39;, value: character.gender },
    { trait_type: &#39;Type&#39;, value: character.characterType },
    { trait_type: &#39;Location&#39;, value: character.currentLocation.name },
  ]

  // Add background attribute
  const background = visibleLayers.find((l) =&gt; l.type === &#39;background&#39;)
  if (background) {
    attributes.push({
      trait_type: &#39;Background&#39;,
      value: background.name
        .split(&#39;-&#39;)
        .map((w) =&gt; w.charAt(0).toUpperCase() + w.slice(1))
        .join(&#39; &#39;),
    })
  }

  // Add equipped item attributes
  const equippedItems = character.inventory.filter((inv) =&gt; inv.isEquipped)
  equippedItems.forEach((inv) =&gt; {
    attributes.push({
      trait_type:
        inv.item.category.charAt(0) + inv.item.category.slice(1).toLowerCase(),
      value: inv.item.name,
    })
  })

  // Add status attributes
  if (character.energy &lt; 30) {
    attributes.push({ trait_type: &#39;Status&#39;, value: &#39;Exhausted&#39; })
  } else if (character.energy &gt; 90) {
    attributes.push({ trait_type: &#39;Status&#39;, value: &#39;Energetic&#39; })
  }

  // Generate description
  const description = generateDescription(character, equippedItems)

  return {
    name: character.name,
    description,
    image: `https://earth.ndao.computer/api/render/${character.id}.png`,
    attributes,
    assets: {
      layers: visibleLayers.map((layer) =&gt; getAssetUrl(layer.type, layer.name)),
    },
  }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function generateDescription(character: any, equippedItems: any[]): string {
  const locationDesc = `wandering ${character.currentLocation.name}`
  const itemDesc =
    equippedItems.length &gt; 0
      ? `equipped with ${equippedItems.map((i) =&gt; i.item.name).join(&#39;, &#39;)}`
      : &#39;traveling light&#39;

  const statusDesc =
    character.energy &lt; 30
      ? &#39;looking weary from their adventures&#39;
      : character.energy &gt; 90
      ? &#39;full of energy and ready for action&#39;
      : &#39;continuing their journey&#39;

  return `A ${character.characterType.toLowerCase()} ${locationDesc}, ${itemDesc}, ${statusDesc}.`
}

// Export layer resolution for use in image rendering
export { resolveVisibleLayers as default }
</content>
    </document>

    <document>
      <source>src/vite-env.d.ts</source>
      <tags></tags>
      <metadata>
        <size>38</size>
        <lastModified>2025-05-28T21:44:35.044Z</lastModified>
        <extension>ts</extension>
        <directory>src</directory>
      </metadata>
      <content>/// &lt;reference types=&quot;vite/client&quot; /&gt;
</content>
    </document>

    <document>
      <source>src/App.tsx</source>
      <tags></tags>
      <metadata>
        <size>42262</size>
        <lastModified>2025-05-29T12:22:54.002Z</lastModified>
        <extension>tsx</extension>
        <directory>src</directory>
      </metadata>
      <content>import { useState, useEffect } from &#39;react&#39;
import { Button } from &#39;@/components/ui/button&#39;
import { MapPin, Pickaxe, Store, Backpack, ArrowLeft, Zap, Heart, Users, Map, MessageCircle, Send, Earth } from &#39;lucide-react&#39;
import &#39;./App.css&#39;
import { ModeToggle } from &#39;./components/mode-toggle&#39;
// import { resolveVisibleLayers, generateCharacterLayers, generateNFTMetadata } from &#39;@/lib/layerResolver&#39;
import { toast, Toaster } from &#39;sonner&#39;
import { InventoryView, MarketView, MiningView, WorldMapView } from &#39;@/components/views&#39;

import { Tabs, TabsList, TabsTrigger, TabsContent } from &quot;@/components/ui/tabs&quot;

// API base URL - will be your Netlify functions URL
const API_BASE = &#39;/.netlify/functions&#39;

import type {
  GameView,
  Character,
  Location,
  MarketItem,
  ChatMessage,
  Player
} from &#39;@/types&#39;

function App() {
  const [currentView, setCurrentView] = useState&lt;GameView&gt;(&#39;main&#39;)
  const [selectedLocation, setSelectedLocation] = useState&lt;Location | null&gt;(null)
  const [gameLog, setGameLog] = useState&lt;string[]&gt;([])
  const [chatInput, setChatInput] = useState(&#39;&#39;)
  const [loadingItems, setLoadingItems] = useState&lt;Set&lt;string&gt;&gt;(new Set())

  // State for API data
  const [character, setCharacter] = useState&lt;Character | null&gt;(null)
  const [locations, setLocations] = useState&lt;Location[]&gt;([])
  const [marketItems, setMarketItems] = useState&lt;MarketItem[]&gt;([])
  const [chatMessages, setChatMessages] = useState&lt;ChatMessage[]&gt;([])
  const [playersAtLocation, setPlayersAtLocation] = useState&lt;Player[]&gt;([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState&lt;string | null&gt;(null)
  const [travelingTo, setTravelingTo] = useState&lt;Location | null&gt;(null)

  // Load initial data
  useEffect(() =&gt; {
    loadGameData()
  }, [])

  // Load chat when location changes
  useEffect(() =&gt; {
    if (character &amp;&amp; currentView === &#39;chat&#39;) {
      loadChatMessages(selectedLocation?.id || character.currentLocation.id)
    }
  }, [currentView, selectedLocation?.id, character?.currentLocation.id, character])

  // Load players when viewing location
  useEffect(() =&gt; {
    if (selectedLocation &amp;&amp; currentView === &#39;location&#39;) {
      loadPlayersAtLocation(selectedLocation.id)
    }
  }, [selectedLocation?.id, currentView, selectedLocation])

  // Load market when opening market view
  useEffect(() =&gt; {
    if (character &amp;&amp; currentView === &#39;market&#39;) {
      loadMarketItems(selectedLocation?.id || character.currentLocation.id)
    }
  }, [currentView, selectedLocation?.id, character?.currentLocation.id, character])

  const loadGameData = async () =&gt; {
    try {
      setLoading(true)

      // Load character data
      const characterResponse = await fetch(`${API_BASE}/get-character?characterId=hardcoded-demo`)
      if (!characterResponse.ok) throw new Error(&#39;Failed to load character&#39;)
      const characterData = await characterResponse.json()
      setCharacter(characterData)

      // Load locations data
      const locationsResponse = await fetch(`${API_BASE}/get-locations`)
      if (!locationsResponse.ok) throw new Error(&#39;Failed to load locations&#39;)
      const locationsData = await locationsResponse.json()
      setLocations(locationsData.locations)

      // Set initial game log
      setGameLog([
        `Welcome to Earth, ${characterData.name}!`,
        `You find yourself in ${characterData.currentLocation.name}.`,
        ...characterData.recentActivity.slice(0, 3).map((activity: Character[&#39;recentActivity&#39;][0]) =&gt;
          `${activity.description}${activity.item ? ` - ${activity.item.name}` : &#39;&#39;}`
        )
      ])

      setError(null)
    } catch (err) {
      console.error(&#39;Failed to load game data:&#39;, err)
      setError(&#39;Failed to load game data. Please refresh the page.&#39;)
    } finally {
      setLoading(false)
    }
  }

  const loadMarketItems = async (locationId: string) =&gt; {
    try {
      const response = await fetch(`${API_BASE}/get-market?locationId=${locationId}`)
      if (response.ok) {
        const data = await response.json()
        setMarketItems(data.items || [])
      }
    } catch (error) {
      console.error(&#39;Failed to load market items:&#39;, error)
      // Fallback to mock data if API not implemented
      setMarketItems([
        {
          id: &#39;1&#39;,
          price: 50,
          quantity: 1,
          isSystemItem: true,
          item: {
            id: &#39;1&#39;,
            name: &#39;Miners Hat&#39;,
            description: &#39;Worn leather hat with a dim headlamp&#39;,
            category: &#39;HAT&#39;,
            rarity: &#39;COMMON&#39;,
            imageUrl: &#39;/items/miners-hat.png&#39;
          }
        },
        {
          id: &#39;2&#39;,
          price: 25,
          quantity: 1,
          isSystemItem: true,
          item: {
            id: &#39;2&#39;,
            name: &#39;Work Gloves&#39;,
            description: &#39;Tough gloves for manual labor&#39;,
            category: &#39;CLOTHING&#39;,
            rarity: &#39;COMMON&#39;
          }
        },
        {
          id: &#39;3&#39;,
          price: 10,
          quantity: 5,
          isSystemItem: true,
          item: {
            id: &#39;3&#39;,
            name: &#39;Energy Drink&#39;,
            description: &#39;Restores energy and keeps you alert&#39;,
            category: &#39;CONSUMABLE&#39;,
            rarity: &#39;COMMON&#39;
          }
        }
      ])
    }
  }

  const loadChatMessages = async (locationId: string) =&gt; {
    try {
      const response = await fetch(`${API_BASE}/get-chat?locationId=${locationId}&amp;limit=50`)
      if (response.ok) {
        const data = await response.json()
        setChatMessages(data.messages || [])
      }
    } catch (error) {
      console.error(&#39;Failed to load chat messages:&#39;, error)
      // Fallback to mock data
      setChatMessages([
        {
          id: &#39;1&#39;,
          message: &#39;Anyone know where the best iron deposits are?&#39;,
          messageType: &#39;CHAT&#39;,
          isSystem: false,
          timeAgo: &#39;3m ago&#39;,
          createdAt: new Date(Date.now() - 3 * 60 * 1000).toISOString(),
          character: {
            id: &#39;1&#39;,
            name: &#39;Wojak #420&#39;,
            characterType: &#39;HUMAN&#39;,
            imageUrl: &#39;/wojak-420.png&#39;
          },
          location: {
            id: locationId,
            name: &#39;Mining Plains&#39;,
            locationType: &#39;REGION&#39;
          }
        },
        {
          id: &#39;2&#39;,
          message: &#39;Try the eastern slopes, found some good scraps there yesterday&#39;,
          messageType: &#39;CHAT&#39;,
          isSystem: false,
          timeAgo: &#39;2m ago&#39;,
          createdAt: new Date(Date.now() - 2 * 60 * 1000).toISOString(),
          character: {
            id: &#39;2&#39;,
            name: &#39;Wojak #1337&#39;,
            characterType: &#39;HUMAN&#39;
          },
          location: {
            id: locationId,
            name: &#39;Mining Plains&#39;,
            locationType: &#39;REGION&#39;
          }
        }
      ])
    }
  }

  const loadPlayersAtLocation = async (locationId: string) =&gt; {
    try {
      const response = await fetch(`${API_BASE}/get-players-at-location?locationId=${locationId}`)
      if (response.ok) {
        const data = await response.json()
        setPlayersAtLocation(data.players || [])
      }
    } catch (error) {
      console.error(&#39;Failed to load players:&#39;, error)
      // Mock data fallback
      setPlayersAtLocation([
        {
          id: &#39;1&#39;,
          name: &#39;Wojak #420&#39;,
          gender: &#39;MALE&#39;,
          characterType: &#39;HUMAN&#39;,
          level: 5,
          energy: 95,
          health: 100,
          status: &#39;Mining&#39;,
          currentImageUrl: &#39;/wojak-420.png&#39;,
          equippedItems: [
            { name: &#39;Miners Hat&#39;, category: &#39;HAT&#39;, rarity: &#39;COMMON&#39; }
          ]
        },
        {
          id: &#39;2&#39;,
          name: &#39;Wojak #69&#39;,
          gender: &#39;FEMALE&#39;,
          characterType: &#39;HUMAN&#39;,
          level: 3,
          energy: 70,
          health: 100,
          status: &#39;Chatting&#39;,
          equippedItems: []
        }
      ])
    }
  }

  const addToLog = (message: string) =&gt; {
    setGameLog(prev =&gt; [...prev.slice(-4), message]) // Keep last 5 messages
  }

  const handleMining = async () =&gt; {
    if (!character) return

    // Set loading state for mining button
    setLoadingItems(prev =&gt; new Set(prev).add(&#39;mining-action&#39;))

    try {
      const response = await fetch(`${API_BASE}/mine-action`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          locationId: selectedLocation?.id || character.currentLocation.id
        })
      })

      const result = await response.json()

      if (!response.ok) {
        // Show error toast
        toast.error(result.message || result.error)
        return
      }

      // Update character energy immediately (optimistic update)
      setCharacter(prev =&gt; prev ? ({
        ...prev,
        energy: result.newEnergyLevel
      }) : null)

      // Show appropriate toast based on what was found
      if (result.foundItem) {
        // Success toast with item details
        const rarityEmoji = {
          &#39;COMMON&#39;: &#39;⚪&#39;,
          &#39;UNCOMMON&#39;: &#39;🟢&#39;,
          &#39;RARE&#39;: &#39;🔵&#39;,
          &#39;EPIC&#39;: &#39;🟣&#39;,
          &#39;LEGENDARY&#39;: &#39;🟡&#39;
        }[result.foundItem.rarity] || &#39;⚪&#39;

        toast.success(
          `Found ${result.foundItem.name}! ${rarityEmoji}`,
          {
            description: `${result.foundItem.description} • Energy: ${result.newEnergyLevel}/100`,
            duration: 4000
          }
        )

        // Add to game log
        addToLog(`⛏️ ${result.message}`)
      } else {
        // Nothing found toast
        toast.info(
          &quot;Nothing found this time...&quot;,
          {
            description: `Keep trying! Energy: ${result.newEnergyLevel}/100`,
            duration: 2000
          }
        )

        // Add to game log  
        addToLog(`⛏️ ${result.message}`)
      }

      // Only refresh character data (not full page reload)
      // This updates inventory with new items
      const characterResponse = await fetch(`${API_BASE}/get-character?characterId=hardcoded-demo`)
      if (characterResponse.ok) {
        const characterData = await characterResponse.json()
        setCharacter(characterData)
      }

    } catch (error) {
      console.error(&#39;Mining failed:&#39;, error)
      toast.error(&#39;Mining attempt failed. Please try again.&#39;)
      addToLog(&#39;⛏️ Mining attempt failed due to connection issues.&#39;)
    } finally {
      // Remove loading state
      setLoadingItems(prev =&gt; {
        const newSet = new Set(prev)
        newSet.delete(&#39;mining-action&#39;)
        return newSet
      })
    }
  }

  const handleTravel = async (locationId: string) =&gt; {
    if (!character) return

    // Find the destination location for the travel animation
    const destination = locations.find(loc =&gt; loc.id === locationId) ||
      locations.find(loc =&gt; loc.subLocations?.some(sub =&gt; sub.id === locationId))?.subLocations?.find(sub =&gt; sub.id === locationId)

    if (destination) {
      setTravelingTo(destination)
    }

    try {
      const response = await fetch(`${API_BASE}/travel-action`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          destinationId: locationId
        })
      })

      const result = await response.json()

      if (!response.ok) {
        addToLog(result.message || result.error)
        setTravelingTo(null)
        return
      }

      // Show travel completion after a brief delay for the animation
      setTimeout(async () =&gt; {
        // Update character location
        setCharacter(prev =&gt; prev ? ({
          ...prev,
          currentLocation: {
            id: result.newLocation.id,
            name: result.newLocation.name,
            description: result.newLocation.description,
            locationType: result.newLocation.locationType,
            biome: result.newLocation.biome,
            welcomeMessage: result.newLocation.welcomeMessage
          }
        }) : null)

        // Show result in log
        addToLog(result.message)
        if (result.newLocation.welcomeMessage) {
          addToLog(`&quot;${result.newLocation.welcomeMessage}&quot;`)
        }

        // Refresh locations data in background without loading state
        try {
          const locationsResponse = await fetch(`${API_BASE}/get-locations`)
          if (locationsResponse.ok) {
            const locationsData = await locationsResponse.json()
            setLocations(locationsData.locations)
          }
        } catch (err) {
          console.error(&#39;Failed to refresh locations:&#39;, err)
        }

        // Clear traveling state and go to main view
        setTravelingTo(null)
        setCurrentView(&#39;main&#39;)
      }, 1500) // 1.5 second travel animation

    } catch (error) {
      console.error(&#39;Travel failed:&#39;, error)
      addToLog(&#39;Travel failed. Please try again.&#39;)
      setTravelingTo(null)
    }
  }

  const handleLocationSelect = (location: Location) =&gt; {
    setSelectedLocation(location)
    setCurrentView(&#39;location&#39;)
  }

  const handlePurchase = async (marketListingId: string, price: number, itemName: string) =&gt; {
    if (!character) return

    // Set loading state
    setLoadingItems(prev =&gt; new Set(prev).add(marketListingId))

    try {
      const response = await fetch(`${API_BASE}/buy-item`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          marketListingId: marketListingId,
          locationId: selectedLocation?.id || character.currentLocation.id
        })
      })

      const result = await response.json()

      if (!response.ok) {
        toast.error(result.message || result.error)
        return
      }

      toast.success(`Bought ${itemName} for ${price} coins!`)

      // Optimistic update for market items
      setMarketItems(prev =&gt; prev.map(item =&gt; {
        if (item.id === marketListingId) {
          const newQuantity = item.quantity - 1
          return newQuantity &gt; 0 ? { ...item, quantity: newQuantity } : null
        }
        return item
      }).filter(Boolean) as MarketItem[])

      // Only refresh character data (not everything)
      const characterResponse = await fetch(`${API_BASE}/get-character?characterId=hardcoded-demo`)
      if (characterResponse.ok) {
        const characterData = await characterResponse.json()
        setCharacter(characterData)
      }

    } catch (error) {
      console.error(&#39;Purchase failed:&#39;, error)
      toast.error(&#39;Purchase failed&#39;)
    } finally {
      // Remove loading state
      setLoadingItems(prev =&gt; {
        const newSet = new Set(prev)
        newSet.delete(marketListingId)
        return newSet
      })
    }
  }

  const handleSendMessage = async () =&gt; {
    if (!chatInput.trim() || !character) return

    try {
      const response = await fetch(`${API_BASE}/send-message`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          locationId: selectedLocation?.id || character.currentLocation.id,
          message: chatInput,
          messageType: &#39;CHAT&#39;
        })
      })

      if (response.ok) {
        setChatInput(&#39;&#39;)
        // Reload chat messages
        loadChatMessages(selectedLocation?.id || character.currentLocation.id)
      } else {
        // Fallback for demo - add message locally
        const newMessage: ChatMessage = {
          id: Date.now().toString(),
          message: chatInput,
          messageType: &#39;CHAT&#39;,
          isSystem: false,
          timeAgo: &#39;now&#39;,
          createdAt: new Date().toISOString(),
          character: {
            id: character.id,
            name: character.name,
            characterType: &#39;HUMAN&#39;
          },
          location: {
            id: selectedLocation?.id || character.currentLocation.id,
            name: selectedLocation?.name || character.currentLocation.name,
            locationType: selectedLocation?.locationType || character.currentLocation.locationType
          }
        }
        setChatMessages(prev =&gt; [...prev, newMessage])
        setChatInput(&#39;&#39;)
      }
    } catch (error) {
      console.error(&#39;Failed to send message:&#39;, error)
    }
  }

  const handleEquipItem = async (inventoryId: string, isEquipped: boolean) =&gt; {
    if (!character) return

    // Set loading state
    setLoadingItems(prev =&gt; new Set(prev).add(inventoryId))

    try {
      const response = await fetch(`${API_BASE}/equip-item`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          inventoryId: inventoryId,
          equip: !isEquipped
        })
      })

      const result = await response.json()

      if (!response.ok) {
        toast.error(result.message || result.error)
        return
      }

      // Optimistic update for ALL inventory items in the same category
      setCharacter(prev =&gt; prev ? ({
        ...prev,
        inventory: prev.inventory.map(inv =&gt; {
          // Unequip items in the same category (auto-replace logic)
          if (inv.item.category === prev.inventory.find(i =&gt; i.id === inventoryId)?.item.category &amp;&amp;
            inv.id !== inventoryId &amp;&amp;
            !isEquipped) {
            return { ...inv, isEquipped: false }
          }
          // Update the target item
          if (inv.id === inventoryId) {
            return { ...inv, isEquipped: !isEquipped }
          }
          return inv
        })
      }) : null)

      // Enhanced toast with replacement info
      if (result.replacedItems &amp;&amp; result.replacedItems.length &gt; 0) {
        toast.success(
          `${result.item.name} equipped!`,
          {
            description: `Replaced ${result.replacedItems.join(&#39;, &#39;)}`,
            duration: 4000
          }
        )
      } else {
        toast.success(
          isEquipped ? `${result.item.name} unequipped` : `${result.item.name} equipped!`,
          {
            description: `${result.item.category.toLowerCase()} • ${result.item.rarity.toLowerCase()}`,
            duration: 3000
          }
        )
      }

    } catch (error) {
      console.error(&#39;Failed to equip item:&#39;, error)
      toast.error(&#39;Failed to update equipment&#39;)
    } finally {
      // Remove loading state
      setLoadingItems(prev =&gt; {
        const newSet = new Set(prev)
        newSet.delete(inventoryId)
        return newSet
      })
    }
  }

  const handleUseItem = async (inventoryId: string, itemName: string, energyEffect?: number, healthEffect?: number) =&gt; {
    if (!character) return

    // Calculate actual effects (capped at 100)
    const actualEnergyGain = energyEffect ? Math.min(energyEffect, 100 - character.energy) : 0
    const actualHealthGain = healthEffect ? Math.min(healthEffect, 100 - character.health) : 0

    // Warn if effects would be wasted
    if ((energyEffect &amp;&amp; actualEnergyGain === 0) || (healthEffect &amp;&amp; actualHealthGain === 0)) {
      toast.warning(`You&#39;re already at full ${energyEffect &amp;&amp; actualEnergyGain === 0 ? &#39;energy&#39; : &#39;health&#39;}!`)
      return
    }

    // Set loading state for this specific item
    setLoadingItems(prev =&gt; new Set(prev).add(inventoryId))

    try {
      const response = await fetch(`${API_BASE}/use-item`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          inventoryId: inventoryId
        })
      })

      const result = await response.json()

      if (!response.ok) {
        toast.error(result.message || result.error)
        return
      }

      // Update character stats immediately (optimistic update)
      setCharacter(prev =&gt; prev ? ({
        ...prev,
        energy: Math.min(100, prev.energy + (result.effects?.energy || 0)),
        health: Math.min(100, prev.health + (result.effects?.health || 0)),
        // Update inventory optimistically
        inventory: prev.inventory.map(inv =&gt; {
          if (inv.id === inventoryId) {
            const newQuantity = inv.quantity - 1
            return newQuantity &gt; 0 ? { ...inv, quantity: newQuantity } : null
          }
          return inv
        }).filter(Boolean) as typeof prev.inventory
      }) : null)

      // Show success toast with effects
      const effects = []
      if (result.effects?.energy &gt; 0) effects.push(`+${result.effects.energy} energy`)
      if (result.effects?.health &gt; 0) effects.push(`+${result.effects.health} health`)

      toast.success(`Used ${itemName}${effects.length &gt; 0 ? ` (${effects.join(&#39;, &#39;)})` : &#39;&#39;}`)

      // Don&#39;t reload everything - just let the optimistic update handle it

    } catch (error) {
      console.error(&#39;Use item failed:&#39;, error)
      toast.error(`Failed to use ${itemName}`)
    } finally {
      // Remove loading state
      setLoadingItems(prev =&gt; {
        const newSet = new Set(prev)
        newSet.delete(inventoryId)
        return newSet
      })
    }
  }

  // Initial loading state (only for app startup)
  if (loading &amp;&amp; !travelingTo) {
    return (
      &lt;div className=&quot;min-h-screen bg-background p-4 flex items-center justify-center&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          {/* &lt;div className=&quot;text-2xl mb-4&quot;&gt;🌍&lt;/div&gt; */}
          &lt;Earth className=&quot;w-12 h-12 mb-4 animate-spin&quot; /&gt;
          &lt;div&gt;Loading Wojak Earth...&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }

  // Travel animation state
  if (travelingTo) {
    return (
      &lt;div className=&quot;min-h-screen bg-background p-4 flex items-center justify-center&quot;&gt;
        &lt;div className=&quot;text-center max-w-md mx-auto&quot;&gt;
          &lt;div className=&quot;mb-6&quot;&gt;
            &lt;div className=&quot;text-4xl mb-4 animate-bounce&quot;&gt;
              {travelingTo.biome === &#39;desert&#39; ? &#39;🏜️&#39; :
                travelingTo.biome === &#39;urban&#39; ? &#39;🏙️&#39; :
                  travelingTo.biome === &#39;plains&#39; ? &#39;🌾&#39; :
                    travelingTo.locationType === &#39;BUILDING&#39; ? &#39;🏠&#39; : &#39;🗺️&#39;}
            &lt;/div&gt;
            &lt;div className=&quot;text-xl font-bold mb-2&quot;&gt;Traveling to...&lt;/div&gt;
            &lt;div className=&quot;text-2xl font-bold text-primary mb-2&quot;&gt;{travelingTo.name}&lt;/div&gt;
            &lt;div className=&quot;text-muted-foreground mb-4&quot;&gt;{travelingTo.description}&lt;/div&gt;

            {/* Animated progress bar */}
            &lt;div className=&quot;w-full bg-muted rounded-full h-2 mb-4 overflow-hidden&quot;&gt;
              &lt;div className=&quot;bg-primary h-2 rounded-full animate-pulse&quot;
                style={{
                  animation: &#39;travel-progress 1.5s ease-in-out forwards&#39;,
                  width: &#39;0%&#39;
                }}&gt;&lt;/div&gt;
            &lt;/div&gt;

            &lt;div className=&quot;text-sm text-muted-foreground animate-pulse&quot;&gt;
              Preparing for arrival...
            &lt;/div&gt;
          &lt;/div&gt;

          {/* Add custom CSS for the travel progress animation */}
          &lt;style&gt;{`
            @keyframes travel-progress {
              0% { width: 0%; }
              100% { width: 100%; }
            }
          `}&lt;/style&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }

  // Error state
  if (error) {
    return (
      &lt;div className=&quot;min-h-screen bg-background p-4 flex items-center justify-center&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          &lt;div className=&quot;text-2xl mb-4&quot;&gt;❌&lt;/div&gt;
          &lt;div className=&quot;text-red-500 mb-4&quot;&gt;{error}&lt;/div&gt;
          &lt;Button onClick={loadGameData}&gt;Retry&lt;/Button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }

  // No character data
  if (!character) {
    return (
      &lt;div className=&quot;min-h-screen bg-background p-4 flex items-center justify-center&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          &lt;div className=&quot;text-2xl mb-4&quot;&gt;🤔&lt;/div&gt;
          &lt;div&gt;No character data found&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }


  // Add this new component for the character display
  const CharacterRenderer: React.FC&lt;{ character: Character }&gt; = ({ character }) =&gt; {
    const [imageError, setImageError] = useState(false)
    const [imageLoading, setImageLoading] = useState(true)

    // Generate the rendered character URL
    const characterImageUrl = `/.netlify/functions/render-character/${character.id}.png`

    const handleImageLoad = () =&gt; {
      setImageLoading(false)
      setImageError(false)
    }

    const handleImageError = () =&gt; {
      setImageLoading(false)
      setImageError(true)
    }

    return (
      &lt;div className=&quot;w-32 h-32 mx-auto bg-gray-200 rounded-lg flex items-center justify-center mb-4 overflow-hidden relative&quot;&gt;
        {imageLoading &amp;&amp; (
          &lt;div className=&quot;absolute inset-0 flex items-center justify-center&quot;&gt;
            &lt;div className=&quot;animate-spin rounded-full h-8 w-8 border-b-2 border-primary&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;
        )}

        {!imageError ? (
          &lt;img
            src=&quot;/wojak.png&quot;
            // src={characterImageUrl}
            alt={character.name}
            className=&quot;w-full h-full object-cover&quot;
            onLoad={handleImageLoad}
            onError={handleImageError}
            style={{ display: imageLoading ? &#39;none&#39; : &#39;block&#39; }}
          /&gt;
        ) : (
          // Fallback to default wojak image
          &lt;img
            src={character.currentImageUrl || &quot;/wojak.png&quot;}
            alt={character.name}
            className=&quot;w-full h-full object-cover&quot;
            onLoad={() =&gt; setImageLoading(false)}
            onError={() =&gt; {
              setImageLoading(false)
              // Ultimate fallback
              const target = event?.target as HTMLImageElement
              if (target) {
                target.style.display = &#39;none&#39;
                if (target.parentElement) {
                  target.parentElement.innerHTML = &#39;&lt;div class=&quot;text-4xl&quot;&gt;🥺&lt;/div&gt;&#39;
                }
              }
            }}
          /&gt;
        )}
      &lt;/div&gt;
    )
  }

  // Add this function to show layer information (useful for debugging)
  // const LayerDebugPanel: React.FC&lt;{ character: Character }&gt; = ({ character }) =&gt; {
  //   const characterLayers = generateCharacterLayers(character)
  //   const visibleLayers = resolveVisibleLayers(
  //     characterLayers,
  //     character.currentLocation.biome
  //   )

  //   return (
  //     &lt;div className=&quot;mt-4 p-3 bg-muted/30 rounded-lg&quot;&gt;
  //       &lt;h4 className=&quot;font-medium mb-2 text-sm&quot;&gt;Character Layers (Debug)&lt;/h4&gt;
  //       &lt;div className=&quot;space-y-1 text-xs&quot;&gt;
  //         {visibleLayers.map((layer, i) =&gt; (
  //           &lt;div key={i} className=&quot;flex justify-between items-center&quot;&gt;
  //             &lt;span className={layer.visible ? &#39;text-green-600&#39; : &#39;text-red-500&#39;}&gt;
  //               {layer.type}/{layer.name}
  //             &lt;/span&gt;
  //             &lt;span className=&quot;text-muted-foreground&quot;&gt;
  //               z:{layer.zIndex} {layer.visible ? &#39;✓&#39; : &#39;✗&#39;}
  //             &lt;/span&gt;
  //           &lt;/div&gt;
  //         ))}
  //       &lt;/div&gt;

  //       &lt;div className=&quot;mt-2 pt-2 border-t&quot;&gt;
  //         &lt;a
  //           href={`/.netlify/functions/metadata/${character.tokenId || character.id}`}
  //           target=&quot;_blank&quot;
  //           rel=&quot;noopener noreferrer&quot;
  //           className=&quot;text-xs text-blue-500 hover:underline&quot;
  //         &gt;
  //           View NFT Metadata →
  //         &lt;/a&gt;
  //       &lt;/div&gt;
  //     &lt;/div&gt;
  //   )
  // }



  const renderMainView = () =&gt; (
    &lt;div className=&quot;space-y-6&quot;&gt;
      &lt;ModeToggle /&gt;
      &lt;div className=&quot;text-center&quot;&gt;
        &lt;CharacterRenderer character={character} /&gt;
        &lt;h2 className=&quot;text-xl font-bold&quot;&gt;{character.name}&lt;/h2&gt;
        &lt;p className=&quot;text-muted-foreground&quot;&gt;Currently in {character.currentLocation.name}&lt;/p&gt;
        &lt;div className=&quot;flex justify-center gap-4 mt-2&quot;&gt;
          &lt;span className=&quot;text-sm flex items-center gap-1&quot;&gt;
            &lt;Zap className=&quot;w-3 h-3&quot; /&gt; {character.energy}/100
          &lt;/span&gt;
          &lt;span className=&quot;text-sm flex items-center gap-1&quot;&gt;
            &lt;Heart className=&quot;w-3 h-3&quot; /&gt; {character.health}/100
          &lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div className=&quot;grid grid-cols-2 gap-3&quot;&gt;
        &lt;Button onClick={() =&gt; setCurrentView(&#39;map&#39;)} variant=&quot;outline&quot;&gt;
          &lt;Map className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Map
        &lt;/Button&gt;
        &lt;Button onClick={() =&gt; setCurrentView(&#39;mine&#39;)} variant=&quot;outline&quot;&gt;
          &lt;Pickaxe className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Mine
        &lt;/Button&gt;
        &lt;Button onClick={() =&gt; setCurrentView(&#39;market&#39;)} variant=&quot;outline&quot;&gt;
          &lt;Store className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Market
        &lt;/Button&gt;
        &lt;Button onClick={() =&gt; setCurrentView(&#39;inventory&#39;)} variant=&quot;outline&quot;&gt;
          &lt;Backpack className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Inventory
        &lt;/Button&gt;
      &lt;/div&gt;

      &lt;div className=&quot;mt-4&quot;&gt;
        &lt;Button onClick={() =&gt; setCurrentView(&#39;chat&#39;)} variant=&quot;ghost&quot; className=&quot;w-full&quot;&gt;
          &lt;MessageCircle className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Local Chat ({playersAtLocation.length} online)
        &lt;/Button&gt;
      &lt;/div&gt;

      {/* Add debug panel in development */}
      {/* {process.env.NODE_ENV === &#39;development&#39; &amp;&amp; character &amp;&amp; (
        &lt;LayerDebugPanel character={character} /&gt;
      )} */}
    &lt;/div&gt;
  )

  const renderMapView = () =&gt; (
    &lt;div className=&quot;space-y-4&quot;&gt;
      &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;World Map&lt;/h3&gt;
      &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;
        Explore different locations across Wojak Earth
      &lt;/p&gt;

      &lt;Tabs defaultValue=&quot;list&quot; className=&quot;w-full&quot;&gt;
        &lt;TabsList className=&quot;mb-4&quot;&gt;
          &lt;TabsTrigger value=&quot;list&quot;&gt;List&lt;/TabsTrigger&gt;
          &lt;TabsTrigger value=&quot;map&quot;&gt;Map&lt;/TabsTrigger&gt;
        &lt;/TabsList&gt;

        &lt;TabsContent value=&quot;list&quot;&gt;
          &lt;div className=&quot;space-y-3&quot;&gt;
            {locations.map(location =&gt; (
              &lt;div
                key={location.id}
                className=&quot;border rounded-lg p-4 hover:bg-muted/50 transition-colors cursor-pointer&quot;
                onClick={() =&gt; handleLocationSelect(location)}
              &gt;
                &lt;div className=&quot;flex items-start justify-between mb-2&quot;&gt;
                  &lt;div&gt;
                    &lt;h4 className=&quot;font-medium&quot;&gt;{location.name}&lt;/h4&gt;
                    &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;{location.description}&lt;/p&gt;
                  &lt;/div&gt;
                  &lt;div className=&quot;flex items-center gap-1 text-sm text-muted-foreground&quot;&gt;
                    &lt;Users className=&quot;w-3 h-3&quot; /&gt;
                    {location.playerCount}
                  &lt;/div&gt;
                &lt;/div&gt;

                &lt;div className=&quot;flex items-center justify-between text-xs&quot;&gt;
                  &lt;div className=&quot;flex gap-3&quot;&gt;
                    &lt;span className=&quot;flex items-center gap-1&quot;&gt;
                      &lt;span className={`w-2 h-2 rounded-full ${location.difficulty &lt;= 2
                        ? &#39;bg-green-500&#39;
                        : location.difficulty &lt;= 4
                          ? &#39;bg-yellow-500&#39;
                          : &#39;bg-red-500&#39;
                        }`} /&gt;
                      Level {location.difficulty}
                    &lt;/span&gt;
                    &lt;span className=&quot;capitalize&quot;&gt;{location.biome}&lt;/span&gt;
                  &lt;/div&gt;
                  &lt;span className=&quot;text-muted-foreground&quot;&gt;
                    {location.lastActive
                      ? new Date(location.lastActive).toLocaleString()
                      : &#39;Active recently&#39;}
                  &lt;/span&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            ))}
          &lt;/div&gt;
        &lt;/TabsContent&gt;

        &lt;TabsContent value=&quot;map&quot;&gt;
          &lt;WorldMapView locations={locations} /&gt;
        &lt;/TabsContent&gt;
      &lt;/Tabs&gt;

      &lt;Button onClick={() =&gt; setCurrentView(&quot;main&quot;)} variant=&quot;ghost&quot;&gt;
        &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
        Back
      &lt;/Button&gt;
    &lt;/div&gt;
  )


  const renderLocationView = () =&gt; {
    if (!selectedLocation) return null

    return (
      &lt;div className=&quot;space-y-4&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;{selectedLocation.name}&lt;/h3&gt;
          &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;{selectedLocation.description}&lt;/p&gt;
          {selectedLocation.locationType &amp;&amp; (
            &lt;span className=&quot;inline-block mt-1 px-2 py-1 text-xs bg-muted rounded-full capitalize&quot;&gt;
              {selectedLocation.locationType.toLowerCase()}
            &lt;/span&gt;
          )}
        &lt;/div&gt;

        {selectedLocation.welcomeMessage &amp;&amp; (
          &lt;div className=&quot;bg-muted/50 p-3 rounded-lg text-sm italic text-center&quot;&gt;
            &quot;{selectedLocation.welcomeMessage}&quot;
          &lt;/div&gt;
        )}

        &lt;div className=&quot;grid grid-cols-3 gap-2 text-center text-sm&quot;&gt;
          &lt;div&gt;
            &lt;div className=&quot;font-medium&quot;&gt;{selectedLocation.playerCount}&lt;/div&gt;
            &lt;div className=&quot;text-muted-foreground&quot;&gt;Players&lt;/div&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;div className=&quot;font-medium&quot;&gt;
              {selectedLocation.difficulty ? `Level ${selectedLocation.difficulty}` : &#39;N/A&#39;}
            &lt;/div&gt;
            &lt;div className=&quot;text-muted-foreground&quot;&gt;Difficulty&lt;/div&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;div className=&quot;font-medium capitalize&quot;&gt;
              {selectedLocation.biome || selectedLocation.locationType?.toLowerCase()}
            &lt;/div&gt;
            &lt;div className=&quot;text-muted-foreground&quot;&gt;Type&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        {/* Sub-locations */}
        {selectedLocation.subLocations &amp;&amp; selectedLocation.subLocations.length &gt; 0 &amp;&amp; (
          &lt;div&gt;
            &lt;h4 className=&quot;font-medium mb-2&quot;&gt;Places to Visit&lt;/h4&gt;
            &lt;div className=&quot;space-y-2&quot;&gt;
              {selectedLocation.subLocations.map((subLocation) =&gt; (
                &lt;div
                  key={subLocation.id}
                  className=&quot;flex items-center justify-between p-2 bg-muted/30 rounded cursor-pointer hover:bg-muted/50 transition-colors&quot;
                  onClick={() =&gt; handleLocationSelect(subLocation)}
                &gt;
                  &lt;div&gt;
                    &lt;div className=&quot;font-medium text-sm&quot;&gt;{subLocation.name}&lt;/div&gt;
                    &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;{subLocation.description}&lt;/div&gt;
                  &lt;/div&gt;
                  &lt;div className=&quot;flex items-center gap-2 text-xs text-muted-foreground&quot;&gt;
                    &lt;Users className=&quot;w-3 h-3&quot; /&gt;
                    {subLocation.playerCount}
                  &lt;/div&gt;
                &lt;/div&gt;
              ))}
            &lt;/div&gt;
          &lt;/div&gt;
        )}

        &lt;div&gt;
          &lt;h4 className=&quot;font-medium mb-2 flex items-center gap-2&quot;&gt;
            &lt;Users className=&quot;w-4 h-4&quot; /&gt;
            Players Here ({playersAtLocation.length})
          &lt;/h4&gt;
          &lt;div className=&quot;space-y-2 max-h-32 overflow-y-auto&quot;&gt;
            {playersAtLocation.map(player =&gt; (
              &lt;div key={player.id} className=&quot;flex items-center justify-between p-2 bg-muted/30 rounded text-sm&quot;&gt;
                &lt;div className=&quot;flex items-center gap-2&quot;&gt;
                  &lt;div className=&quot;w-6 h-6 bg-gray-300 rounded-full flex items-center justify-center text-xs&quot;&gt;
                    {player.characterType === &#39;HUMAN&#39; ? &#39;🙂&#39; : &#39;👹&#39;}
                  &lt;/div&gt;
                  &lt;div&gt;
                    &lt;div className=&quot;font-medium&quot;&gt;{player.name}&lt;/div&gt;
                    &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;Level {player.level} • {player.status}&lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=&quot;text-xs text-right&quot;&gt;
                  &lt;div className=&quot;flex items-center gap-1&quot;&gt;
                    &lt;Zap className=&quot;w-2 h-2&quot; /&gt; {player.energy}
                  &lt;/div&gt;
                  &lt;div className=&quot;flex items-center gap-1&quot;&gt;
                    &lt;Heart className=&quot;w-2 h-2&quot; /&gt; {player.health}
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div className=&quot;grid grid-cols-2 gap-2&quot;&gt;
          {selectedLocation.name !== character.currentLocation.name &amp;&amp; (
            &lt;Button onClick={() =&gt; handleTravel(selectedLocation.id)} variant=&quot;outline&quot;&gt;
              &lt;MapPin className=&quot;w-4 h-4 mr-2&quot; /&gt;
              Travel Here
            &lt;/Button&gt;
          )}
          &lt;Button onClick={() =&gt; setCurrentView(&#39;chat&#39;)} variant=&quot;outline&quot;&gt;
            &lt;MessageCircle className=&quot;w-4 h-4 mr-2&quot; /&gt;
            Local Chat
          &lt;/Button&gt;
        &lt;/div&gt;

        {selectedLocation.lore &amp;&amp; (
          &lt;div className=&quot;border-t pt-3&quot;&gt;
            &lt;h4 className=&quot;font-medium mb-2&quot;&gt;Lore&lt;/h4&gt;
            &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;{selectedLocation.lore}&lt;/p&gt;
          &lt;/div&gt;
        )}

        &lt;Button onClick={() =&gt; setCurrentView(&#39;map&#39;)} variant=&quot;ghost&quot;&gt;
          &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Back to Map
        &lt;/Button&gt;
      &lt;/div&gt;
    )
  }

  const renderMineView = () =&gt; (
    &lt;MiningView
      character={character}
      loadingItems={loadingItems}
      onBack={() =&gt; setCurrentView(&#39;main&#39;)}
      onMine={handleMining}
    /&gt;
  )

  const renderMarketView = () =&gt; (
    &lt;MarketView
      character={character}
      selectedLocation={selectedLocation}
      locations={locations}
      marketItems={marketItems}
      loadingItems={loadingItems}
      onBack={() =&gt; setCurrentView(&#39;main&#39;)}
      onPurchase={handlePurchase}
    /&gt;
  )

  const renderInventoryView = () =&gt; (
    &lt;InventoryView
      character={character}
      loadingItems={loadingItems}
      onBack={() =&gt; setCurrentView(&#39;main&#39;)}
      onUseItem={handleUseItem}
      onEquipItem={handleEquipItem}
    /&gt;
  )

  const renderChatView = () =&gt; {
    return (
      &lt;div className=&quot;space-y-4&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          &lt;h3 className=&quot;text-lg font-semibold flex items-center justify-center gap-2&quot;&gt;
            &lt;MessageCircle className=&quot;w-5 h-5&quot; /&gt;
            {selectedLocation ? selectedLocation.name : character.currentLocation.name}
          &lt;/h3&gt;
          &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;
            Local chat • {chatMessages.length} messages
          &lt;/p&gt;
        &lt;/div&gt;

        &lt;div className=&quot;bg-muted/30 rounded-lg p-3 h-64 overflow-y-auto space-y-2&quot;&gt;
          {chatMessages.length &gt; 0 ? (
            chatMessages.map(message =&gt; (
              &lt;div key={message.id} className=&quot;space-y-1&quot;&gt;
                {message.isSystem ? (
                  &lt;div className=&quot;text-xs text-center text-muted-foreground italic&quot;&gt;
                    {message.message}
                  &lt;/div&gt;
                ) : (
                  &lt;div className=&quot;space-y-1&quot;&gt;
                    &lt;div className=&quot;flex items-center gap-2 text-xs&quot;&gt;
                      &lt;div className=&quot;w-4 h-4 bg-gray-300 rounded-full flex items-center justify-center&quot;&gt;
                        {message.character?.characterType === &#39;HUMAN&#39; ? &#39;🙂&#39; : &#39;👹&#39;}
                      &lt;/div&gt;
                      &lt;span className=&quot;font-medium&quot;&gt;{message.character?.name}&lt;/span&gt;
                      &lt;span className=&quot;text-muted-foreground&quot;&gt;{message.timeAgo}&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div className=&quot;text-sm pl-6&quot;&gt;
                      {message.messageType === &#39;EMOTE&#39; ? (
                        &lt;span className=&quot;italic&quot;&gt;*{message.message}*&lt;/span&gt;
                      ) : (
                        message.message
                      )}
                    &lt;/div&gt;
                  &lt;/div&gt;
                )}
              &lt;/div&gt;
            ))
          ) : (
            &lt;div className=&quot;text-sm text-muted-foreground text-center&quot;&gt;
              No messages yet. Be the first to say something!
            &lt;/div&gt;
          )}
        &lt;/div&gt;

        &lt;div className=&quot;flex gap-2&quot;&gt;
          &lt;input
            type=&quot;text&quot;
            placeholder=&quot;Type your message...&quot;
            value={chatInput}
            onChange={(e) =&gt; setChatInput(e.target.value)}
            onKeyPress={(e) =&gt; e.key === &#39;Enter&#39; &amp;&amp; handleSendMessage()}
            className=&quot;flex-1 px-3 py-2 border rounded-md text-sm&quot;
          /&gt;
          &lt;Button size=&quot;sm&quot; onClick={handleSendMessage} disabled={!chatInput.trim()}&gt;
            &lt;Send className=&quot;w-4 h-4&quot; /&gt;
          &lt;/Button&gt;
        &lt;/div&gt;

        &lt;Button onClick={() =&gt; setCurrentView(selectedLocation ? &#39;location&#39; : &#39;main&#39;)} variant=&quot;ghost&quot;&gt;
          &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Back
        &lt;/Button&gt;
      &lt;/div&gt;
    )
  }

  return (
    &lt;&gt;
      &lt;Toaster
        position=&quot;top-right&quot;
        expand={false}
        richColors={true}
        closeButton={false}
        offset={16}
        toastOptions={{
          duration: 7000,
          style: {
            background: &#39;hsl(var(--card))&#39;,
            color: &#39;hsl(var(--card-foreground))&#39;,
            border: &#39;1px solid hsl(var(--border))&#39;,
            borderRadius: &#39;8px&#39;,
            fontSize: &#39;14px&#39;,
            padding: &#39;12px 16px&#39;,
            zIndex: 99999,
            position: &#39;relative&#39;,
          },
          className: &#39;&#39;,
        }}
      /&gt;
      &lt;div className=&quot;min-h-screen bg-background p-4&quot;&gt;
        &lt;div className=&quot;max-w-md mx-auto&quot;&gt;
          &lt;div className=&quot;bg-card border rounded-lg p-6 shadow-sm&quot;&gt;
            &lt;h1 className=&quot;text-2xl font-bold text-center mb-6 flex items-center justify-center gap-2&quot;&gt;
              &lt;MapPin className=&quot;w-6 h-6&quot; /&gt;
              Wojak Earth
            &lt;/h1&gt;

            {currentView === &#39;main&#39; &amp;&amp; renderMainView()}
            {currentView === &#39;map&#39; &amp;&amp; renderMapView()}
            {currentView === &#39;location&#39; &amp;&amp; renderLocationView()}
            {currentView === &#39;mine&#39; &amp;&amp; renderMineView()}
            {currentView === &#39;market&#39; &amp;&amp; renderMarketView()}
            {currentView === &#39;inventory&#39; &amp;&amp; renderInventoryView()}
            {currentView === &#39;chat&#39; &amp;&amp; renderChatView()}
          &lt;/div&gt;

          {/* Game Log */}
          &lt;div className=&quot;mt-4 bg-card border rounded-lg p-4&quot;&gt;
            &lt;h4 className=&quot;font-medium mb-2&quot;&gt;Recent Activity&lt;/h4&gt;
            &lt;div className=&quot;space-y-1 text-sm&quot;&gt;
              {gameLog.map((log, i) =&gt; (
                &lt;div key={i} className=&quot;text-muted-foreground&quot;&gt;
                  {log}
                &lt;/div&gt;
              ))}
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/&gt;
  )
}

export default App
</content>
    </document>

    <document>
      <source>src/main.tsx</source>
      <tags></tags>
      <metadata>
        <size>384</size>
        <lastModified>2025-05-29T07:59:24.953Z</lastModified>
        <extension>tsx</extension>
        <directory>src</directory>
      </metadata>
      <content>import { StrictMode } from &#39;react&#39;
import { createRoot } from &#39;react-dom/client&#39;
import &#39;./index.css&#39;
import App from &#39;./App.tsx&#39;
import { ThemeProvider } from &#39;./components/theme-provider.tsx&#39;

createRoot(document.getElementById(&#39;root&#39;)!).render(
  &lt;StrictMode&gt;
    &lt;ThemeProvider defaultTheme=&quot;dark&quot; storageKey=&quot;vite-ui-theme&quot;&gt;
      &lt;App /&gt;
    &lt;/ThemeProvider&gt;
  &lt;/StrictMode&gt;,
)
</content>
    </document>

    <document>
      <source>src/App.css</source>
      <tags></tags>
      <metadata>
        <size>606</size>
        <lastModified>2025-05-28T21:44:35.041Z</lastModified>
        <extension>css</extension>
        <directory>src</directory>
      </metadata>
      <content>#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</content>
    </document>

    <document>
      <source>src/index.css</source>
      <tags></tags>
      <metadata>
        <size>4484</size>
        <lastModified>2025-05-28T21:46:42.653Z</lastModified>
        <extension>css</extension>
        <directory>src</directory>
      </metadata>
      <content>@import &quot;tailwindcss&quot;;
@import &quot;tw-animate-css&quot;;

@custom-variant dark (&amp;:is(.dark *));

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.147 0.004 49.25);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.147 0.004 49.25);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.147 0.004 49.25);
  --primary: oklch(0.216 0.006 56.043);
  --primary-foreground: oklch(0.985 0.001 106.423);
  --secondary: oklch(0.97 0.001 106.424);
  --secondary-foreground: oklch(0.216 0.006 56.043);
  --muted: oklch(0.97 0.001 106.424);
  --muted-foreground: oklch(0.553 0.013 58.071);
  --accent: oklch(0.97 0.001 106.424);
  --accent-foreground: oklch(0.216 0.006 56.043);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.923 0.003 48.717);
  --input: oklch(0.923 0.003 48.717);
  --ring: oklch(0.709 0.01 56.259);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0.001 106.423);
  --sidebar-foreground: oklch(0.147 0.004 49.25);
  --sidebar-primary: oklch(0.216 0.006 56.043);
  --sidebar-primary-foreground: oklch(0.985 0.001 106.423);
  --sidebar-accent: oklch(0.97 0.001 106.424);
  --sidebar-accent-foreground: oklch(0.216 0.006 56.043);
  --sidebar-border: oklch(0.923 0.003 48.717);
  --sidebar-ring: oklch(0.709 0.01 56.259);
}

.dark {
  --background: oklch(0.147 0.004 49.25);
  --foreground: oklch(0.985 0.001 106.423);
  --card: oklch(0.216 0.006 56.043);
  --card-foreground: oklch(0.985 0.001 106.423);
  --popover: oklch(0.216 0.006 56.043);
  --popover-foreground: oklch(0.985 0.001 106.423);
  --primary: oklch(0.923 0.003 48.717);
  --primary-foreground: oklch(0.216 0.006 56.043);
  --secondary: oklch(0.268 0.007 34.298);
  --secondary-foreground: oklch(0.985 0.001 106.423);
  --muted: oklch(0.268 0.007 34.298);
  --muted-foreground: oklch(0.709 0.01 56.259);
  --accent: oklch(0.268 0.007 34.298);
  --accent-foreground: oklch(0.985 0.001 106.423);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.553 0.013 58.071);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.216 0.006 56.043);
  --sidebar-foreground: oklch(0.985 0.001 106.423);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0.001 106.423);
  --sidebar-accent: oklch(0.268 0.007 34.298);
  --sidebar-accent-foreground: oklch(0.985 0.001 106.423);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.553 0.013 58.071);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</content>
    </document>

    <document>
      <source>tsconfig.app.json</source>
      <tags></tags>
      <metadata>
        <size>755</size>
        <lastModified>2025-05-28T21:48:18.933Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;compilerOptions&quot;: {
      &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [
        &quot;./src/*&quot;
      ]
    },
    &quot;tsBuildInfoFile&quot;: &quot;./node_modules/.tmp/tsconfig.app.tsbuildinfo&quot;,
    &quot;target&quot;: &quot;ES2020&quot;,
    &quot;useDefineForClassFields&quot;: true,
    &quot;lib&quot;: [&quot;ES2020&quot;, &quot;DOM&quot;, &quot;DOM.Iterable&quot;],
    &quot;module&quot;: &quot;ESNext&quot;,
    &quot;skipLibCheck&quot;: true,

    /* Bundler mode */
    &quot;moduleResolution&quot;: &quot;bundler&quot;,
    &quot;allowImportingTsExtensions&quot;: true,
    &quot;verbatimModuleSyntax&quot;: true,
    &quot;moduleDetection&quot;: &quot;force&quot;,
    &quot;noEmit&quot;: true,
    &quot;jsx&quot;: &quot;react-jsx&quot;,

    /* Linting */
    &quot;strict&quot;: true,
    &quot;noUnusedLocals&quot;: true,
    &quot;noUnusedParameters&quot;: true,
    &quot;noFallthroughCasesInSwitch&quot;: true,
    &quot;noUncheckedSideEffectImports&quot;: true
  },
  &quot;include&quot;: [&quot;src&quot;]
}
</content>
    </document>

    <document>
      <source>TODO.md</source>
      <tags></tags>
      <metadata>
        <size>4300</size>
        <lastModified>2025-05-29T12:58:43.062Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content>## TODO.md

# 🌍 Wojak Earth - Development Status

_Updated: May 29, 2025_

## 🎯 **Current Focus: Community &amp; Engagement**

We&#39;re building the most engaging MMO experience possible, with economic infrastructure ready to activate when player engagement warrants it.

## ✅ **Proof of Concept - Complete**

### Core Game Systems

- ✅ **Character Management** - Rich character display with real-time stats
- ✅ **World Exploration** - 12+ interconnected locations with unique themes
- ✅ **Mining System** - Location-based resource spawning with energy costs
- ✅ **Trading Economy** - Multi-tier markets with local specialties
- ✅ **Equipment System** - Visual equipment slots with auto-replacement
- ✅ **Social Features** - Regional/local chat with community building
- ✅ **Inventory Management** - Categories, consumables, materials organization

### Technical Infrastructure

- ✅ **Database Architecture** - Complete Prisma schema with 13+ models
- ✅ **API Layer** - 13 production-ready Netlify functions
- ✅ **Content Management** - Game master tools for world building
- ✅ **Real-time Systems** - Optimistic updates, toast notifications
- ✅ **Crypto-ready Backend** - Infrastructure prepared for tokenized features

### World Content

- ✅ **Rich Locations** - 7 unique regions with distinct personalities
- ✅ **Diverse Items** - 50+ items from common materials to legendary artifacts
- ✅ **Balanced Economy** - Location-based pricing and resource distribution
- ✅ **Community Features** - Player tracking, social interactions

## 🎯 **Stage 1: Community Building (Current)**

**Goal:** Prove engagement and community formation through pure gameplay

**Status:**

- Free gameplay to test community dynamics
- Focus on social interaction and player retention
- Community feedback driving feature priorities
- Engagement metrics informing next stage timing

**Metrics We&#39;re Watching:**

- Daily active players and session length
- Community-driven content creation
- Player-to-player interaction frequency
- Organic social media and word-of-mouth growth

## 🚀 **Stage 2: Soft Launch (Community Dependent)**

**Activates When:** Sustained player engagement and community requests for ownership

**Planned Features:**

- Character NFT minting (pay-to-create)
- Off-chain $EARTH economy (USDC → game currency)
- Premium cosmetics and character customization
- Community governance experiment

**Infrastructure Ready:**

- ✅ NFT metadata generation system
- ✅ Payment processing architecture
- ✅ Token balance management
- ✅ Marketplace fee structure

## 🌉 **Stage 3: Value Bridge (Stability Dependent)**

**Activates When:** Stable player base demonstrates long-term engagement

**Planned Features:**

- Mainnet $EARTH bridge (off-chain ↔ on-chain)
- Player-owned economy with real value
- DAO governance for game features
- Cross-game asset interoperability

**Infrastructure Ready:**

- ✅ Bridge contract architecture planned
- ✅ Token economics modeling complete
- ✅ Governance framework designed

## 🛠 **Game Master Capabilities (Private)**

_Demonstrating technical readiness for scaling_

- ✅ **Content Management** - Real-time world building and economy balancing
- ✅ **Community Health Monitoring** - Player behavior and engagement analytics
- ✅ **Economic Controls** - Market manipulation prevention and balance tools
- ✅ **Scalable Infrastructure** - Proven ability to handle feature deployment

## 🎮 **What Makes This Different**

1. **Community-Driven Economics** - Features activate based on player demand, not roadmaps
2. **Fun-First Design** - Game quality drives adoption, not token speculation
3. **Organic Growth** - Social features encourage genuine community building
4. **Technical Excellence** - Production-ready infrastructure with zero compromise on gameplay
5. **Patient Capital** - No rush to monetize; economics follow engagement

## 📊 **Success Definition**

**Stage 1 Success:** Daily active community with organic social interactions
**Stage 2 Success:** Players actively requesting ownership and premium features  
**Stage 3 Success:** Sustainable player-owned economy with real-world value creation

---

_We&#39;re not building a crypto game with some gameplay attached. We&#39;re building the best possible game with crypto infrastructure ready when the community wants it._
</content>
    </document>

    <document>
      <source>.gitignore</source>
      <tags></tags>
      <metadata>
        <size>292</size>
        <lastModified>2025-05-28T23:07:21.376Z</lastModified>
        <extension>gitignore</extension>
        <directory>Root</directory>
      </metadata>
      <content># Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

.env

# Local Netlify folder
.netlify
</content>
    </document>

    <document>
      <source>package.json</source>
      <tags></tags>
      <metadata>
        <size>2778</size>
        <lastModified>2025-05-29T11:14:27.449Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;name&quot;: &quot;wojak-earth&quot;,
  &quot;private&quot;: true,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;vite&quot;,
    &quot;build&quot;: &quot;prisma generate &amp;&amp; tsc -b &amp;&amp; vite build&quot;,
    &quot;lint&quot;: &quot;eslint .&quot;,
    &quot;preview&quot;: &quot;vite preview&quot;,
    &quot;db:seed&quot;: &quot;tsx prisma/seed.ts&quot;,
    &quot;setup:world&quot;: &quot;tsx scripts/ultimate-world-setup.ts&quot;,
    &quot;setup:clean&quot;: &quot;tsx scripts/ultimate-world-setup.ts&quot;,
    &quot;add:new-regions&quot;: &quot;tsx scripts/add-new-regions.ts&quot;,
    &quot;setup:new-regions&quot;: &quot;tsx scripts/setup-new-regions-content.ts&quot;,
    &quot;expand:world&quot;: &quot;npm run add:new-regions &amp;&amp; npm run setup:new-regions&quot;,
    &quot;add:items&quot;: &quot;tsx scripts/add-themed-items.ts&quot;,
    &quot;add:tools&quot;: &quot;tsx scripts/add-proper-tools.ts&quot;,
    &quot;seed:mining&quot;: &quot;tsx scripts/seed-mining-resources.ts&quot;,
    &quot;seed:mining-tools&quot;: &quot;tsx scripts/update-mining-with-tools.ts&quot;,
    &quot;seed:markets&quot;: &quot;tsx scripts/seed-enhanced-markets.ts&quot;,
    &quot;debug:markets&quot;: &quot;tsx scripts/debug-market-locations.ts&quot;,
    &quot;fix:markets&quot;: &quot;tsx scripts/fix-market-locations.ts&quot;,
    &quot;setup:unified&quot;: &quot;tsx scripts/setup-complete-game.ts&quot;,
    &quot;setup:complete&quot;: &quot;npm run add:items &amp;&amp; npm run add:tools &amp;&amp; npm run seed:mining &amp;&amp; npm run seed:mining-tools &amp;&amp; npm run fix:markets &amp;&amp; npm run seed:markets&quot;,
    &quot;setup:quick&quot;: &quot;npm run fix:markets &amp;&amp; npm run seed:markets&quot;,
    &quot;functions:dev&quot;: &quot;netlify dev&quot;,
    &quot;functions:build&quot;: &quot;netlify build&quot;,
    &quot;postinstall&quot;: &quot;prisma generate&quot;
  },
  &quot;prisma&quot;: {
    &quot;seed&quot;: &quot;tsx prisma/seed.ts&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@prisma/client&quot;: &quot;^6.8.2&quot;,
    &quot;@radix-ui/react-avatar&quot;: &quot;^1.1.10&quot;,
    &quot;@radix-ui/react-dialog&quot;: &quot;^1.1.14&quot;,
    &quot;@radix-ui/react-dropdown-menu&quot;: &quot;^2.1.15&quot;,
    &quot;@radix-ui/react-scroll-area&quot;: &quot;^1.2.9&quot;,
    &quot;@radix-ui/react-slot&quot;: &quot;^1.2.3&quot;,
    &quot;@radix-ui/react-tabs&quot;: &quot;^1.1.12&quot;,
    &quot;@radix-ui/react-tooltip&quot;: &quot;^1.2.7&quot;,
    &quot;@solana/wallet-adapter-base&quot;: &quot;^0.9.26&quot;,
    &quot;@solana/wallet-adapter-react&quot;: &quot;^0.15.38&quot;,
    &quot;@solana/wallet-adapter-wallets&quot;: &quot;^0.19.36&quot;,
    &quot;@solana/web3.js&quot;: &quot;^1.98.2&quot;,
    &quot;@tailwindcss/vite&quot;: &quot;^4.1.8&quot;,
    &quot;class-variance-authority&quot;: &quot;^0.7.1&quot;,
    &quot;clsx&quot;: &quot;^2.1.1&quot;,
    &quot;lucide-react&quot;: &quot;^0.511.0&quot;,
    &quot;next-themes&quot;: &quot;^0.4.6&quot;,
    &quot;prisma&quot;: &quot;^6.8.2&quot;,
    &quot;react&quot;: &quot;^19.1.0&quot;,
    &quot;react-dom&quot;: &quot;^19.1.0&quot;,
    &quot;sonner&quot;: &quot;^2.0.3&quot;,
    &quot;tailwind-merge&quot;: &quot;^3.3.0&quot;,
    &quot;tailwindcss&quot;: &quot;^4.1.8&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@eslint/js&quot;: &quot;^9.25.0&quot;,
    &quot;@types/node&quot;: &quot;^22.15.24&quot;,
    &quot;@types/react&quot;: &quot;^19.1.2&quot;,
    &quot;@types/react-dom&quot;: &quot;^19.1.2&quot;,
    &quot;@vitejs/plugin-react&quot;: &quot;^4.4.1&quot;,
    &quot;eslint&quot;: &quot;^9.25.0&quot;,
    &quot;eslint-plugin-react-hooks&quot;: &quot;^5.2.0&quot;,
    &quot;eslint-plugin-react-refresh&quot;: &quot;^0.4.19&quot;,
    &quot;globals&quot;: &quot;^16.0.0&quot;,
    &quot;tsx&quot;: &quot;^4.19.4&quot;,
    &quot;tw-animate-css&quot;: &quot;^1.3.0&quot;,
    &quot;typescript&quot;: &quot;~5.8.3&quot;,
    &quot;typescript-eslint&quot;: &quot;^8.30.1&quot;,
    &quot;vite&quot;: &quot;^6.3.5&quot;
  }
}
</content>
    </document>

    <document>
      <source>.env</source>
      <tags></tags>
      <metadata>
        <size>135</size>
        <lastModified>2025-05-28T21:52:13.504Z</lastModified>
        <extension>env</extension>
        <directory>Root</directory>
      </metadata>
      <content>DATABASE_URL=postgresql://neondb_owner:npg_su0rywczKEv9@ep-lively-river-a6lm0x4f-pooler.us-west-2.aws.neon.tech/neondb?sslmode=require
</content>
    </document>

    <document>
      <source>components.json</source>
      <tags></tags>
      <metadata>
        <size>423</size>
        <lastModified>2025-05-28T21:46:42.115Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;$schema&quot;: &quot;https://ui.shadcn.com/schema.json&quot;,
  &quot;style&quot;: &quot;new-york&quot;,
  &quot;rsc&quot;: false,
  &quot;tsx&quot;: true,
  &quot;tailwind&quot;: {
    &quot;config&quot;: &quot;&quot;,
    &quot;css&quot;: &quot;src/index.css&quot;,
    &quot;baseColor&quot;: &quot;stone&quot;,
    &quot;cssVariables&quot;: true,
    &quot;prefix&quot;: &quot;&quot;
  },
  &quot;aliases&quot;: {
    &quot;components&quot;: &quot;@/components&quot;,
    &quot;utils&quot;: &quot;@/lib/utils&quot;,
    &quot;ui&quot;: &quot;@/components/ui&quot;,
    &quot;lib&quot;: &quot;@/lib&quot;,
    &quot;hooks&quot;: &quot;@/hooks&quot;
  },
  &quot;iconLibrary&quot;: &quot;lucide&quot;
}</content>
    </document>

    <document>
      <source>tsconfig.json</source>
      <tags></tags>
      <metadata>
        <size>233</size>
        <lastModified>2025-05-28T21:45:45.831Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;files&quot;: [],
  &quot;references&quot;: [
    {
      &quot;path&quot;: &quot;./tsconfig.app.json&quot;
    },
    {
      &quot;path&quot;: &quot;./tsconfig.node.json&quot;
    }
  ],
  &quot;compilerOptions&quot;: {
    &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [&quot;./src/*&quot;]
    }
  }
}
</content>
    </document>

    <document>
      <source>vite.config.ts</source>
      <tags></tags>
      <metadata>
        <size>327</size>
        <lastModified>2025-05-28T21:46:16.230Z</lastModified>
        <extension>ts</extension>
        <directory>Root</directory>
      </metadata>
      <content>import path from &#39;path&#39;
import tailwindcss from &#39;@tailwindcss/vite&#39;
import react from &#39;@vitejs/plugin-react&#39;
import { defineConfig } from &#39;vite&#39;

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      &#39;@&#39;: path.resolve(__dirname, &#39;./src&#39;),
    },
  },
})
</content>
    </document>

    <document>
      <source>eslint.config.js</source>
      <tags></tags>
      <metadata>
        <size>734</size>
        <lastModified>2025-05-28T21:44:35.037Z</lastModified>
        <extension>js</extension>
        <directory>Root</directory>
      </metadata>
      <content>import js from &#39;@eslint/js&#39;
import globals from &#39;globals&#39;
import reactHooks from &#39;eslint-plugin-react-hooks&#39;
import reactRefresh from &#39;eslint-plugin-react-refresh&#39;
import tseslint from &#39;typescript-eslint&#39;

export default tseslint.config(
  { ignores: [&#39;dist&#39;] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: [&#39;**/*.{ts,tsx}&#39;],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      &#39;react-hooks&#39;: reactHooks,
      &#39;react-refresh&#39;: reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      &#39;react-refresh/only-export-components&#39;: [
        &#39;warn&#39;,
        { allowConstantExport: true },
      ],
    },
  },
)
</content>
    </document>

    <document>
      <source>WHITEPAPER.md</source>
      <tags></tags>
      <metadata>
        <size>8174</size>
        <lastModified>2025-05-29T13:03:30.347Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content># 🌍 $EARTH Token Infrastructure

_Economic Foundation for Community-Driven Gaming_

---

## Executive Summary

$EARTH is the **planned economic infrastructure** for Wojak Earth, a social exploration MMO that prioritizes community engagement over premature monetization.

Unlike traditional crypto games that launch with tokenomics first, $EARTH is designed as **staged economic infrastructure** that activates only when the community demonstrates sustained engagement and explicitly requests ownership features.

---

## Design Philosophy

### Community-First Economics

- **Engagement drives activation** - Features deploy based on player demand, not roadmaps
- **Fun before finance** - Game quality must prove itself before introducing economic complexity
- **Organic growth** - Social interactions and community building create sustainable foundation
- **Patient capital** - No rush to monetize; let genuine economies emerge naturally

### Technical Readiness Without Premature Activation

- Complete token infrastructure built and tested
- Economic models proven in off-chain environment
- Bridge contracts designed but not deployed
- **Capability demonstrated, timeline community-driven**

---

## Staged Activation Model

### Stage 1: Community Building _(Current)_

**Status:** Proof of concept with free gameplay
**Focus:** Social interaction, player retention, community formation
**Economics:** None - pure gameplay engagement
**Success Metrics:** Daily active players, session length, organic social growth

### Stage 2: Soft Launch _(Community-Driven)_

**Activates When:** Players actively request ownership and premium features
**Features:**

- Character NFT minting (pay-to-create with USDC/SOL)
- Off-chain $EARTH economy (1 USDC → 1,000 $EARTH, configurable)
- Premium cosmetics and character customization options
- Community governance experiments

**Economic Structure:**

- **Sources:** SPL token purchases, in-game rewards for sustained engagement
- **Sinks:** Premium features, cosmetics, marketplace fees, travel costs
- **Balance:** Designed for sustainability, not speculation

### Stage 3: Value Bridge _(Stability-Dependent)_

**Activates When:** Stable player base with proven economic sustainability
**Features:**

- Off-chain ↔ On-chain $EARTH bridge
- Real SPL token with DEX liquidity
- Player-owned marketplace with actual asset ownership
- DAO governance for game feature development

**Bridge Mechanics:**

- **Withdraw:** Burn off-chain $EARTH → Mint on-chain SPL tokens
- **Deposit:** Send SPL $EARTH → Credit off-chain balance
- **Rate Limits:** Prevent economic manipulation and ensure stability

---

## Token Distribution _(When On-Chain)_

| Allocation         | Percentage | Purpose                               |
| ------------------ | ---------- | ------------------------------------- |
| Player Bridge      | 50%        | On-demand minting via withdrawals     |
| Community Treasury | 25%        | Events, liquidity, governance         |
| Development Fund   | 15%        | Team alignment, long-term development |
| Ecosystem Growth   | 10%        | Partnerships, community incentives    |

**Supply Model:** Dynamic based on actual bridge demand, not speculative allocation

---

## Economic Sustainability

### Balanced Sink/Source Design

**Token Sources:**

- SPL token purchases (primary revenue)
- In-game achievements and community participation
- Marketplace transaction rewards
- Seasonal events and community challenges

**Token Sinks:**

- Premium character features and cosmetics
- Marketplace listing fees and transaction costs
- Travel to premium locations
- Crafting and equipment enhancement
- Community event participation costs

### Anti-Speculation Measures

- **Utility-first design** - Tokens valuable for gameplay, not just trading
- **Community governance** - Players control economic parameters
- **Gradual activation** - No sudden economic shocks or massive token unlocks
- **Sustainable revenue** - Multiple income streams beyond token appreciation

---

## Revenue Model

### Stage 2 Revenue Streams

- Direct SPL token → $EARTH purchases
- Character NFT minting fees
- Premium feature subscriptions
- Marketplace transaction fees

### Stage 3 Additional Revenue

- Bridge transaction fees (minimal, sustainability-focused)
- Liquidity provision rewards
- Governance token mechanisms
- Cross-game interoperability partnerships

**Focus:** Sustainable revenue from engaged players, not speculative trading

---

## Risk Management

### Community Protection

- **No premature monetization** - Economics activate only when community is ready
- **Transparent governance** - Community controls economic parameters
- **Fair launch principles** - No insider advantages or hidden allocations
- **Sustainable design** - Long-term player value over short-term speculation

### Technical Safeguards

- **Battle-tested infrastructure** - All systems proven in off-chain environment
- **Gradual rollout** - Staged activation allows for adjustment and learning
- **Emergency controls** - Ability to pause or adjust economic features if needed
- **Community override** - Players can vote to modify or disable features

---

## Success Metrics

### Stage 1 (Current)

- Daily active users and session duration
- Community-generated content and social interactions
- Organic growth and word-of-mouth adoption
- Player feedback quality and engagement depth

### Stage 2 (Soft Launch)

- Premium feature adoption rates
- Community satisfaction with economic features
- Sustainable revenue generation
- Maintained gameplay quality despite monetization

### Stage 3 (Value Bridge)

- Healthy on-chain token economics
- Active player-owned marketplace
- Community governance participation
- Cross-ecosystem interoperability success

---

## Governance Framework

### Community Decision Making

- **Economic Parameters** - Community votes on token distribution rates, fees, and economic rules
- **Feature Activation** - Players decide when and how new economic features are introduced
- **Revenue Allocation** - Community determines how generated revenue is reinvested
- **Emergency Measures** - Collective decision-making for economic adjustments

### Developer Responsibilities

- **Technical Infrastructure** - Maintain and improve game systems and economic tools
- **Community Support** - Facilitate governance processes and implement community decisions
- **Transparency** - Regular reporting on economic health and development progress
- **Long-term Vision** - Balance community requests with sustainable development

---

## Conclusion

$EARTH represents a **fundamental shift in crypto gaming economics** - from speculation-driven token launches to community-driven value creation.

By building exceptional gameplay first and introducing economics only when the community demonstrates readiness, we create sustainable foundations for player-owned economies that enhance rather than replace the core gaming experience.

**This is patient capital applied to community building - the future of sustainable crypto gaming.**

---

## Technical Appendix

### Infrastructure Readiness Checklist

- ✅ Complete off-chain token management system
- ✅ NFT metadata generation and character rendering
- ✅ Marketplace infrastructure with fee structures
- ✅ Bridge contract architecture (designed, not deployed)
- ✅ Governance voting mechanisms (ready to activate)
- ✅ Economic monitoring and adjustment tools
- ✅ Community feedback and decision-making systems

### Integration Points

- **Payment Processing:** USDC/SOL → $EARTH conversion ready
- **NFT Minting:** Character and item tokenization infrastructure complete
- **Bridge Contracts:** Off-chain ↔ On-chain conversion mechanisms designed
- **Governance Tools:** Community voting and parameter adjustment systems built
- **Analytics:** Economic health monitoring and community sentiment tracking

**Status:** All technical infrastructure complete and tested. Activation timeline dependent entirely on community engagement and explicit request for these features.

---

_Building the economic infrastructure that communities deserve - ready when they are, not before._
</content>
    </document>

    <document>
      <source>PITCHDECK.md</source>
      <tags></tags>
      <metadata>
        <size>4487</size>
        <lastModified>2025-05-29T13:01:27.667Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content># 🎯 Wojak Earth - Community-Driven MMO

_Investor Pitch: Building Engagement Before Economics_

---

## 🌍 **Slide 1: Vision**

**Wojak Earth**
_The MMO that activates tokenomics when the community is ready_

&gt; **We&#39;re proving that great games build great economies, not the other way around.**

---

## 🎮 **Slide 2: What We&#39;re Building**

**A Social Exploration MMO with Crypto-Ready Infrastructure**

- Rich multiplayer world with mining, trading, and crafting
- Real-time social features and community building
- Economic infrastructure ready for staged activation
- **Fun-first design** with tokenomics that activate based on engagement

---

## 📊 **Slide 3: Staged Development Model**

**Stage 1: Proof of Engagement** _(Current)_

- Free gameplay focused on community building
- Measuring player retention and social interaction
- **Success Metric:** Sustained daily active community

**Stage 2: Soft Launch** _(Community-Driven)_

- Character NFT minting and off-chain $EARTH economy
- Premium features for engaged community members
- **Success Metric:** Players actively requesting ownership features

**Stage 3: Value Bridge** _(Stability-Dependent)_

- Mainnet $EARTH with real-world value extraction
- Player-owned economy and governance
- **Success Metric:** Sustainable economic ecosystem

---

## 🛠 **Slide 4: Technical Readiness**

**Complete Game Infrastructure** _(Ready Today)_

- 13 production-grade API endpoints
- Real-time multiplayer systems
- Comprehensive content management tools
- **Crypto infrastructure built but not activated**

**Why This Approach Works:**

- Prove product-market fit before monetization
- Build genuine community before introducing economics
- Technical capability demonstrated, timeline driven by engagement

---

## 💰 **Slide 5: Economics When Ready**

**$EARTH Token - Infrastructure Complete**

**Off-Chain Phase:**

- USDC/SOL → $EARTH purchases for premium features
- In-game economy with sustainable sink/source balance
- Community governance experiments

**Bridge Phase:**

- Off-chain ↔ On-chain $EARTH conversion
- Real value extraction for engaged players
- Player-owned marketplace with actual ownership

---

## 📈 **Slide 6: Market Opportunity**

**The Problem with Crypto Gaming:**

- Token-first approach creates unsustainable economies
- Players abandon games when speculation ends
- Community building takes backseat to financialization

**Our Solution:**

- **Community-first approach** builds lasting engagement
- **Technical readiness** without premature monetization
- **Organic economics** that emerge from genuine player demand

---

## 🎯 **Slide 7: Competitive Advantage**

**What Makes Us Different:**

1. **Patience** - We don&#39;t monetize until community demands it
2. **Technical Excellence** - Production-ready infrastructure proves capability
3. **Community Focus** - Social features drive retention, not token rewards
4. **Flexible Monetization** - Multiple revenue streams ready when appropriate
5. **Sustainable Design** - Economics support gameplay, not replace it

---

## 📊 **Slide 8: Current Traction**

**Proof of Concept Metrics:**

- Complete MMO systems with 50+ items and 12+ locations
- Rich social features and community tools
- Production-ready infrastructure handling all game systems
- **Zero player acquisition cost** during community building phase

**Development Stage Advantages:**

- Iterate based on player feedback, not token price
- Build sustainable engagement before introducing economics
- Prove technical capability to investors and community

---

## 💼 **Slide 9: Investment Opportunity**

**We&#39;re Seeking Strategic Partners For:**

- Community building and player acquisition
- Technical infrastructure scaling
- Economic activation when community demonstrates readiness
- **Long-term vision alignment** over quick monetization

**Not Seeking:**

- Pressure for premature token launch
- Rush to monetize before community is ready
- Compromise on game quality for economic features

---

## 🚀 **Slide 10: The Vision**

**Wojak Earth represents the future of sustainable gaming economies**

- **Stage 1:** Prove we can build engaging communities
- **Stage 2:** Show we can monetize without destroying fun
- **Stage 3:** Demonstrate sustainable player-owned economies

**This isn&#39;t just a game or just a token - it&#39;s a new model for community-driven entertainment.**

---

_Join us in building the first MMO where economics serve the community, not the other way around._
</content>
    </document>

    <document>
      <source>NFT.md</source>
      <tags></tags>
      <metadata>
        <size>10292</size>
        <lastModified>2025-05-29T13:22:36.411Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content># 🎨 Wojak Earth - Dynamic Character NFT System

_Living NFTs That Evolve With Your Journey_

---

## The Innovation

**Your character NFT isn&#39;t just a static image - it&#39;s a living visual representation of your entire gaming journey.**

Every action you take, every item you equip, every location you visit, and every achievement you unlock dynamically updates your NFT&#39;s appearance in real-time. Your character becomes a visual autobiography of your adventures in Wojak Earth.

---

## How It Works

### **Dynamic Layer Composition**

Your character NFT is built from multiple visual layers that change based on your game state:

**Base Layers:**

- Character type (Human, Creature, etc.)
- Gender and core appearance
- Current location background

**Equipment Layers:**

- Head slot (hats, helmets, headwear)
- Body slot (clothing, armor, jackets)
- Accessory slot (jewelry, charms, tools)
- Tool slot (weapons, mining equipment)

**Status Layers:**

- Health/energy visual effects (glows, auras)
- Achievement badges and rank indicators
- Environmental effects (weather, biome-specific)
- Temporary status effects (potions, buffs)

### **Real-Time Rendering Pipeline**

```
Game Action → Layer Update → NFT Recomposition → Metadata Refresh → Visual Update
```

1. **Player Action** - Equip item, visit location, achieve milestone
2. **Layer Resolution** - System determines which visual layers to show/hide
3. **Dynamic Rendering** - Layers composited into final character image
4. **Metadata Update** - NFT traits and attributes automatically updated
5. **Live Refresh** - Character image updates across all platforms instantly

---

## Visual Evolution Examples

### **Equipment Changes**

```
Base Wojak → Equips Miner&#39;s Hat → NFT shows character wearing hat
             Adds Cyber Jacket → NFT updates with jacket layer
             Finds Lucky Charm → Charm appears as accessory
```

### **Location-Based Backgrounds**

```
Mining Plains → Desert sand and heat shimmer background
Cyber City → Neon lights and urban skyline
Crystal Caves → Glowing crystal formations
Glitch Wastes → Corrupted digital artifacts
```

### **Achievement Overlays**

```
First Epic Item Found → Golden aura effect
Mining Milestone → Specialized tool glow
Community Leader → Leadership badge
Legendary Discovery → Unique particle effects
```

### **Status Effects**

```
Low Health → Red warning glow
High Energy → Vibrant energy aura
Potion Active → Swirling magical effects
Weather Events → Environmental overlays
```

---

## Technical Architecture

### **Layer Management System**

- **Layer Types:** Background, Base, Clothing, Accessories, Overlays, Effects
- **Z-Index Ordering:** Automatic depth management for proper visual stacking
- **Conflict Resolution:** Smart handling of incompatible items (can&#39;t wear two hats)
- **Performance Optimization:** Efficient layer caching and delta updates

### **Rendering Engine**

- **Canvas Compositing:** HTML5 Canvas for real-time layer combination
- **Asset Pipeline:** Optimized PNG layers with transparency support
- **Quality Scaling:** Multiple resolution outputs (thumbnail, standard, high-res)
- **Format Support:** PNG for viewing, SVG for scalability, WebP for optimization

### **Metadata Integration**

```json
{
  &quot;name&quot;: &quot;Wojak #1337&quot;,
  &quot;description&quot;: &quot;A legendary miner currently exploring Crystal Caves...&quot;,
  &quot;image&quot;: &quot;https://wojak-earth.com/nft/1337.png&quot;,
  &quot;attributes&quot;: [
    { &quot;trait_type&quot;: &quot;Location&quot;, &quot;value&quot;: &quot;Crystal Caves&quot; },
    { &quot;trait_type&quot;: &quot;Hat&quot;, &quot;value&quot;: &quot;Miner&#39;s Helmet&quot; },
    { &quot;trait_type&quot;: &quot;Tool&quot;, &quot;value&quot;: &quot;Crystal Pickaxe&quot; },
    { &quot;trait_type&quot;: &quot;Status&quot;, &quot;value&quot;: &quot;Legendary Finder&quot; },
    { &quot;trait_type&quot;: &quot;Energy&quot;, &quot;value&quot;: 85, &quot;max_value&quot;: 100 }
  ],
  &quot;properties&quot;: {
    &quot;layers&quot;: [
      &quot;background-crystal-caves&quot;,
      &quot;base-male&quot;,
      &quot;hat-miners-helmet&quot;,
      &quot;tool-crystal-pickaxe&quot;
    ],
    &quot;last_updated&quot;: &quot;2025-05-29T12:00:00Z&quot;,
    &quot;game_version&quot;: &quot;1.2.3&quot;
  }
}
```

---

## NFT Features

### **Dynamic Traits**

Your NFT traits update automatically based on game state:

- **Current Location** - Always shows where you are
- **Equipped Items** - Displays all visible gear
- **Stats** - Real-time health, energy, level display
- **Achievements** - Permanent record of accomplishments
- **Activity Status** - Online/offline, current action

### **Historical Preservation**

While your NFT shows current state, we preserve your journey:

- **Version History** - Every significant change saved
- **Achievement Gallery** - Permanent record of all accomplishments
- **Equipment Archive** - Gallery of all items you&#39;ve owned
- **Location Log** - Travel history across all regions

### **Rarity Evolution**

Your character&#39;s rarity can increase through gameplay:

- **Base Rarity** - Determined at mint (Common, Uncommon, Rare)
- **Achievement Bonuses** - Legendary actions increase effective rarity
- **Equipment Influence** - Rare gear affects overall character rarity
- **Community Recognition** - Player voting can elevate status

---

## Use Cases &amp; Benefits

### **For Players**

- **Visual Progression** - See your journey reflected in your character&#39;s appearance
- **Social Status** - Rare equipment and achievements visible to others
- **Personal Investment** - Your NFT becomes more unique through your actions
- **Bragging Rights** - Legendary items and locations permanently displayed

### **For Communities**

- **Guild Recognition** - Team achievements shown on individual characters
- **Event Participation** - Special events leave permanent visual marks
- **Social Proof** - Active players stand out visually from inactive accounts
- **Community Building** - Shared visual elements create group identity

### **For Collectors**

- **Living Investment** - NFT value increases with player achievement
- **Unique Combinations** - Impossible to fake rare equipment/location combinations
- **Provable Scarcity** - Achievement-based rarity is verifiable and meaningful
- **Market Dynamics** - Active characters command premium over static ones

---

## Implementation Stages

### **Stage 1: Infrastructure** ✅

- Layer composition system built and tested
- Metadata generation pipeline complete
- Real-time rendering engine operational
- Basic equipment visualization working

### **Stage 2: Enhancement** 🎯

- Advanced status effects and overlays
- Location-specific environmental effects
- Achievement badge and milestone markers
- Social recognition visual elements

### **Stage 3: Advanced Features** 🚀

- Community-driven layer creation
- Custom cosmetic options
- Cross-game interoperability
- AR/VR character display

---

## Economic Impact

### **NFT Value Drivers**

- **Activity Premium** - Active characters worth more than inactive
- **Achievement Rarity** - Legendary accomplishments increase value
- **Equipment Display** - Rare gear visible in NFT increases desirability
- **Historical Significance** - First-to-achieve status creates collectible value

### **Market Dynamics**

- **Engagement Rewards** - Playing the game literally increases NFT value
- **Social Proof** - Visual achievements create status and demand
- **Collector Appeal** - Dynamic evolution creates ongoing interest
- **Utility Value** - NFT serves functional purpose beyond speculation

---

## Technical Specifications

### **Layer Assets**

- **Resolution:** 512x512 base, scalable to 2048x2048
- **Format:** PNG with alpha transparency
- **Optimization:** WebP for web, PNG for permanent storage
- **Naming Convention:** `{type}-{category}-{item-name}.png`

### **Rendering Performance**

- **Composition Time:** &lt;200ms for standard character
- **Cache Strategy:** Layer combinations cached for 24 hours
- **Update Frequency:** Real-time for equipment, hourly for status
- **Fallback System:** Static images if rendering fails

### **API Endpoints**

```
GET /nft/{characterId}.png        - Current character image
GET /nft/{characterId}/metadata   - Full NFT metadata
GET /nft/{characterId}/layers     - Layer composition details
GET /nft/{characterId}/history    - Visual evolution timeline
```

---

## Privacy &amp; Control

### **Player Control**

- **Visibility Settings** - Choose what aspects are publicly visible
- **Historical Opt-out** - Remove specific achievements from display
- **Equipment Privacy** - Hide valuable items if desired
- **Status Broadcasting** - Control real-time activity sharing

### **Data Security**

- **On-chain Metadata** - Core traits stored on blockchain
- **Decentralized Images** - Visual assets on IPFS/Arweave
- **Player Ownership** - Complete control over NFT and associated data
- **Privacy by Design** - Only publicly opt-in information displayed

---

## Future Vision

**Your Wojak Earth character NFT becomes the ultimate gaming passport:**

- **Cross-Game Identity** - Visual representation carries across different games
- **Achievement Portfolio** - Permanent record of all gaming accomplishments
- **Social Credential** - Proof of skill, dedication, and community contribution
- **Investment Asset** - Value that grows with your gaming journey
- **Digital Legacy** - Permanent artifact of your virtual adventures

---

## Getting Started

### **Minting Your Character** _(Stage 2 Feature)_

1. **Play First** - Build your character through gameplay
2. **Mint When Ready** - Convert your character to NFT when desired
3. **Visual History** - All your progress becomes part of the NFT
4. **Ongoing Evolution** - Continue playing, keep evolving your NFT

### **Viewing Your NFT**

- **In-Game Display** - See your character in all its dynamic glory
- **Wallet Integration** - Standard NFT display in any compatible wallet
- **Social Sharing** - Export high-res images for social media
- **Marketplace Display** - Full visual presentation on NFT platforms

---

_Your journey creates your NFT. Your NFT tells your story._

---

## Technical Deep Dive

For developers and technical stakeholders interested in implementation details, see our [Layer Resolution System Documentation](./src/lib/layerResolver.ts) and [NFT Metadata Generation](./netlify/functions/metadata.js) source code.

---

_This represents the future of gaming NFTs - not static pictures, but living, breathing visual representations of player achievement and community participation._
</content>
    </document>

    <document>
      <source>README.md</source>
      <tags></tags>
      <metadata>
        <size>1111</size>
        <lastModified>2025-05-29T13:12:00.912Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content># 🌍 Wojak Earth

A social exploration MMO where players mine, trade, craft, and build communities across interconnected worlds.

## Current Status

**Proof of Concept** - Fully functional game systems with crypto-ready infrastructure

## What We&#39;re Building

- **Community-first MMO** with rich social interactions
- **Engaging gameplay** across mining, trading, crafting, and exploration
- **Crypto-ready architecture** that activates based on player engagement
- **Organic economy** that grows with the community

## Key Features

- ✅ Complete inventory and equipment system
- ✅ Multi-location world with unique biomes
- ✅ Real-time chat and social features
- ✅ Resource mining and crafting mechanics
- ✅ Player-driven marketplace
- ✅ Infrastructure ready for tokenized features

## Development Philosophy

**Fun-first, crypto-ready** - We build the best possible game experience, with economic features that activate when the community demonstrates sustained engagement.

## Getting Started

```bash
npm install
npm run setup:world  # Complete game setup
npm run dev          # Start development server
```
</content>
    </document>

    <document>
      <source>LITEPAPER.md</source>
      <tags></tags>
      <metadata>
        <size>6107</size>
        <lastModified>2025-05-29T13:15:03.925Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content># 🌍 Wojak Earth - Litepaper

_Community-First MMO with Crypto-Ready Infrastructure_

---

## The Problem

**Crypto games launch backwards.** They start with tokenomics, add gameplay as an afterthought, and wonder why communities abandon them when speculation ends.

Players don&#39;t want to &quot;play to earn&quot; - they want to **play to enjoy**, with earning as an organic possibility that emerges from genuine engagement.

---

## Our Approach

**Build the best possible game first. Add economics when the community asks for them.**

Wojak Earth is a social exploration MMO where players mine, trade, craft, and build communities across interconnected worlds. We&#39;ve built complete crypto infrastructure - NFT systems, token economics, bridge contracts - but **none of it is active.**

Instead, we&#39;re focused entirely on what matters: **creating engaging social experiences that make players want to log in every day.**

---

## Why This Works

### 1. **Sustainable Community Building**

Free gameplay removes financial pressure and speculation. Players join for fun, stay for community, and create organic social bonds that last beyond market cycles.

### 2. **Proven Technical Capability**

We&#39;ve built production-ready crypto infrastructure alongside exceptional gameplay systems. Investors can see we&#39;re technically capable without the risk of premature monetization.

### 3. **Market Timing Control**

We activate economic features when the community demonstrates sustained engagement, not when we need revenue. This creates sustainable growth rather than speculative bubbles.

### 4. **Authentic Player Demand**

When players start asking &quot;Can I own my character?&quot; and &quot;Can I trade items for real value?&quot;, we know they&#39;re genuinely engaged, not just speculating.

---

## Current Status

**Proof of Concept Complete** - Full MMO systems with crypto infrastructure ready

### Game Systems ✅

- Multi-region world with unique biomes and communities
- Complete inventory, equipment, and crafting systems
- Real-time chat and social features
- Resource mining and player-driven marketplace
- Rich character progression and customization

### Crypto Infrastructure ✅ (Built, Not Active)

- NFT metadata and character rendering systems
- Token economics modeling and balance testing
- Payment processing and wallet integration
- Bridge contracts designed for future deployment
- Community governance frameworks

---

## Staged Activation Model

### **Stage 1: Community Building** _(Current)_

- **Focus:** Social engagement, player retention, organic growth
- **Economics:** None - completely free gameplay
- **Success Metric:** Daily active community with genuine social interactions

### **Stage 2: Soft Launch** _(Community-Driven)_

- **Activates When:** Players actively request ownership features
- **Features:** Character NFT minting, off-chain $EARTH economy, premium cosmetics
- **Success Metric:** Sustained revenue from engaged players, not speculators

### **Stage 3: Value Bridge** _(Stability-Dependent)_

- **Activates When:** Stable player base with proven economic sustainability
- **Features:** Mainnet $EARTH bridge, player-owned marketplace, DAO governance
- **Success Metric:** Thriving player-owned economy with real-world value creation

---

## What Makes This Different

### **Patient Capital Approach**

We&#39;re not rushing to monetize. We&#39;re building sustainable foundations that can support tokenized features when the community genuinely wants them.

### **Technical Excellence First**

Our crypto infrastructure is production-ready, but we&#39;re proving game quality and community engagement before activating economic features.

### **Community-Driven Timeline**

Features activate based on player demand and engagement metrics, not arbitrary roadmap dates or funding pressure.

### **Sustainable by Design**

When economics do activate, they&#39;re designed to enhance gameplay and community building, not replace them with financial speculation.

---

## The Vision

**Wojak Earth represents the future of crypto gaming:**

- Communities built on shared experiences, not shared investments
- Economic features that emerge organically from player engagement
- Technical capability demonstrated through exceptional gameplay
- Patient development that prioritizes long-term sustainability

We&#39;re proving that the best crypto games are first and foremost **great games** - with tokenomics that activate when they can genuinely enhance the player experience.

---

## For Investors

We&#39;re seeking partners who understand that **sustainable crypto gaming requires patience and community-first thinking.**

**What we offer:**

- Proven technical capability across both gaming and crypto systems
- Clear community-driven activation model with measurable milestones
- Sustainable revenue potential without speculative risk
- Long-term vision for player-owned economies built on genuine engagement

**What we&#39;re not:**

- A quick token flip opportunity
- A game disguised as DeFi yield farming
- A project that prioritizes tokenomics over player experience
- A team that will compromise game quality for faster monetization

---

## Next Steps

**Join our community** and see what community-first gaming looks like. Experience the gameplay, participate in the social systems, and help us build the foundation for sustainable crypto gaming.

When you&#39;re ready to own your character, trade items for real value, and participate in governing the game&#39;s future - those features will be ready too.

**But first, let&#39;s build something worth owning.**

---

_Wojak Earth - Where community builds the economy, not the other way around._

---

## Quick Links

- **Play the Game:** [earth.ndao.computer](https://earth.ndao.computer)
- **Community:** Join our community channels for updates
- **Documentation:** [Full Technical Details](./WHITEPAPER.md)
- **Investment Deck:** [Detailed Investor Presentation](./PITCHDECK.md)

---

_This litepaper serves as an introduction to our approach. For detailed tokenomics, technical specifications, and investment opportunities, see our complete documentation suite._
</content>
    </document>

    <document>
      <source>tsconfig.node.json</source>
      <tags></tags>
      <metadata>
        <size>598</size>
        <lastModified>2025-05-28T21:46:21.462Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;compilerOptions&quot;: {
    &quot;tsBuildInfoFile&quot;: &quot;./node_modules/.tmp/tsconfig.node.tsbuildinfo&quot;,
    &quot;target&quot;: &quot;ES2022&quot;,
    &quot;lib&quot;: [&quot;ES2023&quot;],
    &quot;module&quot;: &quot;ESNext&quot;,
    &quot;skipLibCheck&quot;: true,

    /* Bundler mode */
    &quot;moduleResolution&quot;: &quot;bundler&quot;,
    &quot;allowImportingTsExtensions&quot;: true,
    &quot;verbatimModuleSyntax&quot;: true,
    &quot;moduleDetection&quot;: &quot;force&quot;,
    &quot;noEmit&quot;: true,

    /* Linting */
    &quot;strict&quot;: true,
    &quot;noUnusedLocals&quot;: true,
    &quot;noUnusedParameters&quot;: true,
    &quot;noFallthroughCasesInSwitch&quot;: true,
    &quot;noUncheckedSideEffectImports&quot;: true
  },
  &quot;include&quot;: [&quot;vite.config.ts&quot;]
}
</content>
    </document>

    <document>
      <source>index.html</source>
      <tags></tags>
      <metadata>
        <size>367</size>
        <lastModified>2025-05-28T21:48:47.451Z</lastModified>
        <extension>html</extension>
        <directory>Root</directory>
      </metadata>
      <content>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/wojak-earth.svg&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;wojak-earth&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;module&quot; src=&quot;/src/main.tsx&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</content>
    </document>
    
  </documents>

</bundle>