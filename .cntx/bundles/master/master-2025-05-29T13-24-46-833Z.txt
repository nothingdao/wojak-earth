<?xml version="1.0" encoding="UTF-8"?>
<bundle id="master-2025-05-29T13-24-46-833Z" created="2025-05-29T13:24:46.833Z" fileCount="70">
  
  <metadata>
    <projectName>project</projectName>
    <totalFiles>70</totalFiles>
    <bundleType>master</bundleType>
    <ignorePatterns>
      <pattern>node_modules</pattern>
      <pattern>.git</pattern>
      <pattern>dist</pattern>
      <pattern>build</pattern>
      <pattern>coverage</pattern>
      <pattern>.next</pattern>
      <pattern>.cache</pattern>
      <pattern>.netlify</pattern>
      <pattern>package-lock.json</pattern>
      <pattern>yarn.lock</pattern>
      <pattern>.DS_Store</pattern>
      <pattern>Thumbs.db</pattern>
      <pattern>*.mp3</pattern>
      <pattern>*.mp4</pattern>
      <pattern>*.wav</pattern>
      <pattern>*.ogg</pattern>
      <pattern>*.m4a</pattern>
      <pattern>*.flac</pattern>
      <pattern>*.jpg</pattern>
      <pattern>*.jpeg</pattern>
      <pattern>*.gif</pattern>
      <pattern>*.webp</pattern>
      <pattern>*.svg</pattern>
      <pattern>*.ico</pattern>
      <pattern>*.pxd</pattern>
      <pattern>*.pdf</pattern>
      <pattern>*.doc</pattern>
      <pattern>*.docx</pattern>
      <pattern>*.zip</pattern>
      <pattern>*.tar</pattern>
      <pattern>*.gz</pattern>
      <pattern>*.rar</pattern>
      <pattern>*.png</pattern>
    </ignorePatterns>
  </metadata>

  <directoryTree>
  <directory name="netlify" path="netlify">
    <directory name="functions" path="netlify/functions">
      <file name="buy-item.js" path="netlify/functions/buy-item.js" size="0" lastModified="2025-05-29T03:25:43.591Z">
        <tags></tags>
      </file>
      <file name="equip-item.js" path="netlify/functions/equip-item.js" size="0" lastModified="2025-05-29T05:38:49.985Z">
        <tags></tags>
      </file>
      <file name="get-character.js" path="netlify/functions/get-character.js" size="0" lastModified="2025-05-28T23:17:38.002Z">
        <tags></tags>
      </file>
      <file name="get-chat.js" path="netlify/functions/get-chat.js" size="0" lastModified="2025-05-28T23:51:59.175Z">
        <tags></tags>
      </file>
      <file name="get-locations.js" path="netlify/functions/get-locations.js" size="0" lastModified="2025-05-29T00:12:36.034Z">
        <tags></tags>
      </file>
      <file name="get-market.js" path="netlify/functions/get-market.js" size="0" lastModified="2025-05-29T03:47:50.500Z">
        <tags></tags>
      </file>
      <file name="get-players-at-location.js" path="netlify/functions/get-players-at-location.js" size="0" lastModified="2025-05-28T23:55:02.361Z">
        <tags></tags>
      </file>
      <file name="metadata.js" path="netlify/functions/metadata.js" size="0" lastModified="2025-05-29T02:46:06.495Z">
        <tags></tags>
      </file>
      <file name="mine-action.js" path="netlify/functions/mine-action.js" size="0" lastModified="2025-05-29T07:11:55.499Z">
        <tags></tags>
      </file>
      <file name="render-character.js" path="netlify/functions/render-character.js" size="0" lastModified="2025-05-29T02:46:20.676Z">
        <tags></tags>
      </file>
      <file name="send-message.js" path="netlify/functions/send-message.js" size="0" lastModified="2025-05-29T00:06:10.082Z">
        <tags></tags>
      </file>
      <file name="travel-action.js" path="netlify/functions/travel-action.js" size="0" lastModified="2025-05-28T23:30:33.914Z">
        <tags></tags>
      </file>
      <file name="use-item.js" path="netlify/functions/use-item.js" size="0" lastModified="2025-05-29T04:02:05.691Z">
        <tags></tags>
      </file>
    </directory>
  </directory>
  <directory name="prisma" path="prisma">
    <file name="schema.prisma" path="prisma/schema.prisma" size="0" lastModified="2025-05-28T22:31:59.236Z">
      <tags></tags>
    </file>
    <file name="seed.ts" path="prisma/seed.ts" size="0" lastModified="2025-05-28T23:49:37.575Z">
      <tags></tags>
    </file>
  </directory>
  <directory name="scripts" path="scripts">
    <file name="add-new-regions.ts" path="scripts/add-new-regions.ts" size="0" lastModified="2025-05-29T08:48:57.681Z">
      <tags></tags>
    </file>
    <file name="add-proper-tools.ts" path="scripts/add-proper-tools.ts" size="0" lastModified="2025-05-29T06:21:08.021Z">
      <tags></tags>
    </file>
    <file name="add-themed-items.ts" path="scripts/add-themed-items.ts" size="0" lastModified="2025-05-29T05:47:45.577Z">
      <tags></tags>
    </file>
    <file name="debug-market-locations.ts" path="scripts/debug-market-locations.ts" size="0" lastModified="2025-05-29T06:00:54.267Z">
      <tags></tags>
    </file>
    <file name="fix-market-locations.ts" path="scripts/fix-market-locations.ts" size="0" lastModified="2025-05-29T06:07:56.390Z">
      <tags></tags>
    </file>
    <file name="seed-enhanced-markets.ts" path="scripts/seed-enhanced-markets.ts" size="0" lastModified="2025-05-29T06:25:23.751Z">
      <tags></tags>
    </file>
    <file name="seed-markets.ts" path="scripts/seed-markets.ts" size="0" lastModified="2025-05-29T06:22:57.295Z">
      <tags></tags>
    </file>
    <file name="seed-mining-resources.ts" path="scripts/seed-mining-resources.ts" size="0" lastModified="2025-05-29T04:58:00.336Z">
      <tags></tags>
    </file>
    <file name="setup-complete-game.ts" path="scripts/setup-complete-game.ts" size="0" lastModified="2025-05-29T06:32:31.722Z">
      <tags></tags>
    </file>
    <file name="setup-new-regions-content.ts" path="scripts/setup-new-regions-content.ts" size="0" lastModified="2025-05-29T10:04:14.004Z">
      <tags></tags>
    </file>
    <file name="ultimate-world-setup.ts" path="scripts/ultimate-world-setup.ts" size="0" lastModified="2025-05-29T10:08:28.693Z">
      <tags></tags>
    </file>
    <file name="update-mining-with-tools.ts" path="scripts/update-mining-with-tools.ts" size="0" lastModified="2025-05-29T06:21:32.931Z">
      <tags></tags>
    </file>
  </directory>
  <directory name="src" path="src">
    <directory name="components" path="src/components">
      <directory name="ui" path="src/components/ui">
        <file name="avatar.tsx" path="src/components/ui/avatar.tsx" size="0" lastModified="2025-05-29T08:13:25.444Z">
          <tags></tags>
        </file>
        <file name="badge.tsx" path="src/components/ui/badge.tsx" size="0" lastModified="2025-05-29T08:13:25.456Z">
          <tags></tags>
        </file>
        <file name="button.tsx" path="src/components/ui/button.tsx" size="0" lastModified="2025-05-28T21:47:16.145Z">
          <tags></tags>
        </file>
        <file name="dialog.tsx" path="src/components/ui/dialog.tsx" size="0" lastModified="2025-05-29T08:13:25.281Z">
          <tags></tags>
        </file>
        <file name="dropdown-menu.tsx" path="src/components/ui/dropdown-menu.tsx" size="0" lastModified="2025-05-29T00:35:27.082Z">
          <tags></tags>
        </file>
        <file name="scroll-area.tsx" path="src/components/ui/scroll-area.tsx" size="0" lastModified="2025-05-29T08:13:25.435Z">
          <tags></tags>
        </file>
        <file name="sonner.tsx" path="src/components/ui/sonner.tsx" size="0" lastModified="2025-05-29T04:28:51.400Z">
          <tags></tags>
        </file>
        <file name="tabs.tsx" path="src/components/ui/tabs.tsx" size="0" lastModified="2025-05-29T11:14:29.295Z">
          <tags></tags>
        </file>
        <file name="tooltip.tsx" path="src/components/ui/tooltip.tsx" size="0" lastModified="2025-05-29T11:09:24.963Z">
          <tags></tags>
        </file>
      </directory>
      <directory name="views" path="src/components/views">
        <file name="index.ts" path="src/components/views/index.ts" size="0" lastModified="2025-05-29T11:12:15.786Z">
          <tags></tags>
        </file>
        <file name="InventoryView.tsx" path="src/components/views/InventoryView.tsx" size="0" lastModified="2025-05-29T11:14:50.302Z">
          <tags></tags>
        </file>
        <file name="MarketView.tsx" path="src/components/views/MarketView.tsx" size="0" lastModified="2025-05-29T04:43:00.072Z">
          <tags></tags>
        </file>
        <file name="MiningView.tsx" path="src/components/views/MiningView.tsx" size="0" lastModified="2025-05-29T05:11:37.300Z">
          <tags></tags>
        </file>
        <file name="WorldMapView.tsx" path="src/components/views/WorldMapView.tsx" size="0" lastModified="2025-05-29T12:27:30.500Z">
          <tags></tags>
        </file>
      </directory>
      <file name="mode-toggle.tsx" path="src/components/mode-toggle.tsx" size="0" lastModified="2025-05-29T00:32:40.806Z">
        <tags></tags>
      </file>
      <file name="theme-provider.tsx" path="src/components/theme-provider.tsx" size="0" lastModified="2025-05-29T00:31:34.688Z">
        <tags></tags>
      </file>
      <file name="wallet-connect-button.tsx" path="src/components/wallet-connect-button.tsx" size="0" lastModified="2025-05-29T08:13:24.988Z">
        <tags></tags>
      </file>
      <file name="wallet-provider.tsx" path="src/components/wallet-provider.tsx" size="0" lastModified="2025-05-29T08:13:24.629Z">
        <tags></tags>
      </file>
      <file name="wallet-select-modal.tsx" path="src/components/wallet-select-modal.tsx" size="0" lastModified="2025-05-29T08:13:25.130Z">
        <tags></tags>
      </file>
    </directory>
    <directory name="lib" path="src/lib">
      <file name="layerResolver.ts" path="src/lib/layerResolver.ts" size="0" lastModified="2025-05-29T02:27:27.011Z">
        <tags></tags>
      </file>
      <file name="utils.ts" path="src/lib/utils.ts" size="0" lastModified="2025-05-28T21:46:49.754Z">
        <tags></tags>
      </file>
    </directory>
    <directory name="types" path="src/types">
      <file name="index.ts" path="src/types/index.ts" size="0" lastModified="2025-05-29T07:19:18.019Z">
        <tags></tags>
      </file>
    </directory>
    <file name="App.css" path="src/App.css" size="0" lastModified="2025-05-28T21:44:35.041Z">
      <tags></tags>
    </file>
    <file name="App.tsx" path="src/App.tsx" size="0" lastModified="2025-05-29T12:22:54.002Z">
      <tags></tags>
    </file>
    <file name="index.css" path="src/index.css" size="0" lastModified="2025-05-28T21:46:42.653Z">
      <tags></tags>
    </file>
    <file name="main.tsx" path="src/main.tsx" size="0" lastModified="2025-05-29T07:59:24.953Z">
      <tags></tags>
    </file>
    <file name="vite-env.d.ts" path="src/vite-env.d.ts" size="0" lastModified="2025-05-28T21:44:35.044Z">
      <tags></tags>
    </file>
  </directory>
  <file name=".env" path=".env" size="0" lastModified="2025-05-28T21:52:13.504Z">
    <tags></tags>
  </file>
  <file name=".gitignore" path=".gitignore" size="0" lastModified="2025-05-28T23:07:21.376Z">
    <tags></tags>
  </file>
  <file name="components.json" path="components.json" size="0" lastModified="2025-05-28T21:46:42.115Z">
    <tags></tags>
  </file>
  <file name="eslint.config.js" path="eslint.config.js" size="0" lastModified="2025-05-28T21:44:35.037Z">
    <tags></tags>
  </file>
  <file name="index.html" path="index.html" size="0" lastModified="2025-05-28T21:48:47.451Z">
    <tags></tags>
  </file>
  <file name="LITEPAPER.md" path="LITEPAPER.md" size="0" lastModified="2025-05-29T13:15:03.925Z">
    <tags></tags>
  </file>
  <file name="NFT.md" path="NFT.md" size="0" lastModified="2025-05-29T13:22:36.411Z">
    <tags></tags>
  </file>
  <file name="package.json" path="package.json" size="0" lastModified="2025-05-29T11:14:27.449Z">
    <tags></tags>
  </file>
  <file name="PITCHDECK.md" path="PITCHDECK.md" size="0" lastModified="2025-05-29T13:01:27.667Z">
    <tags></tags>
  </file>
  <file name="README.md" path="README.md" size="0" lastModified="2025-05-29T13:12:00.912Z">
    <tags></tags>
  </file>
  <file name="TODO.md" path="TODO.md" size="0" lastModified="2025-05-29T12:58:43.062Z">
    <tags></tags>
  </file>
  <file name="tsconfig.app.json" path="tsconfig.app.json" size="0" lastModified="2025-05-28T21:48:18.933Z">
    <tags></tags>
  </file>
  <file name="tsconfig.json" path="tsconfig.json" size="0" lastModified="2025-05-28T21:45:45.831Z">
    <tags></tags>
  </file>
  <file name="tsconfig.node.json" path="tsconfig.node.json" size="0" lastModified="2025-05-28T21:46:21.462Z">
    <tags></tags>
  </file>
  <file name="vite.config.ts" path="vite.config.ts" size="0" lastModified="2025-05-28T21:46:16.230Z">
    <tags></tags>
  </file>
  <file name="WHITEPAPER.md" path="WHITEPAPER.md" size="0" lastModified="2025-05-29T13:03:30.347Z">
    <tags></tags>
  </file>
</directoryTree>

  <asciiTree>
project/
‚îú‚îÄ‚îÄ netlify/
‚îÇ   ‚îî‚îÄ‚îÄ functions/
‚îÇ       ‚îú‚îÄ‚îÄ buy-item.js
‚îÇ       ‚îú‚îÄ‚îÄ equip-item.js
‚îÇ       ‚îú‚îÄ‚îÄ get-character.js
‚îÇ       ‚îú‚îÄ‚îÄ get-chat.js
‚îÇ       ‚îú‚îÄ‚îÄ get-locations.js
‚îÇ       ‚îú‚îÄ‚îÄ get-market.js
‚îÇ       ‚îú‚îÄ‚îÄ get-players-at-location.js
‚îÇ       ‚îú‚îÄ‚îÄ metadata.js
‚îÇ       ‚îú‚îÄ‚îÄ mine-action.js
‚îÇ       ‚îú‚îÄ‚îÄ render-character.js
‚îÇ       ‚îú‚îÄ‚îÄ send-message.js
‚îÇ       ‚îú‚îÄ‚îÄ travel-action.js
‚îÇ       ‚îî‚îÄ‚îÄ use-item.js
‚îú‚îÄ‚îÄ prisma/
‚îÇ   ‚îú‚îÄ‚îÄ schema.prisma
‚îÇ   ‚îî‚îÄ‚îÄ seed.ts
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ add-new-regions.ts
‚îÇ   ‚îú‚îÄ‚îÄ add-proper-tools.ts
‚îÇ   ‚îú‚îÄ‚îÄ add-themed-items.ts
‚îÇ   ‚îú‚îÄ‚îÄ debug-market-locations.ts
‚îÇ   ‚îú‚îÄ‚îÄ fix-market-locations.ts
‚îÇ   ‚îú‚îÄ‚îÄ seed-enhanced-markets.ts
‚îÇ   ‚îú‚îÄ‚îÄ seed-markets.ts
‚îÇ   ‚îú‚îÄ‚îÄ seed-mining-resources.ts
‚îÇ   ‚îú‚îÄ‚îÄ setup-complete-game.ts
‚îÇ   ‚îú‚îÄ‚îÄ setup-new-regions-content.ts
‚îÇ   ‚îú‚îÄ‚îÄ ultimate-world-setup.ts
‚îÇ   ‚îî‚îÄ‚îÄ update-mining-with-tools.ts
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ avatar.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ badge.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ button.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dialog.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dropdown-menu.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scroll-area.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sonner.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tabs.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tooltip.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ views/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ InventoryView.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MarketView.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MiningView.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ WorldMapView.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mode-toggle.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ theme-provider.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ wallet-connect-button.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ wallet-provider.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ wallet-select-modal.tsx
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layerResolver.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.ts
‚îÇ   ‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ App.css
‚îÇ   ‚îú‚îÄ‚îÄ App.tsx
‚îÇ   ‚îú‚îÄ‚îÄ index.css
‚îÇ   ‚îú‚îÄ‚îÄ main.tsx
‚îÇ   ‚îî‚îÄ‚îÄ vite-env.d.ts
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ components.json
‚îú‚îÄ‚îÄ eslint.config.js
‚îú‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ LITEPAPER.md
‚îú‚îÄ‚îÄ NFT.md
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ PITCHDECK.md
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ TODO.md
‚îú‚îÄ‚îÄ tsconfig.app.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ tsconfig.node.json
‚îú‚îÄ‚îÄ vite.config.ts
‚îî‚îÄ‚îÄ WHITEPAPER.md

70 files, 10 directories
  </asciiTree>

  <documents>
    
    <document>
      <source>prisma/seed.ts</source>
      <tags></tags>
      <metadata>
        <size>21139</size>
        <lastModified>2025-05-28T23:49:37.575Z</lastModified>
        <extension>ts</extension>
        <directory>prisma</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

async function main() {
  console.log(&#39;üå± Starting expanded database seed...&#39;)

  // Clean existing data (optional - remove in production)
  await prisma.chatMessage.deleteMany()
  await prisma.marketListing.deleteMany()
  await prisma.locationResource.deleteMany()
  await prisma.characterInventory.deleteMany()
  await prisma.characterImage.deleteMany()
  await prisma.transaction.deleteMany()
  await prisma.character.deleteMany()
  await prisma.location.deleteMany()
  await prisma.item.deleteMany()

  console.log(&#39;üßπ Cleaned existing data&#39;)

  // Create Items first (same as before)
  const items = await Promise.all([
    // Mining Materials
    prisma.item.create({
      data: {
        name: &#39;Dirty Coal&#39;,
        description: &#39;Basic fuel found in shallow mines&#39;,
        category: &#39;MATERIAL&#39;,
        rarity: &#39;COMMON&#39;,
        imageUrl: &#39;/items/dirty-coal.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Iron Scraps&#39;,
        description: &#39;Rusty metal pieces, still useful&#39;,
        category: &#39;MATERIAL&#39;,
        rarity: &#39;COMMON&#39;,
        imageUrl: &#39;/items/iron-scraps.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Ancient Coin&#39;,
        description: &#39;Currency from a forgotten civilization&#39;,
        category: &#39;MATERIAL&#39;,
        rarity: &#39;RARE&#39;,
        imageUrl: &#39;/items/ancient-coin.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Crystal Shard&#39;,
        description: &#39;Glowing fragment with mysterious properties&#39;,
        category: &#39;MATERIAL&#39;,
        rarity: &#39;EPIC&#39;,
        imageUrl: &#39;/items/crystal-shard.png&#39;,
      },
    }),

    // Equipment
    prisma.item.create({
      data: {
        name: &#39;Miners Hat&#39;,
        description: &#39;Worn leather hat with a dim headlamp&#39;,
        category: &#39;HAT&#39;,
        layerType: &#39;HAT&#39;,
        rarity: &#39;COMMON&#39;,
        durability: 100,
        energyEffect: 5,
        imageUrl: &#39;/items/miners-hat.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Work Gloves&#39;,
        description: &#39;Tough gloves for manual labor&#39;,
        category: &#39;CLOTHING&#39;,
        layerType: &#39;ACCESSORY&#39;,
        rarity: &#39;COMMON&#39;,
        durability: 80,
        imageUrl: &#39;/items/work-gloves.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Lucky Charm&#39;,
        description: &quot;A rabbit&#39;s foot that might bring fortune&quot;,
        category: &#39;ACCESSORY&#39;,
        layerType: &#39;ACCESSORY&#39;,
        rarity: &#39;UNCOMMON&#39;,
        imageUrl: &#39;/items/lucky-charm.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Cyber Jacket&#39;,
        description: &#39;High-tech jacket with built-in displays&#39;,
        category: &#39;CLOTHING&#39;,
        layerType: &#39;CLOTHING&#39;,
        rarity: &#39;RARE&#39;,
        energyEffect: 15,
        imageUrl: &#39;/items/cyber-jacket.png&#39;,
      },
    }),

    // Consumables
    prisma.item.create({
      data: {
        name: &#39;Energy Drink&#39;,
        description: &#39;Restores energy and keeps you alert&#39;,
        category: &#39;CONSUMABLE&#39;,
        rarity: &#39;COMMON&#39;,
        energyEffect: 25,
        imageUrl: &#39;/items/energy-drink.png&#39;,
      },
    }),
    prisma.item.create({
      data: {
        name: &#39;Health Potion&#39;,
        description: &#39;Mysterious red liquid that heals wounds&#39;,
        category: &#39;CONSUMABLE&#39;,
        rarity: &#39;UNCOMMON&#39;,
        healthEffect: 30,
        imageUrl: &#39;/items/health-potion.png&#39;,
      },
    }),
  ])

  console.log(`‚ú® Created ${items.length} items`)

  // Create top-level locations (same as before)
  const miningPlains = await prisma.location.create({
    data: {
      name: &#39;Mining Plains&#39;,
      description: &#39;Rich in basic materials and perfect for newcomers&#39;,
      locationType: &#39;REGION&#39;,
      biome: &#39;plains&#39;,
      difficulty: 1,
      playerCount: 8, // Will be updated by actual characters
      lastActive: new Date(Date.now() - 2 * 60 * 1000),
      hasMarket: true,
      hasMining: true,
      hasChat: true,
      chatScope: &#39;REGIONAL&#39;,
      welcomeMessage: &#39;The wind carries the sound of pickaxes striking stone.&#39;,
      lore: &#39;Once a vast battlefield, these plains now serve as the primary mining grounds for new arrivals to Earth.&#39;,
      mapX: 100,
      mapY: 200,
    },
  })

  const desertOutpost = await prisma.location.create({
    data: {
      name: &#39;Desert Outpost&#39;,
      description: &#39;Harsh but rewarding terrain for experienced miners&#39;,
      locationType: &#39;REGION&#39;,
      biome: &#39;desert&#39;,
      difficulty: 3,
      playerCount: 3,
      lastActive: new Date(Date.now() - 12 * 60 * 1000),
      hasMarket: true,
      hasMining: true,
      hasChat: true,
      chatScope: &#39;REGIONAL&#39;,
      welcomeMessage: &#39;The scorching sun beats down mercilessly.&#39;,
      lore: &#39;A remote trading post built around an ancient oasis.&#39;,
      mapX: 400,
      mapY: 100,
    },
  })

  const cyberCity = await prisma.location.create({
    data: {
      name: &#39;Cyber City&#39;,
      description: &#39;The technological heart of wojak civilization&#39;,
      locationType: &#39;CITY&#39;,
      biome: &#39;urban&#39;,
      difficulty: 2,
      playerCount: 12,
      lastActive: new Date(Date.now() - 30 * 1000),
      hasMarket: true,
      hasMining: false,
      hasChat: true,
      chatScope: &#39;LOCAL&#39;,
      welcomeMessage: &#39;Neon lights flicker in the perpetual twilight.&#39;,
      lore: &#39;The beating heart of wojak civilization.&#39;,
      mapX: 300,
      mapY: 300,
    },
  })

  // Create sub-locations
  const rustyPickaxeInn = await prisma.location.create({
    data: {
      name: &#39;Rusty Pickaxe Inn&#39;,
      description: &#39;A cozy tavern where miners share stories and ale&#39;,
      locationType: &#39;BUILDING&#39;,
      parentLocationId: miningPlains.id,
      difficulty: 1,
      playerCount: 4,
      lastActive: new Date(Date.now() - 5 * 60 * 1000),
      hasMarket: true,
      hasMining: false,
      hasChat: true,
      chatScope: &#39;LOCAL&#39;,
      welcomeMessage: &#39;The smell of ale and roasted meat fills the air.&#39;,
    },
  })

  const crystalCaves = await prisma.location.create({
    data: {
      name: &#39;Crystal Caves&#39;,
      description: &#39;Deep underground shafts where rare crystals grow&#39;,
      locationType: &#39;BUILDING&#39;,
      parentLocationId: miningPlains.id,
      difficulty: 2,
      playerCount: 4,
      lastActive: new Date(Date.now() - 1 * 60 * 1000),
      hasMarket: false,
      hasMining: true,
      hasChat: true,
      chatScope: &#39;LOCAL&#39;,
      welcomeMessage: &#39;Crystalline formations sparkle in your torchlight.&#39;,
    },
  })

  const centralExchange = await prisma.location.create({
    data: {
      name: &#39;Central Exchange&#39;,
      description: &#39;The main financial district and trading hub&#39;,
      locationType: &#39;BUILDING&#39;,
      parentLocationId: cyberCity.id,
      difficulty: 2,
      playerCount: 8,
      lastActive: new Date(Date.now() - 2 * 60 * 1000),
      hasMarket: true,
      hasMining: false,
      hasChat: true,
      chatScope: &#39;LOCAL&#39;,
      welcomeMessage:
        &#39;Holographic displays show market prices from across the world.&#39;,
    },
  })

  const glitchClub = await prisma.location.create({
    data: {
      name: &#39;The Glitch Club&#39;,
      description: &#39;Underground social hub for hackers and rebels&#39;,
      locationType: &#39;BUILDING&#39;,
      parentLocationId: cyberCity.id,
      difficulty: 2,
      playerCount: 4,
      lastActive: new Date(Date.now() - 15 * 60 * 1000),
      hasMarket: false,
      hasMining: false,
      hasChat: true,
      chatScope: &#39;LOCAL&#39;,
      welcomeMessage: &#39;Bass-heavy music thumps through the smoky atmosphere.&#39;,
    },
  })

  console.log(&#39;üèòÔ∏è Created locations&#39;)

  // üÜï CREATE DIVERSE CHARACTERS (Our Test Players)
  const characters = await Promise.all([
    // Our main test character
    prisma.character.create({
      data: {
        nftAddress: &#39;DemoNFT123456789&#39;,
        tokenId: &#39;1337&#39;,
        walletAddress: &#39;DemoWallet123456789&#39;,
        name: &#39;Wojak #1337&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: miningPlains.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak.png&#39;,
        energy: 85,
        health: 100,
      },
    }),

    // Mining Plains characters
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT420420420&#39;,
        tokenId: &#39;420&#39;,
        walletAddress: &#39;Wallet420&#39;,
        name: &#39;Wojak #420&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: miningPlains.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-420.png&#39;,
        energy: 95,
        health: 100,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT69696969&#39;,
        tokenId: &#39;69&#39;,
        walletAddress: &#39;Wallet69&#39;,
        name: &#39;Wojak #69&#39;,
        gender: &#39;FEMALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: rustyPickaxeInn.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-69.png&#39;,
        energy: 70,
        health: 100,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT888888&#39;,
        tokenId: &#39;888&#39;,
        walletAddress: &#39;Wallet888&#39;,
        name: &#39;Wojak #888&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: crystalCaves.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-888.png&#39;,
        energy: 45,
        health: 90,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT2077777&#39;,
        tokenId: &#39;2077&#39;,
        walletAddress: &#39;Wallet2077&#39;,
        name: &#39;Wojak #2077&#39;,
        gender: &#39;FEMALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: crystalCaves.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-2077.png&#39;,
        energy: 60,
        health: 85,
      },
    }),

    // Cyber City characters
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT1001001&#39;,
        tokenId: &#39;100&#39;,
        walletAddress: &#39;Wallet100&#39;,
        name: &#39;Wojak #100&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: centralExchange.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-100.png&#39;,
        energy: 80,
        health: 100,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT7777777&#39;,
        tokenId: &#39;777&#39;,
        walletAddress: &#39;Wallet777&#39;,
        name: &#39;Wojak #777&#39;,
        gender: &#39;FEMALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: centralExchange.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-777.png&#39;,
        energy: 90,
        health: 95,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT3333333&#39;,
        tokenId: &#39;333&#39;,
        walletAddress: &#39;Wallet333&#39;,
        name: &#39;Wojak #333&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: glitchClub.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-333.png&#39;,
        energy: 55,
        health: 80,
      },
    }),

    // Desert characters
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT5555555&#39;,
        tokenId: &#39;555&#39;,
        walletAddress: &#39;Wallet555&#39;,
        name: &#39;Wojak #555&#39;,
        gender: &#39;FEMALE&#39;,
        characterType: &#39;HUMAN&#39;,
        currentLocationId: desertOutpost.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-555.png&#39;,
        energy: 40,
        health: 75,
      },
    }),
    prisma.character.create({
      data: {
        nftAddress: &#39;NFT9999999&#39;,
        tokenId: &#39;999&#39;,
        walletAddress: &#39;Wallet999&#39;,
        name: &#39;Wojak #999&#39;,
        gender: &#39;MALE&#39;,
        characterType: &#39;CREATURE&#39;,
        currentLocationId: desertOutpost.id,
        currentVersion: 1,
        currentImageUrl: &#39;/wojak-999.png&#39;,
        energy: 85,
        health: 100,
      },
    }),
  ])

  console.log(`üë• Created ${characters.length} characters`)

  // üÜï CREATE REALISTIC CHAT MESSAGES
  const chatMessages = await Promise.all([
    // Mining Plains chat (regional - shows in main area and sub-locations)
    prisma.chatMessage.create({
      data: {
        locationId: miningPlains.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #420&#39;)!.id,
        message: &#39;Anyone know where the best iron deposits are?&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 3 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: miningPlains.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #1337&#39;)!.id,
        message:
          &#39;Try the eastern slopes, found some good scraps there yesterday&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 2 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: miningPlains.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #420&#39;)!.id,
        message: &#39;Thanks! Heading there now&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 90 * 1000),
      },
    }),

    // Rusty Pickaxe Inn chat (local - cozy tavern conversation)
    prisma.chatMessage.create({
      data: {
        locationId: rustyPickaxeInn.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #69&#39;)!.id,
        message: &#39;This ale tastes like it was brewed in a boot üòÇ&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 8 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: rustyPickaxeInn.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #420&#39;)!.id,
        message: &#39;Hey, at least it gets you drunk!&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 7 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: rustyPickaxeInn.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #69&#39;)!.id,
        message: &#39;True! Anyone up for some mining stories?&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 6 * 60 * 1000),
      },
    }),

    // Crystal Caves chat (focused on mining)
    prisma.chatMessage.create({
      data: {
        locationId: crystalCaves.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #888&#39;)!.id,
        message: &#39;Whoa! Just found a crystal shard in the deep tunnel!&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 5 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: crystalCaves.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #2077&#39;)!.id,
        message: &#39;Nice! What rarity?&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 4 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: crystalCaves.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #888&#39;)!.id,
        message: &quot;Epic! First one I&#39;ve ever seen&quot;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 3 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: crystalCaves.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #2077&#39;)!.id,
        message: &quot;Damn, I&#39;ve been mining here for weeks with no luck&quot;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 2 * 60 * 1000),
      },
    }),

    // Central Exchange chat (trading focused)
    prisma.chatMessage.create({
      data: {
        locationId: centralExchange.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #100&#39;)!.id,
        message: &#39;WTS: Cyber Jacket, rare quality. Looking for ancient coins&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 15 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: centralExchange.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #777&#39;)!.id,
        message: &#39;How many coins?&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 14 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: centralExchange.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #100&#39;)!.id,
        message: &#39;15 coins, firm price&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 13 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: centralExchange.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #777&#39;)!.id,
        message: &#39;Deal! Meet me at the trade terminal&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 12 * 60 * 1000),
      },
    }),

    // Glitch Club chat (underground vibe)
    prisma.chatMessage.create({
      data: {
        locationId: glitchClub.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #333&#39;)!.id,
        message: &#39;*nods to the beat* This track is fire üî•&#39;,
        messageType: &#39;EMOTE&#39;,
        createdAt: new Date(Date.now() - 20 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: glitchClub.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #777&#39;)!.id,
        message: &#39;Anyone know who the DJ is tonight?&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 18 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: glitchClub.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #333&#39;)!.id,
        message: &#39;DJ CyberWojak, they drop the sickest beats in the city&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 16 * 60 * 1000),
      },
    }),

    // Desert Outpost chat (survival focused)
    prisma.chatMessage.create({
      data: {
        locationId: desertOutpost.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #555&#39;)!.id,
        message: &#39;Water supplies running low... need to find the oasis&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 25 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: desertOutpost.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #999&#39;)!.id,
        message: &#39;Follow the ancient stone markers, they lead to water&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 23 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: desertOutpost.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #555&#39;)!.id,
        message: &#39;Thanks creature-wojak, you know this desert well&#39;,
        messageType: &#39;CHAT&#39;,
        createdAt: new Date(Date.now() - 22 * 60 * 1000),
      },
    }),

    // System messages
    prisma.chatMessage.create({
      data: {
        locationId: miningPlains.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #420&#39;)!.id,
        message: &#39;Wojak #420 found: Iron Scraps (COMMON)&#39;,
        messageType: &#39;SYSTEM&#39;,
        isSystem: true,
        createdAt: new Date(Date.now() - 10 * 60 * 1000),
      },
    }),
    prisma.chatMessage.create({
      data: {
        locationId: crystalCaves.id,
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #888&#39;)!.id,
        message: &#39;Wojak #888 found: Crystal Shard (EPIC)&#39;,
        messageType: &#39;SYSTEM&#39;,
        isSystem: true,
        createdAt: new Date(Date.now() - 4 * 60 * 1000),
      },
    }),
  ])

  console.log(`üí¨ Created ${chatMessages.length} chat messages`)

  // Create some sample inventory items
  await Promise.all([
    prisma.characterInventory.create({
      data: {
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #1337&#39;)!.id,
        itemId: items.find((i) =&gt; i.name === &#39;Dirty Coal&#39;)!.id,
        quantity: 3,
      },
    }),
    prisma.characterInventory.create({
      data: {
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #1337&#39;)!.id,
        itemId: items.find((i) =&gt; i.name === &#39;Miners Hat&#39;)!.id,
        quantity: 1,
        isEquipped: true,
      },
    }),
    prisma.characterInventory.create({
      data: {
        characterId: characters.find((c) =&gt; c.name === &#39;Wojak #888&#39;)!.id,
        itemId: items.find((i) =&gt; i.name === &#39;Crystal Shard&#39;)!.id,
        quantity: 1,
      },
    }),
  ])

  // Create some location resources
  await Promise.all([
    prisma.locationResource.create({
      data: {
        locationId: miningPlains.id,
        itemId: items.find((i) =&gt; i.name === &#39;Dirty Coal&#39;)!.id,
        spawnRate: 0.6,
        maxPerDay: 20,
        difficulty: 1,
      },
    }),
    prisma.locationResource.create({
      data: {
        locationId: crystalCaves.id,
        itemId: items.find((i) =&gt; i.name === &#39;Crystal Shard&#39;)!.id,
        spawnRate: 0.1,
        maxPerDay: 3,
        difficulty: 3,
      },
    }),
  ])

  console.log(&#39;üéâ Expanded database seed completed successfully!&#39;)
}

main()
  .catch((e) =&gt; {
    console.error(&#39;‚ùå Enhanced seed failed:&#39;, e)
    process.exit(1)
  })
  .finally(async () =&gt; {
    await prisma.$disconnect()
  })
</content>
    </document>

    <document>
      <source>prisma/schema.prisma</source>
      <tags></tags>
      <metadata>
        <size>7380</size>
        <lastModified>2025-05-28T22:31:59.236Z</lastModified>
        <extension>prisma</extension>
        <directory>prisma</directory>
      </metadata>
      <content>// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = &quot;prisma-client-js&quot;
}

datasource db {
  provider = &quot;postgresql&quot;
  url      = env(&quot;DATABASE_URL&quot;)
}

model Character {
  id            String @id @default(cuid())
  nftAddress    String @unique // Solana NFT address
  tokenId       String @unique // Token ID or mint address
  walletAddress String // Owner&#39;s wallet

  // Character basics
  name          String
  gender        Gender
  characterType CharacterType @default(HUMAN)

  // Current state
  currentLocationId String
  currentLocation   Location @relation(fields: [currentLocationId], references: [id])

  // NFT versioning
  currentVersion  Int     @default(1)
  currentImageUrl String?

  // Game stats
  energy Int @default(100)
  health Int @default(100)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  inventory      CharacterInventory[]
  imageHistory   CharacterImage[]
  transactions   Transaction[]
  marketListings MarketListing[]
  chatMessages   ChatMessage[]

  @@map(&quot;characters&quot;)
}

model Item {
  id          String       @id @default(cuid())
  name        String       @unique
  description String
  category    ItemCategory

  // Visual properties
  layerType LayerType? // which layer this item affects
  imageUrl  String? // item&#39;s image for layering

  // Game properties
  rarity     Rarity @default(COMMON)
  durability Int? // for equipment that degrades

  // Stats effects (optional for MVP)
  energyEffect Int?
  healthEffect Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  characterInventory CharacterInventory[]
  locationResources  LocationResource[]
  marketListings     MarketListing[]

  @@map(&quot;items&quot;)
}

model ChatMessage {
  id          String @id @default(cuid())
  locationId  String
  characterId String

  message     String
  messageType ChatMessageType @default(CHAT)

  // For system messages (player joined, found item, etc.)
  isSystem Boolean @default(false)

  location  Location  @relation(fields: [locationId], references: [id], onDelete: Cascade)
  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@map(&quot;chat_messages&quot;)
}

model Location {
  id          String  @id @default(cuid())
  name        String
  description String
  imageUrl    String?

  // Hierarchy support
  parentLocationId String?
  parentLocation   Location?  @relation(&quot;LocationHierarchy&quot;, fields: [parentLocationId], references: [id])
  subLocations     Location[] @relation(&quot;LocationHierarchy&quot;)

  // Location type
  locationType LocationType @default(REGION) // REGION, CITY, BUILDING, ROOM

  // Location properties
  biome      String? // only for top-level locations
  difficulty Int     @default(1)

  // Map positioning
  mapX Int? // X coordinate on map
  mapY Int? // Y coordinate on map

  // Location stats
  playerCount Int       @default(0) // cached count for performance
  lastActive  DateTime? // when someone last performed an action here

  // Location features
  hasMarket Boolean @default(true)
  hasMining Boolean @default(true)
  hasTravel Boolean @default(true)
  hasChat   Boolean @default(true) // enable chat in this location

  // Chat settings
  chatScope ChatScope @default(LOCAL) // LOCAL (this location only) or REGIONAL (includes parent)

  // Flavor text
  welcomeMessage String? // custom message when entering
  lore           String? // extended description/backstory

  // Entry requirements (optional)
  minLevel  Int? // minimum level to enter
  entryCost Int? // cost in coins to enter
  isPrivate Boolean @default(false) // requires invitation/ownership

  // Available resources for mining
  resources LocationResource[]

  // Characters currently here
  characters Character[]

  // Market items available here
  marketListings MarketListing[]

  // Chat messages in this location
  chatMessages ChatMessage[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([name, parentLocationId]) // location names must be unique within parent
  @@map(&quot;locations&quot;)
}

model CharacterInventory {
  id          String  @id @default(cuid())
  characterId String
  itemId      String
  quantity    Int     @default(1)
  isEquipped  Boolean @default(false)

  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)
  item      Item      @relation(fields: [itemId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([characterId, itemId])
  @@map(&quot;character_inventory&quot;)
}

model LocationResource {
  id         String @id @default(cuid())
  locationId String
  itemId     String

  // Mining properties
  spawnRate  Float @default(0.1) // chance per mining attempt
  maxPerDay  Int? // daily limit per character
  difficulty Int   @default(1)

  location Location @relation(fields: [locationId], references: [id], onDelete: Cascade)
  item     Item     @relation(fields: [itemId], references: [id])

  @@unique([locationId, itemId])
  @@map(&quot;location_resources&quot;)
}

model CharacterImage {
  id          String  @id @default(cuid())
  characterId String
  version     Int
  imageUrl    String
  description String? // what changed in this version

  character Character @relation(fields: [characterId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([characterId, version])
  @@map(&quot;character_images&quot;)
}

model MarketListing {
  id         String  @id @default(cuid())
  sellerId   String? // null for system items
  locationId String
  itemId     String

  price        Int // in game currency or SOL lamports
  quantity     Int     @default(1)
  isSystemItem Boolean @default(false) // true for NPC shop items

  seller   Character? @relation(fields: [sellerId], references: [id])
  location Location   @relation(fields: [locationId], references: [id])
  item     Item       @relation(fields: [itemId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map(&quot;market_listings&quot;)
}

model Transaction {
  id          String          @id @default(cuid())
  characterId String
  type        TransactionType
  itemId      String?
  quantity    Int?
  description String

  character Character @relation(fields: [characterId], references: [id])

  createdAt DateTime @default(now())

  @@map(&quot;transactions&quot;)
}

// Enums
enum Gender {
  MALE
  FEMALE
}

enum CharacterType {
  HUMAN
  CREATURE
}

enum LocationType {
  REGION // Continents, large areas
  CITY // Towns, cities
  BUILDING // Inns, shops, temples
  ROOM // Specific rooms within buildings
}

enum ChatScope {
  LOCAL // Only this specific location
  REGIONAL // This location + parent location
  GLOBAL // Entire game (for special locations)
}

enum ChatMessageType {
  CHAT // Regular player chat
  EMOTE // Player actions (/me waves)
  SYSTEM // System announcements
  WHISPER // Private messages
}

enum ItemCategory {
  CLOTHING
  HAT
  ACCESSORY
  TOOL
  CONSUMABLE
  MATERIAL
}

enum LayerType {
  BACKGROUND
  BASE
  CLOTHING
  HAT
  FACE_COVERING
  ACCESSORY
}

enum Rarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
}

enum TransactionType {
  MINT
  MINE
  BUY
  SELL
  TRAVEL
  EQUIP
  UNEQUIP
}
</content>
    </document>

    <document>
      <source>netlify/functions/metadata.js</source>
      <tags></tags>
      <metadata>
        <size>6861</size>
        <lastModified>2025-05-29T02:46:06.495Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>// netlify/functions/metadata.js
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// Configuration
const ASSET_BASE_URL = process.env.NODE_ENV === &#39;production&#39;
  ? &#39;https://earth.ndao.computer&#39;
  : process.env.URL || &#39;http://localhost:8888&#39;

/**
 * Generate trait attributes from character data
 */
function generateAttributes(character) {
  const attributes = []

  // Basic character traits
  attributes.push({
    trait_type: &quot;Gender&quot;,
    value: character.gender
  })

  attributes.push({
    trait_type: &quot;Character Type&quot;,
    value: character.characterType
  })

  // Location-based traits
  if (character.currentLocation) {
    attributes.push({
      trait_type: &quot;Current Location&quot;,
      value: character.currentLocation.name
    })

    if (character.currentLocation.biome) {
      attributes.push({
        trait_type: &quot;Biome&quot;,
        value: character.currentLocation.biome.charAt(0).toUpperCase() +
          character.currentLocation.biome.slice(1)
      })
    }
  }

  // Equipment traits
  if (character.inventory) {
    const equippedItems = character.inventory.filter(inv =&gt; inv.isEquipped)

    equippedItems.forEach(inv =&gt; {
      const item = inv.item
      attributes.push({
        trait_type: item.category.charAt(0).toUpperCase() +
          item.category.slice(1).toLowerCase(),
        value: item.name
      })
    })

    // Equipment count
    attributes.push({
      trait_type: &quot;Equipped Items&quot;,
      value: equippedItems.length,
      display_type: &quot;number&quot;
    })
  }

  // Stats
  attributes.push({
    trait_type: &quot;Energy&quot;,
    value: character.energy,
    max_value: 100,
    display_type: &quot;boost_percentage&quot;
  })

  attributes.push({
    trait_type: &quot;Health&quot;,
    value: character.health,
    max_value: 100,
    display_type: &quot;boost_percentage&quot;
  })

  // Game progression (could be calculated)
  const daysSinceCreation = Math.floor(
    (Date.now() - new Date(character.createdAt).getTime()) / (1000 * 60 * 60 * 24)
  )

  attributes.push({
    trait_type: &quot;Days Active&quot;,
    value: daysSinceCreation,
    display_type: &quot;number&quot;
  })

  return attributes
}

/**
 * Generate visible layers data
 */
function generateLayerData(character) {
  const layers = []

  // Background
  const backgroundName = character.currentLocation?.biome || &#39;mining-plains&#39;
  layers.push(`${ASSET_BASE_URL}/layers/backgrounds/${backgroundName}.png`)

  // Base
  const baseName = character.gender?.toLowerCase() || &#39;male&#39;
  layers.push(`${ASSET_BASE_URL}/layers/bases/${baseName}.png`)

  // Equipment layers
  if (character.inventory) {
    character.inventory
      .filter(inv =&gt; inv.isEquipped)
      .forEach(inv =&gt; {
        const item = inv.item
        let layerPath

        // Map items to layer paths
        switch (item.name) {
          case &#39;Miners Hat&#39;:
            layerPath = &#39;accessories/miners-hat.png&#39;
            break
          case &#39;Cyber Jacket&#39;:
            layerPath = &#39;clothing/cyber-jacket.png&#39;
            break
          case &#39;Work Gloves&#39;:
            layerPath = &#39;accessories/work-gloves.png&#39;
            break
          case &#39;Lucky Charm&#39;:
            layerPath = &#39;accessories/lucky-charm.png&#39;
            break
          // Add more mappings as needed
        }

        if (layerPath) {
          layers.push(`${ASSET_BASE_URL}/layers/${layerPath}`)
        }
      })
  }

  return layers
}

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;,
    &#39;Content-Type&#39;: &#39;application/json&#39;,
    &#39;Cache-Control&#39;: &#39;public, max-age=1800&#39; // Cache for 30 minutes
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    // Extract token ID from path
    const pathParts = event.path.split(&#39;/&#39;)
    const tokenId = pathParts[pathParts.length - 1]

    if (!tokenId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Token ID required&#39; })
      }
    }

    // Get character data
    let character

    if (tokenId === &#39;demo&#39; || tokenId === &#39;1337&#39;) {
      // Demo character
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; },
        include: {
          currentLocation: true,
          inventory: {
            where: { isEquipped: true },
            include: { item: true }
          }
        }
      })
    } else {
      // Try to find by tokenId first, then by ID
      character = await prisma.character.findFirst({
        where: {
          OR: [
            { tokenId: tokenId },
            { id: tokenId }
          ]
        },
        include: {
          currentLocation: true,
          inventory: {
            where: { isEquipped: true },
            include: { item: true }
          }
        }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Generate metadata
    const metadata = {
      name: character.name,
      description: `${character.name} is a ${character.characterType.toLowerCase()} explorer currently in ${character.currentLocation?.name || &#39;Unknown Location&#39;}. Energy: ${character.energy}/100, Health: ${character.health}/100.`,
      image: `${ASSET_BASE_URL}/.netlify/functions/render-character/${character.tokenId || character.id}.png`,
      external_url: `${ASSET_BASE_URL}/character/${character.tokenId || character.id}`,

      // Standard NFT metadata
      attributes: generateAttributes(character),

      // Wojak Earth specific data
      wojak_earth: {
        character_id: character.id,
        token_id: character.tokenId,
        nft_address: character.nftAddress,
        current_location: {
          id: character.currentLocation?.id,
          name: character.currentLocation?.name,
          type: character.currentLocation?.locationType,
          biome: character.currentLocation?.biome
        },
        stats: {
          energy: character.energy,
          health: character.health,
          level: Math.floor((Date.now() - new Date(character.createdAt).getTime()) / (1000 * 60 * 60 * 24 * 7)) + 1 // Rough level calculation
        },
        assets: {
          layers: generateLayerData(character),
          last_updated: new Date().toISOString()
        }
      }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(metadata, null, 2)
    }

  } catch (error) {
    console.error(&#39;Error generating metadata:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Metadata generation failed&#39;,
        message: error.message
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/buy-item.js</source>
      <tags></tags>
      <metadata>
        <size>6043</size>
        <lastModified>2025-05-29T03:25:43.591Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const { characterId = &#39;hardcoded-demo&#39;, marketListingId, quantity = 1 } = JSON.parse(event.body || &#39;{}&#39;)

    if (!marketListingId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Market listing ID is required&#39; })
      }
    }

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Get market listing with item details
    const marketListing = await prisma.marketListing.findUnique({
      where: { id: marketListingId },
      include: {
        item: true,
        seller: true,
        location: true
      }
    })

    if (!marketListing) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Market listing not found&#39; })
      }
    }

    // Check if enough quantity available
    if (quantity &gt; marketListing.quantity) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Insufficient quantity&#39;,
          message: `Only ${marketListing.quantity} available, you requested ${quantity}`
        })
      }
    }

    // Calculate total cost
    const totalCost = marketListing.price * quantity

    // For MVP: Skip currency check (assume player has enough)
    // TODO: Implement currency system
    // if (character.coins &lt; totalCost) {
    //   return {
    //     statusCode: 400,
    //     headers,
    //     body: JSON.stringify({
    //       error: &#39;Insufficient funds&#39;,
    //       message: `Item costs ${totalCost} coins, you have ${character.coins}`
    //     })
    //   }
    // }

    // Perform transaction
    const result = await prisma.$transaction(async (tx) =&gt; {
      // Add item to character inventory
      const existingInventory = await tx.characterInventory.findUnique({
        where: {
          characterId_itemId: {
            characterId: character.id,
            itemId: marketListing.itemId
          }
        }
      })

      let inventoryItem
      if (existingInventory) {
        // Update existing inventory
        inventoryItem = await tx.characterInventory.update({
          where: { id: existingInventory.id },
          data: { quantity: existingInventory.quantity + quantity },
          include: { item: true }
        })
      } else {
        // Create new inventory entry
        inventoryItem = await tx.characterInventory.create({
          data: {
            characterId: character.id,
            itemId: marketListing.itemId,
            quantity: quantity
          },
          include: { item: true }
        })
      }

      // Update or remove market listing
      if (marketListing.quantity === quantity &amp;&amp; !marketListing.isSystemItem) {
        // Only remove player listings when sold out
        await tx.marketListing.delete({
          where: { id: marketListingId }
        })
      } else {
        // Reduce quantity (system items can go to 0 but stay in DB)
        await tx.marketListing.update({
          where: { id: marketListingId },
          data: { quantity: marketListing.quantity - quantity }
        })
      }

      // TODO: Handle currency transfer
      // if (!marketListing.isSystemItem &amp;&amp; marketListing.seller) {
      //   // Transfer coins to seller
      //   await tx.character.update({
      //     where: { id: marketListing.sellerId },
      //     data: { coins: { increment: totalCost } }
      //   })
      // }
      // 
      // // Deduct coins from buyer
      // await tx.character.update({
      //   where: { id: character.id },
      //   data: { coins: { decrement: totalCost } }
      // })

      // Log the transaction
      const transaction = await tx.transaction.create({
        data: {
          characterId: character.id,
          type: &#39;BUY&#39;,
          itemId: marketListing.itemId,
          quantity: quantity,
          description: `Bought ${quantity}x ${marketListing.item.name} for ${totalCost} coins from ${marketListing.location.name} market`
        }
      })

      return {
        inventoryItem,
        transaction,
        totalCost,
        remainingQuantity: marketListing.quantity - quantity
      }
    })

    // Prepare response
    const responseData = {
      success: true,
      message: `Successfully purchased ${quantity}x ${marketListing.item.name}!`,
      purchase: {
        itemName: marketListing.item.name,
        itemRarity: marketListing.item.rarity,
        quantity: quantity,
        totalCost: totalCost,
        newInventoryQuantity: result.inventoryItem.quantity
      },
      marketListing: {
        id: marketListingId,
        remainingQuantity: result.remainingQuantity,
        wasRemoved: result.remainingQuantity === 0
      }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error purchasing item:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Purchase failed&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/use-item.js</source>
      <tags></tags>
      <metadata>
        <size>5806</size>
        <lastModified>2025-05-29T04:02:05.691Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>// netlify/functions/use-item.js
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const { characterId = &#39;hardcoded-demo&#39;, inventoryId } = JSON.parse(event.body || &#39;{}&#39;)

    if (!inventoryId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Inventory ID is required&#39; })
      }
    }

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Get inventory item with details
    const inventoryItem = await prisma.characterInventory.findUnique({
      where: { id: inventoryId },
      include: { item: true }
    })

    if (!inventoryItem) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Inventory item not found&#39; })
      }
    }

    // Verify ownership
    if (inventoryItem.characterId !== character.id) {
      return {
        statusCode: 403,
        headers,
        body: JSON.stringify({ error: &#39;Item does not belong to this character&#39; })
      }
    }

    // Check if item is consumable
    if (inventoryItem.item.category !== &#39;CONSUMABLE&#39;) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Item not consumable&#39;,
          message: `${inventoryItem.item.name} cannot be consumed`
        })
      }
    }

    // Check if there&#39;s quantity to consume
    if (inventoryItem.quantity &lt;= 0) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;No items to use&#39;,
          message: `You don&#39;t have any ${inventoryItem.item.name} to use`
        })
      }
    }

    // Calculate effects (capped at 100)
    const energyEffect = inventoryItem.item.energyEffect || 0
    const healthEffect = inventoryItem.item.healthEffect || 0

    const newEnergy = Math.min(100, character.energy + energyEffect)
    const newHealth = Math.min(100, character.health + healthEffect)

    const actualEnergyGain = newEnergy - character.energy
    const actualHealthGain = newHealth - character.health

    // Check if effects would be wasted
    if (actualEnergyGain === 0 &amp;&amp; actualHealthGain === 0) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;No effect&#39;,
          message: `Using ${inventoryItem.item.name} would have no effect - you&#39;re already at full health and energy`
        })
      }
    }

    // Perform consumption within transaction
    const result = await prisma.$transaction(async (tx) =&gt; {
      // Update character stats
      const updatedCharacter = await tx.character.update({
        where: { id: character.id },
        data: {
          energy: newEnergy,
          health: newHealth
        }
      })

      // Reduce inventory quantity or remove item
      let updatedInventory
      if (inventoryItem.quantity === 1) {
        // Remove item completely
        await tx.characterInventory.delete({
          where: { id: inventoryId }
        })
        updatedInventory = null
      } else {
        // Reduce quantity
        updatedInventory = await tx.characterInventory.update({
          where: { id: inventoryId },
          data: { quantity: inventoryItem.quantity - 1 },
          include: { item: true }
        })
      }

      // Log the transaction
      const transaction = await tx.transaction.create({
        data: {
          characterId: character.id,
          type: &#39;MINE&#39;, // We can add &#39;USE&#39; to the enum later, using MINE for now
          itemId: inventoryItem.itemId,
          quantity: 1,
          description: `Used ${inventoryItem.item.name}${actualEnergyGain &gt; 0 || actualHealthGain &gt; 0 ?
            ` (${[
              actualEnergyGain &gt; 0 ? `+${actualEnergyGain} energy` : null,
              actualHealthGain &gt; 0 ? `+${actualHealthGain} health` : null
            ].filter(Boolean).join(&#39;, &#39;)})` : &#39;&#39;
            }`
        }
      })

      return {
        character: updatedCharacter,
        inventory: updatedInventory,
        transaction,
        effects: {
          energy: actualEnergyGain,
          health: actualHealthGain
        }
      }
    })

    // Prepare response
    const responseData = {
      success: true,
      message: `Used ${inventoryItem.item.name}!`,
      effects: result.effects,
      newStats: {
        energy: result.character.energy,
        health: result.character.health
      },
      inventory: {
        remainingQuantity: result.inventory?.quantity || 0,
        wasRemoved: !result.inventory
      }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error using item:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to use item&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/get-locations.js</source>
      <tags></tags>
      <metadata>
        <size>3256</size>
        <lastModified>2025-05-29T00:12:36.034Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    // Fetch all top-level locations (no parent) with their sub-locations
    const locations = await prisma.location.findMany({
      where: {
        parentLocationId: null // Only top-level locations
      },
      include: {
        subLocations: {
          include: {
            _count: {
              select: {
                characters: true // Count characters in each sub-location
              }
            }
          },
          orderBy: {
            name: &#39;asc&#39;
          }
        },
        _count: {
          select: {
            characters: true // Count characters directly in parent location
          }
        }
      },
      orderBy: {
        difficulty: &#39;asc&#39; // Easier locations first
      }
    })

    // Transform data for frontend with aggregated player counts
    const responseData = locations.map(location =&gt; {
      // Calculate total players: direct + all sub-locations
      const directPlayerCount = location._count.characters
      const subLocationPlayerCount = location.subLocations.reduce((total, subLoc) =&gt; {
        return total + subLoc._count.characters
      }, 0)
      const totalPlayerCount = directPlayerCount + subLocationPlayerCount

      return {
        id: location.id,
        name: location.name,
        description: location.description,
        locationType: location.locationType,
        biome: location.biome,
        difficulty: location.difficulty,
        playerCount: totalPlayerCount, // Aggregated count
        directPlayerCount: directPlayerCount, // Players directly at this location
        lastActive: location.lastActive,
        hasMarket: location.hasMarket,
        hasMining: location.hasMining,
        hasChat: location.hasChat,
        welcomeMessage: location.welcomeMessage,
        lore: location.lore,

        subLocations: location.subLocations.map(subLoc =&gt; ({
          id: subLoc.id,
          name: subLoc.name,
          description: subLoc.description,
          locationType: subLoc.locationType,
          difficulty: subLoc.difficulty,
          playerCount: subLoc._count.characters, // Real player count for sub-location
          hasMarket: subLoc.hasMarket,
          hasMining: subLoc.hasMining,
          hasChat: subLoc.hasChat,
          welcomeMessage: subLoc.welcomeMessage,
          parentLocationId: subLoc.parentLocationId
        }))
      }
    })

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        locations: responseData,
        timestamp: new Date().toISOString()
      })
    }

  } catch (error) {
    console.error(&#39;Error fetching locations:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to fetch locations&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/get-character.js</source>
      <tags></tags>
      <metadata>
        <size>4642</size>
        <lastModified>2025-05-28T23:17:38.002Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    // For MVP, we&#39;ll use hardcoded character ID
    const characterId = event.queryStringParameters?.characterId || &#39;hardcoded-demo&#39;

    let character

    if (characterId === &#39;hardcoded-demo&#39;) {
      // Return our seeded test character
      character = await prisma.character.findFirst({
        where: {
          name: &quot;Wojak #1337&quot;
        },
        include: {
          currentLocation: true,
          inventory: {
            include: {
              item: true
            }
          },
          imageHistory: {
            orderBy: {
              version: &#39;desc&#39;
            },
            take: 5
          },
          transactions: {
            orderBy: {
              createdAt: &#39;desc&#39;
            },
            take: 10
            // Remove the item include since Transaction doesn&#39;t have a direct relation
          }
        }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId },
        include: {
          currentLocation: true,
          inventory: {
            include: {
              item: true
            }
          },
          imageHistory: {
            orderBy: {
              version: &#39;desc&#39;
            },
            take: 5
          },
          transactions: {
            orderBy: {
              createdAt: &#39;desc&#39;
            },
            take: 10
          }
        }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({
          error: &#39;Character not found&#39;,
          message: &#39;No character exists with the provided ID&#39;
        })
      }
    }

    // For transactions with itemId, we&#39;ll fetch the item separately if needed
    const transactionsWithItems = []
    for (const tx of character.transactions) {
      if (tx.itemId) {
        const item = await prisma.item.findUnique({
          where: { id: tx.itemId }
        })
        transactionsWithItems.push({
          ...tx,
          item: item ? { name: item.name, rarity: item.rarity } : null
        })
      } else {
        transactionsWithItems.push({ ...tx, item: null })
      }
    }

    // Transform the data for frontend consumption
    const responseData = {
      id: character.id,
      name: character.name,
      gender: character.gender,
      characterType: character.characterType,
      energy: character.energy,
      health: character.health,
      currentImageUrl: character.currentImageUrl,
      currentVersion: character.currentVersion,
      nftAddress: character.nftAddress,
      tokenId: character.tokenId,

      currentLocation: {
        id: character.currentLocation.id,
        name: character.currentLocation.name,
        description: character.currentLocation.description,
        locationType: character.currentLocation.locationType,
        biome: character.currentLocation.biome,
        welcomeMessage: character.currentLocation.welcomeMessage
      },

      inventory: character.inventory.map(inv =&gt; ({
        id: inv.id,
        quantity: inv.quantity,
        isEquipped: inv.isEquipped,
        item: {
          id: inv.item.id,
          name: inv.item.name,
          description: inv.item.description,
          category: inv.item.category,
          rarity: inv.item.rarity,
          imageUrl: inv.item.imageUrl,
          layerType: inv.item.layerType
        }
      })),

      imageHistory: character.imageHistory.map(img =&gt; ({
        version: img.version,
        imageUrl: img.imageUrl,
        description: img.description,
        createdAt: img.createdAt
      })),

      recentActivity: transactionsWithItems.map(tx =&gt; ({
        id: tx.id,
        type: tx.type,
        description: tx.description,
        quantity: tx.quantity,
        createdAt: tx.createdAt,
        item: tx.item
      }))
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error fetching character:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to fetch character data&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/equip-item.js</source>
      <tags></tags>
      <metadata>
        <size>6557</size>
        <lastModified>2025-05-29T05:38:49.985Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>// netlify/functions/equip-item.js - Fixed version
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const { characterId = &#39;hardcoded-demo&#39;, inventoryId, equip = true } = JSON.parse(event.body || &#39;{}&#39;)

    if (!inventoryId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Inventory ID is required&#39; })
      }
    }

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Get inventory item with details
    const inventoryItem = await prisma.characterInventory.findUnique({
      where: { id: inventoryId },
      include: { item: true }
    })

    if (!inventoryItem) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Inventory item not found&#39; })
      }
    }

    // Verify ownership
    if (inventoryItem.characterId !== character.id) {
      return {
        statusCode: 403,
        headers,
        body: JSON.stringify({ error: &#39;Item does not belong to this character&#39; })
      }
    }

    // Check if item is equippable
    const equipableCategories = [&#39;HAT&#39;, &#39;CLOTHING&#39;, &#39;ACCESSORY&#39;, &#39;TOOL&#39;]
    if (!equipableCategories.includes(inventoryItem.item.category)) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Item not equippable&#39;,
          message: `${inventoryItem.item.category} items cannot be equipped`
        })
      }
    }

    // Perform equipment action within transaction
    const result = await prisma.$transaction(async (tx) =&gt; {
      let replacedItems = []

      if (equip) {
        // Find conflicting items in the same category to auto-unequip
        const conflictingItems = await tx.characterInventory.findMany({
          where: {
            characterId: character.id,
            isEquipped: true,
            item: {
              category: inventoryItem.item.category
            },
            id: { not: inventoryId } // Don&#39;t include the item we&#39;re trying to equip
          },
          include: { item: true }
        })

        // Unequip conflicting items
        if (conflictingItems.length &gt; 0) {
          await tx.characterInventory.updateMany({
            where: {
              characterId: character.id,
              isEquipped: true,
              item: {
                category: inventoryItem.item.category
              },
              id: { not: inventoryId }
            },
            data: { isEquipped: false }
          })

          // Log unequip transactions for replaced items
          for (const item of conflictingItems) {
            await tx.transaction.create({
              data: {
                characterId: character.id,
                type: &#39;UNEQUIP&#39;,
                itemId: item.itemId,
                description: `Auto-unequipped ${item.item.name} (replaced by ${inventoryItem.item.name})`
              }
            })
          }

          replacedItems = conflictingItems.map(item =&gt; item.item.name)
        }

        // Equip the new item
        const updatedItem = await tx.characterInventory.update({
          where: { id: inventoryId },
          data: { isEquipped: true },
          include: { item: true }
        })

        // Log the equip transaction
        await tx.transaction.create({
          data: {
            characterId: character.id,
            type: &#39;EQUIP&#39;,
            itemId: inventoryItem.itemId,
            description: `Equipped ${inventoryItem.item.name}`
          }
        })

        return {
          action: &#39;equipped&#39;,
          item: updatedItem,
          replacedItems: replacedItems
        }

      } else {
        // Unequip the item
        const updatedItem = await tx.characterInventory.update({
          where: { id: inventoryId },
          data: { isEquipped: false },
          include: { item: true }
        })

        // Log the transaction
        await tx.transaction.create({
          data: {
            characterId: character.id,
            type: &#39;UNEQUIP&#39;,
            itemId: inventoryItem.itemId,
            description: `Unequipped ${inventoryItem.item.name}`
          }
        })

        return { action: &#39;unequipped&#39;, item: updatedItem, replacedItems: [] }
      }
    })

    // Calculate stat effects (for future implementation)
    const statEffects = {
      energy: inventoryItem.item.energyEffect || 0,
      health: inventoryItem.item.healthEffect || 0
    }

    // Prepare response with replacement info
    let message = `${inventoryItem.item.name} ${result.action} successfully!`
    if (result.replacedItems.length &gt; 0) {
      message += ` (Replaced: ${result.replacedItems.join(&#39;, &#39;)})`
    }

    const responseData = {
      success: true,
      message: message,
      item: {
        id: result.item.id,
        name: result.item.item.name,
        category: result.item.item.category,
        rarity: result.item.item.rarity,
        isEquipped: result.item.isEquipped,
        layerType: result.item.item.layerType
      },
      action: result.action,
      replacedItems: result.replacedItems,
      statEffects: equip ? statEffects : { energy: -statEffects.energy, health: -statEffects.health }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error equipping/unequipping item:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Equipment action failed&#39;,
        details: error.message // Added for debugging
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/get-market.js</source>
      <tags></tags>
      <metadata>
        <size>6022</size>
        <lastModified>2025-05-29T03:47:50.500Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>// netlify/functions/get-market.js - Updated version
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    const locationId = event.queryStringParameters?.locationId
    const limit = parseInt(event.queryStringParameters?.limit || &#39;20&#39;)

    if (!locationId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Location ID is required&#39; })
      }
    }

    // Get location with parent info
    const location = await prisma.location.findUnique({
      where: { id: locationId },
      include: {
        parentLocation: true
      }
    })

    if (!location) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Location not found&#39; })
      }
    }

    if (!location.hasMarket) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;No market available&#39;,
          message: &#39;This location does not have a market&#39;
        })
      }
    }

    let allMarketListings = []

    // Get local market listings (items specifically at this location)
    const localListings = await prisma.marketListing.findMany({
      where: {
        locationId: locationId
      },
      include: {
        item: true,
        seller: {
          select: {
            id: true,
            name: true,
            characterType: true
          }
        }
      }
    })

    // If this is a child location, also get parent location&#39;s items (global market)
    let globalListings = []
    if (location.parentLocationId) {
      globalListings = await prisma.marketListing.findMany({
        where: {
          locationId: location.parentLocationId
        },
        include: {
          item: true,
          seller: {
            select: {
              id: true,
              name: true,
              characterType: true
            }
          }
        }
      })
    }

    // Combine and mark items appropriately
    const combinedListings = [
      ...localListings.map(listing =&gt; ({ ...listing, isLocalSpecialty: true })),
      ...globalListings.map(listing =&gt; ({ ...listing, isLocalSpecialty: false }))
    ]

    // If no listings exist at all, create some default items
    if (combinedListings.length === 0) {
      // Get some items to create system listings for
      const availableItems = await prisma.item.findMany({
        where: {
          category: {
            in: [&#39;HAT&#39;, &#39;CLOTHING&#39;, &#39;ACCESSORY&#39;, &#39;CONSUMABLE&#39;]
          }
        },
        take: 6
      })

      // Create system market listings
      const systemListings = await Promise.all(
        availableItems.map(item =&gt; {
          // Price based on rarity
          let price = 10
          switch (item.rarity) {
            case &#39;UNCOMMON&#39;: price = 25; break
            case &#39;RARE&#39;: price = 50; break
            case &#39;EPIC&#39;: price = 100; break
            case &#39;LEGENDARY&#39;: price = 250; break
          }

          return prisma.marketListing.create({
            data: {
              locationId: locationId,
              itemId: item.id,
              price: price,
              quantity: item.category === &#39;CONSUMABLE&#39; ? 5 : 1,
              isSystemItem: true
            },
            include: {
              item: true,
              seller: {
                select: {
                  id: true,
                  name: true,
                  characterType: true
                }
              }
            }
          })
        })
      )

      // Use the newly created listings
      allMarketListings = systemListings.map(listing =&gt; ({ ...listing, isLocalSpecialty: true }))
    } else {
      allMarketListings = combinedListings
    }

    // Transform listings for frontend
    const transformedListings = allMarketListings
      .sort((a, b) =&gt; {
        // Sort: local specialties first, then by creation date
        if (a.isLocalSpecialty &amp;&amp; !b.isLocalSpecialty) return -1
        if (!a.isLocalSpecialty &amp;&amp; b.isLocalSpecialty) return 1
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      })
      .slice(0, limit)
      .map(listing =&gt; ({
        id: listing.id,
        price: listing.price,
        quantity: listing.quantity,
        isSystemItem: listing.isSystemItem,
        isLocalSpecialty: listing.isLocalSpecialty,
        seller: listing.seller ? {
          id: listing.seller.id,
          name: listing.seller.name,
          characterType: listing.seller.characterType
        } : null,
        item: {
          id: listing.item.id,
          name: listing.item.name,
          description: listing.item.description,
          category: listing.item.category,
          rarity: listing.item.rarity,
          imageUrl: listing.item.imageUrl,
          layerType: listing.item.layerType,
          energyEffect: listing.item.energyEffect,
          healthEffect: listing.item.healthEffect
        },
        createdAt: listing.createdAt
      }))

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        items: transformedListings,
        totalCount: transformedListings.length,
        locationId: locationId,
        locationName: location.name,
        isChildLocation: !!location.parentLocationId,
        parentLocationName: location.parentLocation?.name,
        timestamp: new Date().toISOString()
      })
    }

  } catch (error) {
    console.error(&#39;Error fetching market items:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to fetch market items&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/get-players-at-location.js</source>
      <tags></tags>
      <metadata>
        <size>2971</size>
        <lastModified>2025-05-28T23:55:02.361Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;,
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return {
      statusCode: 200,
      headers,
      body: &#39;&#39;
    }
  }

  try {
    const locationId = event.queryStringParameters?.locationId

    if (!locationId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Location ID is required&#39; })
      }
    }

    const players = await prisma.character.findMany({
      where: {
        currentLocationId: locationId
      },
      select: {
        id: true,
        name: true,
        gender: true,
        characterType: true,
        energy: true,
        health: true,
        currentImageUrl: true,
        createdAt: true,
        inventory: {
          where: { isEquipped: true },
          include: { item: true }
        }
      },
      orderBy: {
        name: &#39;asc&#39;
      }
    })

    const playersWithStatus = players.map(player =&gt; {
      let status = &#39;Idle&#39;

      if (player.energy &lt; 20) {
        status = &#39;Resting&#39;
      } else if (player.energy &gt; 90) {
        status = &#39;Energetic&#39;
      } else if (player.inventory.some(inv =&gt; inv.item.category === &#39;HAT&#39;)) {
        status = &#39;Mining&#39;
      } else if (player.energy &lt; 50) {
        status = &#39;Tired&#39;
      } else {
        const activities = [&#39;Mining&#39;, &#39;Exploring&#39;, &#39;Trading&#39;, &#39;Chatting&#39;, &#39;Just Arrived&#39;]
        status = activities[Math.floor(Math.random() * activities.length)]
      }

      const daysSinceCreation = Math.floor((Date.now() - player.createdAt.getTime()) / (1000 * 60 * 60 * 24))
      const level = Math.max(1, Math.floor(daysSinceCreation / 7) + Math.floor(Math.random() * 20) + 1)

      return {
        id: player.id,
        name: player.name,
        gender: player.gender,
        characterType: player.characterType,
        level: level,
        energy: player.energy,
        health: player.health,
        status: status,
        currentImageUrl: player.currentImageUrl,
        equippedItems: player.inventory.map(inv =&gt; ({
          name: inv.item.name,
          category: inv.item.category,
          rarity: inv.item.rarity
        }))
      }
    })

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        players: playersWithStatus,
        totalCount: playersWithStatus.length,
        locationId: locationId,
        timestamp: new Date().toISOString()
      })
    }

  } catch (error) {
    console.error(&#39;Error fetching players:&#39;, error)
    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to fetch players at location&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/mine-action.js</source>
      <tags></tags>
      <metadata>
        <size>6197</size>
        <lastModified>2025-05-29T07:11:55.499Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const { characterId = &#39;hardcoded-demo&#39;, locationId } = JSON.parse(event.body || &#39;{}&#39;)

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; },
        include: { currentLocation: true }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId },
        include: { currentLocation: true }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Use current location if none specified
    const targetLocationId = locationId || character.currentLocationId

    // Check if character has enough energy
    const ENERGY_COST = 10
    if (character.energy &lt; ENERGY_COST) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Not enough energy&#39;,
          message: `Mining requires ${ENERGY_COST} energy. You have ${character.energy}.`,
          currentEnergy: character.energy,
          required: ENERGY_COST
        })
      }
    }

    // Get location and its available resources
    const location = await prisma.location.findUnique({
      where: { id: targetLocationId },
      include: {
        resources: {
          include: {
            item: true
          }
        }
      }
    })

    if (!location || !location.hasMining) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Cannot mine here&#39;,
          message: &#39;This location does not support mining&#39;
        })
      }
    }

    if (location.resources.length === 0) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;No resources available&#39;,
          message: &#39;This location has no mineable resources&#39;
        })
      }
    }

    // Mining logic - check each resource by spawn rate
    const roll = Math.random()
    let foundResource = null

    // Sort by spawn rate (highest first) for better user experience
    const sortedResources = location.resources.sort((a, b) =&gt; b.spawnRate - a.spawnRate)

    for (const resource of sortedResources) {
      if (roll &lt; resource.spawnRate) {
        foundResource = resource
        break
      }
    }

    // Start transaction to update character and add item
    const result = await prisma.$transaction(async (tx) =&gt; {
      // Reduce character energy
      const updatedCharacter = await tx.character.update({
        where: { id: character.id },
        data: {
          energy: character.energy - ENERGY_COST
        }
      })

      let addedItem = null
      let transaction = null

      if (foundResource) {
        // Check if character already has this item in inventory
        const existingInventory = await tx.characterInventory.findUnique({
          where: {
            characterId_itemId: {
              characterId: character.id,
              itemId: foundResource.itemId
            }
          }
        })

        if (existingInventory) {
          // Update quantity
          addedItem = await tx.characterInventory.update({
            where: { id: existingInventory.id },
            data: { quantity: existingInventory.quantity + 1 },
            include: { item: true }
          })
        } else {
          // Create new inventory entry
          addedItem = await tx.characterInventory.create({
            data: {
              characterId: character.id,
              itemId: foundResource.itemId,
              quantity: 1
            },
            include: { item: true }
          })
        }

        // Log the transaction
        transaction = await tx.transaction.create({
          data: {
            characterId: character.id,
            type: &#39;MINE&#39;,
            itemId: foundResource.itemId,
            quantity: 1,
            description: `Found ${foundResource.item.name} while mining in ${location.name}`
          }
        })
      } else {
        // Log failed mining attempt
        transaction = await tx.transaction.create({
          data: {
            characterId: character.id,
            type: &#39;MINE&#39;,
            description: `Mining attempt in ${location.name} - nothing found`
          }
        })
      }

      return {
        character: updatedCharacter,
        foundItem: addedItem,
        transaction
      }
    })

    // Prepare response
    const responseData = {
      success: true,
      energyUsed: ENERGY_COST,
      newEnergyLevel: result.character.energy,
      location: {
        id: location.id,
        name: location.name
      }
    }

    if (result.foundItem) {
      responseData.foundItem = {
        name: result.foundItem.item.name,
        description: result.foundItem.item.description,
        rarity: result.foundItem.item.rarity,
        imageUrl: result.foundItem.item.imageUrl,
        newQuantity: result.foundItem.quantity
      }
      responseData.message = `You found: ${result.foundItem.item.name} (${result.foundItem.item.rarity})!`
    } else {
      responseData.message = &quot;You dig around but find nothing useful...&quot;
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error during mining:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Mining operation failed&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/travel-action.js</source>
      <tags></tags>
      <metadata>
        <size>5685</size>
        <lastModified>2025-05-28T23:30:33.914Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const { characterId = &#39;hardcoded-demo&#39;, destinationId } = JSON.parse(event.body || &#39;{}&#39;)

    if (!destinationId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Destination ID is required&#39; })
      }
    }

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; },
        include: { currentLocation: true }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId },
        include: { currentLocation: true }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Get destination location
    const destination = await prisma.location.findUnique({
      where: { id: destinationId },
      include: {
        subLocations: true,
        parentLocation: true
      }
    })

    if (!destination) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Destination not found&#39; })
      }
    }

    // Check if already at destination
    if (character.currentLocationId === destinationId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Already at destination&#39;,
          message: `You are already in ${destination.name}`
        })
      }
    }

    // TODO: Future travel requirements check
    // const requirements = getTravelRequirements(character.currentLocation, destination)
    // const canTravel = checkTravelRequirements(character, requirements)
    // if (!canTravel.allowed) {
    //   return { statusCode: 400, body: JSON.stringify({ error: canTravel.reason }) }
    // }

    // For MVP: Instant travel with no cost
    const result = await prisma.$transaction(async (tx) =&gt; {
      // Update character location
      const updatedCharacter = await tx.character.update({
        where: { id: character.id },
        data: {
          currentLocationId: destinationId
        },
        include: {
          currentLocation: true
        }
      })

      // Log the travel transaction
      const transaction = await tx.transaction.create({
        data: {
          characterId: character.id,
          type: &#39;TRAVEL&#39;,
          description: `Traveled from ${character.currentLocation.name} to ${destination.name}`
        }
      })

      // Update player counts (decrement old location, increment new location)
      await tx.location.update({
        where: { id: character.currentLocationId },
        data: {
          playerCount: { decrement: 1 }
        }
      })

      await tx.location.update({
        where: { id: destinationId },
        data: {
          playerCount: { increment: 1 },
          lastActive: new Date()
        }
      })

      return {
        character: updatedCharacter,
        transaction
      }
    })

    // Prepare response
    const responseData = {
      success: true,
      message: `Welcome to ${destination.name}!`,
      newLocation: {
        id: destination.id,
        name: destination.name,
        description: destination.description,
        locationType: destination.locationType,
        biome: destination.biome,
        welcomeMessage: destination.welcomeMessage,
        lore: destination.lore,
        hasMarket: destination.hasMarket,
        hasMining: destination.hasMining,
        hasChat: destination.hasChat
      },
      previousLocation: {
        id: character.currentLocation.id,
        name: character.currentLocation.name
      },
      // Future: costs incurred
      costs: {
        time: 0,      // minutes
        energy: 0,    // energy points
        money: 0,     // SOL
        status: []    // required items used
      }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify(responseData)
    }

  } catch (error) {
    console.error(&#39;Error during travel:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Travel failed&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}

// Future: Travel requirements calculation
function getTravelRequirements(origin, destination) {
  // Calculate based on:
  // - Distance (map coordinates)
  // - Difficulty difference
  // - Location type (REGION vs BUILDING vs ROOM)
  // - Special requirements per location

  return {
    time: 0,        // Will calculate based on distance/difficulty
    energy: 0,      // Will calculate based on terrain/difficulty  
    money: 0,       // Will be location-specific
    status: []      // Will check location.minLevel, required items, etc.
  }
}

function checkTravelRequirements(character, requirements) {
  // Check if character meets all requirements
  // - Has enough energy
  // - Can afford SOL cost
  // - Has required status items in inventory
  // - Meets level requirements

  return {
    allowed: true,
    reason: null
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/render-character.js</source>
      <tags></tags>
      <metadata>
        <size>4859</size>
        <lastModified>2025-05-29T02:46:20.676Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>// netlify/functions/render-character.js
import { PrismaClient } from &#39;@prisma/client&#39;

// For now, let&#39;s create a simple version without Sharp since it might be causing issues
const prisma = new PrismaClient()

// Configuration
const ASSET_BASE_URL = process.env.NODE_ENV === &#39;production&#39;
  ? &#39;https://earth.ndao.computer&#39;
  : process.env.URL || &#39;http://localhost:8888&#39;

/**
 * Generate character layers from database data
 */
function generateCharacterLayers(character) {
  const layers = []

  // Background layer
  const backgroundName = character.currentLocation?.biome || &#39;mining-plains&#39;
  layers.push({
    type: &#39;backgrounds&#39;,
    name: backgroundName,
    url: `${ASSET_BASE_URL}/layers/backgrounds/${backgroundName}.png`,
    visible: true,
    zIndex: 0
  })

  // Base layer
  const baseName = character.gender?.toLowerCase() || &#39;male&#39;
  layers.push({
    type: &#39;bases&#39;,
    name: baseName,
    url: `${ASSET_BASE_URL}/layers/bases/${baseName}.png`,
    visible: true,
    zIndex: 1
  })

  // Equipment layers from inventory
  if (character.inventory) {
    character.inventory
      .filter(inv =&gt; inv.isEquipped)
      .forEach(inv =&gt; {
        const item = inv.item
        let layerType, layerName

        // Map items to layers
        switch (item.category) {
          case &#39;HAT&#39;:
            if (item.name === &#39;Miners Hat&#39;) {
              layerType = &#39;accessories&#39;
              layerName = &#39;miners-hat&#39;
            }
            break
          case &#39;CLOTHING&#39;:
            if (item.name === &#39;Cyber Jacket&#39;) {
              layerType = &#39;clothing&#39;
              layerName = &#39;cyber-jacket&#39;
            } else if (item.name === &#39;Work Gloves&#39;) {
              layerType = &#39;accessories&#39;
              layerName = &#39;work-gloves&#39;
            }
            break
          case &#39;ACCESSORY&#39;:
            if (item.name === &#39;Lucky Charm&#39;) {
              layerType = &#39;accessories&#39;
              layerName = &#39;lucky-charm&#39;
            }
            break
        }

        if (layerType &amp;&amp; layerName) {
          layers.push({
            type: layerType,
            name: layerName,
            url: `${ASSET_BASE_URL}/layers/${layerType}/${layerName}.png`,
            visible: true,
            zIndex: layerType === &#39;clothing&#39; ? 2 : 3
          })
        }
      })
  }

  // Sort by z-index
  return layers.sort((a, b) =&gt; a.zIndex - b.zIndex)
}

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;,
    &#39;Cache-Control&#39;: &#39;public, max-age=3600&#39; // Cache for 1 hour
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    // Extract character ID from path
    const pathParts = event.path.split(&#39;/&#39;)
    const characterParam = pathParts[pathParts.length - 1]
    const characterId = characterParam.replace(&#39;.png&#39;, &#39;&#39;)

    if (!characterId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Character ID required&#39; })
      }
    }

    // Get character data
    let character

    if (characterId === &#39;demo&#39; || characterId === &#39;1337&#39;) {
      // Demo character
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; },
        include: {
          currentLocation: true,
          inventory: {
            where: { isEquipped: true },
            include: { item: true }
          }
        }
      })
    } else {
      // Real character by ID
      character = await prisma.character.findUnique({
        where: { id: characterId },
        include: {
          currentLocation: true,
          inventory: {
            where: { isEquipped: true },
            include: { item: true }
          }
        }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // For now, just return the layer information as JSON until we get Sharp working
    // Generate layers
    const layers = generateCharacterLayers(character)

    return {
      statusCode: 200,
      headers: {
        ...headers,
        &#39;Content-Type&#39;: &#39;application/json&#39;
      },
      body: JSON.stringify({
        character: {
          id: character.id,
          name: character.name,
          location: character.currentLocation?.name
        },
        layers: layers,
        message: &#39;Layer composition ready - PNG rendering coming soon!&#39;
      })
    }

  } catch (error) {
    console.error(&#39;Error rendering character:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Rendering failed&#39;,
        message: error.message
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/send-message.js</source>
      <tags></tags>
      <metadata>
        <size>6576</size>
        <lastModified>2025-05-29T00:06:10.082Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;POST, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  if (event.httpMethod !== &#39;POST&#39;) {
    return {
      statusCode: 405,
      headers,
      body: JSON.stringify({ error: &#39;Method not allowed&#39; })
    }
  }

  try {
    const {
      characterId = &#39;hardcoded-demo&#39;,
      locationId,
      message,
      messageType = &#39;CHAT&#39;
    } = JSON.parse(event.body || &#39;{}&#39;)

    if (!locationId || !message?.trim()) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Missing required fields&#39;,
          message: &#39;Location ID and message content are required&#39;
        })
      }
    }

    // Validate message length
    if (message.length &gt; 500) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Message too long&#39;,
          message: &#39;Messages must be 500 characters or less&#39;
        })
      }
    }

    // Get character
    let character
    if (characterId === &#39;hardcoded-demo&#39;) {
      character = await prisma.character.findFirst({
        where: { name: &quot;Wojak #1337&quot; }
      })
    } else {
      character = await prisma.character.findUnique({
        where: { id: characterId }
      })
    }

    if (!character) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Character not found&#39; })
      }
    }

    // Get location to verify it exists and has chat enabled
    const location = await prisma.location.findUnique({
      where: { id: locationId }
    })

    if (!location) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Location not found&#39; })
      }
    }

    if (!location.hasChat) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Chat not available&#39;,
          message: &#39;This location does not support chat&#39;
        })
      }
    }

    // Verify character is at this location or a related location (for regional chat)
    let canChat = false

    if (character.currentLocationId === locationId) {
      canChat = true
    } else if (location.chatScope === &#39;REGIONAL&#39;) {
      // Check if character is in a sub-location or parent location
      const characterLocation = await prisma.location.findUnique({
        where: { id: character.currentLocationId }
      })

      if (characterLocation) {
        // Check if character&#39;s location is a parent of the chat location
        if (characterLocation.id === location.parentLocationId) {
          canChat = true
        }
        // Check if character&#39;s location has the same parent as chat location
        else if (characterLocation.parentLocationId === location.parentLocationId &amp;&amp; location.parentLocationId) {
          canChat = true
        }
        // Check if chat location is a sub-location of character&#39;s location
        else if (location.parentLocationId === characterLocation.id) {
          canChat = true
        }
      }
    }

    if (!canChat) {
      return {
        statusCode: 403,
        headers,
        body: JSON.stringify({
          error: &#39;Cannot chat here&#39;,
          message: &#39;You must be at this location to participate in chat&#39;
        })
      }
    }

    // Basic content filtering (expand as needed)
    const bannedWords = [&#39;spam&#39;, &#39;scam&#39;, &#39;hack&#39;] // Add more as needed
    const lowercaseMessage = message.toLowerCase()
    const hasBannedWords = bannedWords.some(word =&gt; lowercaseMessage.includes(word))

    if (hasBannedWords) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({
          error: &#39;Message blocked&#39;,
          message: &#39;Your message contains prohibited content&#39;
        })
      }
    }

    // Rate limiting check (simple version)
    const recentMessages = await prisma.chatMessage.findMany({
      where: {
        characterId: character.id,
        createdAt: {
          gte: new Date(Date.now() - 60000) // Last minute
        }
      }
    })

    if (recentMessages.length &gt;= 10) {
      return {
        statusCode: 429,
        headers,
        body: JSON.stringify({
          error: &#39;Rate limited&#39;,
          message: &#39;Please wait before sending another message&#39;
        })
      }
    }

    // Create chat message
    const chatMessage = await prisma.chatMessage.create({
      data: {
        locationId: locationId,
        characterId: character.id,
        message: message.trim(),
        messageType: messageType,
        isSystem: false
      },
      include: {
        character: {
          select: {
            id: true,
            name: true,
            characterType: true,
            currentImageUrl: true
          }
        },
        location: {
          select: {
            id: true,
            name: true,
            locationType: true
          }
        }
      }
    })

    // Update location last active timestamp
    await prisma.location.update({
      where: { id: locationId },
      data: { lastActive: new Date() }
    })

    // Transform message for response
    const transformedMessage = {
      id: chatMessage.id,
      message: chatMessage.message,
      messageType: chatMessage.messageType,
      isSystem: chatMessage.isSystem,
      timeAgo: &#39;now&#39;,
      createdAt: chatMessage.createdAt,
      character: {
        id: chatMessage.character.id,
        name: chatMessage.character.name,
        characterType: chatMessage.character.characterType,
        imageUrl: chatMessage.character.currentImageUrl
      },
      location: {
        id: chatMessage.location.id,
        name: chatMessage.location.name,
        locationType: chatMessage.location.locationType
      }
    }

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        success: true,
        message: &#39;Message sent successfully&#39;,
        chatMessage: transformedMessage,
        timestamp: new Date().toISOString()
      })
    }

  } catch (error) {
    console.error(&#39;Error sending message:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to send message&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}
</content>
    </document>

    <document>
      <source>netlify/functions/get-chat.js</source>
      <tags></tags>
      <metadata>
        <size>4454</size>
        <lastModified>2025-05-28T23:51:59.175Z</lastModified>
        <extension>js</extension>
        <directory>netlify/functions</directory>
      </metadata>
      <content>import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

export const handler = async (event, context) =&gt; {
  const headers = {
    &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39;,
    &#39;Access-Control-Allow-Headers&#39;: &#39;Content-Type&#39;,
    &#39;Access-Control-Allow-Methods&#39;: &#39;GET, OPTIONS&#39;
  }

  if (event.httpMethod === &#39;OPTIONS&#39;) {
    return { statusCode: 200, headers, body: &#39;&#39; }
  }

  try {
    const locationId = event.queryStringParameters?.locationId
    const limit = parseInt(event.queryStringParameters?.limit || &#39;50&#39;)

    if (!locationId) {
      return {
        statusCode: 400,
        headers,
        body: JSON.stringify({ error: &#39;Location ID is required&#39; })
      }
    }

    // Get the location to understand chat scope
    const location = await prisma.location.findUnique({
      where: { id: locationId },
      include: {
        parentLocation: true,
        subLocations: true
      }
    })

    if (!location) {
      return {
        statusCode: 404,
        headers,
        body: JSON.stringify({ error: &#39;Location not found&#39; })
      }
    }

    let chatLocationIds = [locationId]

    // Handle chat scope - REGIONAL chat includes parent and sub-locations
    if (location.chatScope === &#39;REGIONAL&#39;) {
      // If this is a parent location, include all sub-locations
      if (location.subLocations?.length &gt; 0) {
        chatLocationIds.push(...location.subLocations.map(sub =&gt; sub.id))
      }
      // If this is a sub-location, include the parent
      if (location.parentLocationId) {
        chatLocationIds.push(location.parentLocationId)
        // Also include sibling sub-locations
        const siblings = await prisma.location.findMany({
          where: {
            parentLocationId: location.parentLocationId,
            id: { not: locationId }
          }
        })
        chatLocationIds.push(...siblings.map(sib =&gt; sib.id))
      }
    }

    // Get chat messages for the relevant locations
    const messages = await prisma.chatMessage.findMany({
      where: {
        locationId: { in: chatLocationIds }
      },
      include: {
        character: {
          select: {
            id: true,
            name: true,
            characterType: true,
            currentImageUrl: true
          }
        },
        location: {
          select: {
            id: true,
            name: true,
            locationType: true
          }
        }
      },
      orderBy: {
        createdAt: &#39;desc&#39;
      },
      take: limit
    })

    // Transform messages for frontend
    const transformedMessages = messages.reverse().map(msg =&gt; {
      // Calculate time ago
      const timeAgo = getTimeAgo(msg.createdAt)

      return {
        id: msg.id,
        message: msg.message,
        messageType: msg.messageType,
        isSystem: msg.isSystem,
        timeAgo: timeAgo,
        createdAt: msg.createdAt,
        character: msg.isSystem ? null : {
          id: msg.character.id,
          name: msg.character.name,
          characterType: msg.character.characterType,
          imageUrl: msg.character.currentImageUrl
        },
        location: {
          id: msg.location.id,
          name: msg.location.name,
          locationType: msg.location.locationType
        }
      }
    })

    return {
      statusCode: 200,
      headers,
      body: JSON.stringify({
        messages: transformedMessages,
        totalCount: transformedMessages.length,
        locationId: locationId,
        chatScope: location.chatScope,
        locationName: location.name,
        timestamp: new Date().toISOString()
      })
    }

  } catch (error) {
    console.error(&#39;Error fetching chat messages:&#39;, error)

    return {
      statusCode: 500,
      headers,
      body: JSON.stringify({
        error: &#39;Internal server error&#39;,
        message: &#39;Failed to fetch chat messages&#39;
      })
    }
  } finally {
    await prisma.$disconnect()
  }
}

// Helper function to calculate time ago
function getTimeAgo(date) {
  const now = new Date()
  const diffInSeconds = Math.floor((now - date) / 1000)

  if (diffInSeconds &lt; 60) {
    return `${diffInSeconds}s ago`
  } else if (diffInSeconds &lt; 3600) {
    const minutes = Math.floor(diffInSeconds / 60)
    return `${minutes}m ago`
  } else if (diffInSeconds &lt; 86400) {
    const hours = Math.floor(diffInSeconds / 3600)
    return `${hours}h ago`
  } else {
    const days = Math.floor(diffInSeconds / 86400)
    return `${days}d ago`
  }
}
</content>
    </document>

    <document>
      <source>scripts/update-mining-with-tools.ts</source>
      <tags></tags>
      <metadata>
        <size>4576</size>
        <lastModified>2025-05-29T06:21:32.931Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/update-mining-with-tools.ts - Add new tools to mining locations
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// Additional mining resources with new tools
const TOOL_MINING_CONFIGS = {
  &#39;Mining Plains&#39;: [
    { name: &#39;Basic Pickaxe&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 1 },
    { name: &#39;Multi-Tool&#39;, spawnRate: 0.05, maxPerDay: 2, difficulty: 1 },
    { name: &#39;Repair Kit&#39;, spawnRate: 0.04, maxPerDay: 2, difficulty: 1 },
  ],

  &#39;Crystal Caves&#39;: [
    { name: &#39;Drill Hammer&#39;, spawnRate: 0.03, maxPerDay: 1, difficulty: 3 },
    { name: &#39;Scanning Device&#39;, spawnRate: 0.02, maxPerDay: 1, difficulty: 3 },
    { name: &#39;Laser Cutter&#39;, spawnRate: 0.015, maxPerDay: 1, difficulty: 4 },
    { name: &#39;Omni-Tool&#39;, spawnRate: 0.002, maxPerDay: 1, difficulty: 5 }, // Ultra rare
  ],

  &#39;Desert Outpost&#39;: [
    { name: &#39;Survival Knife&#39;, spawnRate: 0.06, maxPerDay: 2, difficulty: 2 },
    { name: &#39;Fire Starter&#39;, spawnRate: 0.05, maxPerDay: 3, difficulty: 1 },
    { name: &#39;GPS Tracker&#39;, spawnRate: 0.03, maxPerDay: 1, difficulty: 2 },
  ],

  &#39;Central Exchange&#39;: [
    { name: &#39;Hacking Toolkit&#39;, spawnRate: 0.02, maxPerDay: 1, difficulty: 4 },
    { name: &#39;Signal Booster&#39;, spawnRate: 0.04, maxPerDay: 2, difficulty: 3 },
    {
      name: &#39;Quantum Processor&#39;,
      spawnRate: 0.008,
      maxPerDay: 1,
      difficulty: 4,
    },
  ],

  &#39;The Glitch Club&#39;: [
    { name: &#39;Hacking Toolkit&#39;, spawnRate: 0.035, maxPerDay: 2, difficulty: 3 }, // Better in underground
    { name: &#39;Reality Wrench&#39;, spawnRate: 0.001, maxPerDay: 1, difficulty: 5 }, // Legendary find
  ],
}

async function updateMiningWithTools() {
  console.log(&#39;üîß Adding new tools to mining locations...&#39;)

  try {
    const locations = await prisma.location.findMany({
      where: { hasMining: true },
    })

    const items = await prisma.item.findMany()
    const itemMap = new Map(items.map((item) =&gt; [item.name, item]))

    let totalResourcesAdded = 0

    for (const location of locations) {
      const toolConfigs =
        TOOL_MINING_CONFIGS[location.name as keyof typeof TOOL_MINING_CONFIGS]

      if (!toolConfigs) {
        continue // Skip locations without tool configs
      }

      console.log(`\nüîß Adding tools to ${location.name}...`)

      for (const toolConfig of toolConfigs) {
        const item = itemMap.get(toolConfig.name)

        if (!item) {
          console.log(`  ‚ùå Tool &#39;${toolConfig.name}&#39; not found in database`)
          continue
        }

        // Check if resource already exists
        const existingResource = await prisma.locationResource.findUnique({
          where: {
            locationId_itemId: {
              locationId: location.id,
              itemId: item.id,
            },
          },
        })

        if (existingResource) {
          console.log(
            `  ‚ö†Ô∏è  ${toolConfig.name} already configured for this location`
          )
          continue
        }

        // Create new resource
        await prisma.locationResource.create({
          data: {
            locationId: location.id,
            itemId: item.id,
            spawnRate: toolConfig.spawnRate,
            maxPerDay: toolConfig.maxPerDay,
            difficulty: toolConfig.difficulty,
          },
        })

        console.log(
          `  ‚ú® Added ${toolConfig.name}: ${(
            toolConfig.spawnRate * 100
          ).toFixed(1)}% spawn`
        )
        totalResourcesAdded++
      }
    }

    console.log(
      `\nüéâ Tool mining resources added! Added ${totalResourcesAdded} new tool nodes`
    )

    // Show ultra-rare tool finds
    console.log(&#39;\n‚≠ê Ultra-Rare Tool Finds:&#39;)
    const rareToolResources = await prisma.locationResource.findMany({
      where: {
        spawnRate: { lt: 0.01 },
        item: { category: &#39;TOOL&#39; },
      },
      include: {
        item: true,
        location: true,
      },
      orderBy: { spawnRate: &#39;asc&#39; },
    })

    rareToolResources.forEach((resource) =&gt; {
      console.log(
        `  üîß ${resource.item.name} in ${resource.location.name}: ${(
          resource.spawnRate * 100
        ).toFixed(2)}% chance`
      )
    })

    // Show total tool mining nodes
    const totalToolNodes = await prisma.locationResource.count({
      where: {
        item: { category: &#39;TOOL&#39; },
      },
    })

    console.log(`\nüìä Total tool mining nodes: ${totalToolNodes}`)
  } catch (error) {
    console.error(&#39;‚ùå Failed to update mining with tools:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

updateMiningWithTools()
</content>
    </document>

    <document>
      <source>scripts/seed-mining-resources.ts</source>
      <tags></tags>
      <metadata>
        <size>7017</size>
        <lastModified>2025-05-29T04:58:00.336Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/seed-mining-resources.ts
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// Mining resource configurations per location
const MINING_CONFIGS = {
  &#39;Mining Plains&#39;: {
    resources: [
      { name: &#39;Dirty Coal&#39;, spawnRate: 0.6, maxPerDay: 25, difficulty: 1 },
      { name: &#39;Iron Scraps&#39;, spawnRate: 0.4, maxPerDay: 15, difficulty: 1 },
      { name: &#39;Ancient Coin&#39;, spawnRate: 0.05, maxPerDay: 2, difficulty: 1 }, // Rare find
    ],
  },
  &#39;Crystal Caves&#39;: {
    resources: [
      { name: &#39;Crystal Shard&#39;, spawnRate: 0.15, maxPerDay: 5, difficulty: 3 },
      { name: &#39;Iron Scraps&#39;, spawnRate: 0.3, maxPerDay: 8, difficulty: 2 },
      { name: &#39;Ancient Coin&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 2 },
    ],
  },
  &#39;Desert Outpost&#39;: {
    resources: [
      { name: &#39;Ancient Coin&#39;, spawnRate: 0.2, maxPerDay: 8, difficulty: 3 }, // Desert specialty
      { name: &#39;Crystal Shard&#39;, spawnRate: 0.08, maxPerDay: 2, difficulty: 4 }, // Very rare
      { name: &#39;Iron Scraps&#39;, spawnRate: 0.25, maxPerDay: 6, difficulty: 3 },
    ],
  },
  // Sub-locations get their own resources too
  &#39;Rusty Pickaxe Inn&#39;: {
    resources: [
      { name: &#39;Dirty Coal&#39;, spawnRate: 0.3, maxPerDay: 5, difficulty: 1 }, // Limited indoor mining
    ],
  },
}

async function seedMiningResources() {
  console.log(&#39;‚õèÔ∏è  Starting mining resources seed...&#39;)

  try {
    // Get all locations and items for reference
    const locations = await prisma.location.findMany({
      where: { hasMining: true },
    })

    const items = await prisma.item.findMany()
    const itemMap = new Map(items.map((item) =&gt; [item.name, item]))

    console.log(`üìç Found ${locations.length} minable locations`)
    console.log(`üì¶ Found ${items.length} items in database`)

    for (const location of locations) {
      const config =
        MINING_CONFIGS[location.name as keyof typeof MINING_CONFIGS]

      if (!config) {
        console.log(`‚ö†Ô∏è  No mining config for ${location.name}, skipping...`)
        continue
      }

      console.log(`\n‚õèÔ∏è  Setting up mining resources for ${location.name}...`)

      for (const resourceConfig of config.resources) {
        const item = itemMap.get(resourceConfig.name)

        if (!item) {
          console.log(
            `  ‚ùå Item &#39;${resourceConfig.name}&#39; not found in database`
          )
          continue
        }

        // Check if resource already exists
        const existingResource = await prisma.locationResource.findUnique({
          where: {
            locationId_itemId: {
              locationId: location.id,
              itemId: item.id,
            },
          },
        })

        if (existingResource) {
          // Update existing resource
          await prisma.locationResource.update({
            where: { id: existingResource.id },
            data: {
              spawnRate: resourceConfig.spawnRate,
              maxPerDay: resourceConfig.maxPerDay,
              difficulty: resourceConfig.difficulty,
            },
          })
          console.log(
            `  üîÑ Updated ${resourceConfig.name}: ${(
              resourceConfig.spawnRate * 100
            ).toFixed(1)}% spawn rate, max ${resourceConfig.maxPerDay}/day`
          )
        } else {
          // Create new resource
          await prisma.locationResource.create({
            data: {
              locationId: location.id,
              itemId: item.id,
              spawnRate: resourceConfig.spawnRate,
              maxPerDay: resourceConfig.maxPerDay,
              difficulty: resourceConfig.difficulty,
            },
          })
          console.log(
            `  ‚ú® Added ${resourceConfig.name}: ${(
              resourceConfig.spawnRate * 100
            ).toFixed(1)}% spawn rate, max ${resourceConfig.maxPerDay}/day`
          )
        }
      }
    }

    console.log(&#39;\nüéâ Mining resources seed completed successfully!&#39;)

    // Show summary
    const totalResources = await prisma.locationResource.count()
    console.log(`üìä Total mining resources available: ${totalResources}`)

    // Show resource breakdown by location
    console.log(&#39;\nüìã Resource Summary:&#39;)
    for (const location of locations) {
      const locationResources = await prisma.locationResource.findMany({
        where: { locationId: location.id },
        include: { item: true },
      })

      if (locationResources.length &gt; 0) {
        console.log(`\n  ${location.name}:`)
        locationResources.forEach((resource) =&gt; {
          console.log(
            `    ‚Ä¢ ${resource.item.name} (${(resource.spawnRate * 100).toFixed(
              1
            )}% chance, ${resource.maxPerDay}/day max)`
          )
        })
      }
    }
  } catch (error) {
    console.error(&#39;‚ùå Mining resources seed failed:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

// Command line options
const args = process.argv.slice(2)

if (args.includes(&#39;--help&#39;) || args.includes(&#39;-h&#39;)) {
  console.log(`
‚õèÔ∏è  Mining Resources Seed Script

Usage:
  npm run seed:mining                    # Setup all mining resources
  npm run seed:mining --clear            # Clear all resources first
  npm run seed:mining --location &quot;Mining Plains&quot;  # Setup specific location

Options:
  --clear                               Clear all location resources first
  --location &lt;name&gt;                     Only setup specific location
  --dry-run                            Show what would be changed without making changes
  --help, -h                           Show this help message

Resource Spawn Rates:
  0.6 = 60% chance (very common)
  0.4 = 40% chance (common)  
  0.2 = 20% chance (uncommon)
  0.1 = 10% chance (rare)
  0.05 = 5% chance (very rare)
`)
  process.exit(0)
}

// Handle clear option
if (args.includes(&#39;--clear&#39;)) {
  console.log(&#39;üßπ Clearing existing mining resources...&#39;)
  await prisma.locationResource.deleteMany({})
  console.log(&#39;‚úÖ Cleared all mining resources&#39;)
}

// Handle dry run
if (args.includes(&#39;--dry-run&#39;)) {
  console.log(&#39;üîç DRY RUN MODE - No changes will be made&#39;)
  // You&#39;d implement dry run logic here
}

// Handle specific location
const locationArg = args.indexOf(&#39;--location&#39;)
if (locationArg !== -1 &amp;&amp; args[locationArg + 1]) {
  const targetLocation = args[locationArg + 1]
  console.log(`üéØ Targeting specific location: ${targetLocation}`)

  // Filter MINING_CONFIGS to only include the target location
  const filteredConfig = {
    [targetLocation]:
      MINING_CONFIGS[targetLocation as keyof typeof MINING_CONFIGS],
  }

  if (!filteredConfig[targetLocation]) {
    console.error(`‚ùå No mining config found for location: ${targetLocation}`)
    console.log(&#39;Available locations:&#39;, Object.keys(MINING_CONFIGS).join(&#39;, &#39;))
    process.exit(1)
  }

  // Replace the configs with filtered version
  Object.keys(MINING_CONFIGS).forEach((key) =&gt; {
    if (key !== targetLocation) {
      delete MINING_CONFIGS[key as keyof typeof MINING_CONFIGS]
    }
  })
}

// Run the seed
seedMiningResources()
</content>
    </document>

    <document>
      <source>scripts/fix-market-locations.ts</source>
      <tags></tags>
      <metadata>
        <size>2825</size>
        <lastModified>2025-05-29T06:07:56.390Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/fix-market-locations.ts - Fix market settings
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

async function fixMarketLocations() {
  console.log(&#39;üîß Fixing market location settings...\n&#39;)

  try {
    // Enable markets for locations that should have them
    const locationsToEnableMarkets = [
      &#39;Crystal Caves&#39;, // Should have a market
      &#39;The Glitch Club&#39;, // Should have a market
      &#39;Cyber City&#39;,
    ]

    // Disable markets for locations that shouldn&#39;t have them
    const locationsToDisableMarkets = [
      // &#39;Cyber City&#39;, // Parent location - markets are in sub-locations
    ]

    console.log(&#39;‚úÖ ENABLING MARKETS:&#39;)
    for (const locationName of locationsToEnableMarkets) {
      const result = await prisma.location.updateMany({
        where: { name: locationName },
        data: { hasMarket: true },
      })

      if (result.count &gt; 0) {
        console.log(`  üè™ ${locationName} - market enabled`)
      } else {
        console.log(`  ‚ùå ${locationName} - location not found`)
      }
    }

    console.log(&#39;\n‚ùå DISABLING MARKETS:&#39;)
    for (const locationName of locationsToDisableMarkets) {
      const result = await prisma.location.updateMany({
        where: { name: locationName },
        data: { hasMarket: false },
      })

      if (result.count &gt; 0) {
        console.log(
          `  üö´ ${locationName} - market disabled (use sub-locations instead)`
        )
      } else {
        console.log(`  ‚ùå ${locationName} - location not found`)
      }
    }

    console.log(&#39;\nüîç UPDATED MARKET LOCATIONS:&#39;)
    const marketLocations = await prisma.location.findMany({
      where: { hasMarket: true },
      orderBy: [{ parentLocationId: &#39;asc&#39; }, { name: &#39;asc&#39; }],
    })

    marketLocations.forEach((location) =&gt; {
      const isParent = !location.parentLocationId
      const parentIcon = isParent ? &#39;üèõÔ∏è&#39; : &#39;  ‚îî‚îÄ&#39;
      console.log(`${parentIcon} ${location.name} (${location.locationType})`)
    })

    console.log(`\nüìä Total market locations: ${marketLocations.length}`)

    // Check if we have configs for all market locations
    const MARKET_CONFIG_NAMES = [
      &#39;Mining Plains&#39;,
      &#39;Central Exchange&#39;,
      &#39;Desert Outpost&#39;,
      &#39;The Glitch Club&#39;,
      &#39;Rusty Pickaxe Inn&#39;,
      &#39;Crystal Caves&#39;,
      &#39;Cyber City&#39;, // Added parent location config
    ]

    console.log(&#39;\nüéØ MARKET CONFIG COVERAGE:&#39;)
    marketLocations.forEach((location) =&gt; {
      const hasConfig = MARKET_CONFIG_NAMES.includes(location.name)
      const configIcon = hasConfig ? &#39;‚úÖ&#39; : &#39;‚ùå&#39;
      console.log(`  ${configIcon} ${location.name}`)
    })

    console.log(&#39;\n‚ú® Market location settings fixed!&#39;)
  } catch (error) {
    console.error(&#39;‚ùå Fix failed:&#39;, error)
  } finally {
    await prisma.$disconnect()
  }
}

fixMarketLocations()
</content>
    </document>

    <document>
      <source>scripts/setup-new-regions-content.ts</source>
      <tags></tags>
      <metadata>
        <size>9594</size>
        <lastModified>2025-05-29T10:04:14.004Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/setup-new-regions-content.ts - Markets &amp; Mining for the 5 new regions
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// Market configurations for new regions
const NEW_MARKET_CONFIGS = {
  &#39;The Glitch Wastes&#39;: [
    { name: &#39;Glitch Goggles&#39;, quantity: 2, price: 120 },
    { name: &#39;Buffer Overflow Potion&#39;, quantity: 1, price: 200 },
    { name: &#39;Pixel Dust&#39;, quantity: 15, price: 8 },
    { name: &#39;Energy Drink&#39;, quantity: 5, price: 20 }, // More expensive in harsh digital wasteland
    { name: &#39;Hacking Toolkit&#39;, quantity: 3, price: 90 }, // Cheaper here
    { name: &#39;Signal Booster&#39;, quantity: 2, price: 60 },
  ],

  &#39;Error 404 Oasis&#39;: [
    { name: &#39;Buffer Overflow Potion&#39;, quantity: 3, price: 180 }, // Oasis specialty
    { name: &#39;Health Potion&#39;, quantity: 8, price: 40 },
    { name: &#39;Temporal Stabilizer&#39;, quantity: 2, price: 85 }, // Cross-region rare item
  ],

  &#39;Fungi Networks&#39;: [
    { name: &#39;Symbiotic Armor&#39;, quantity: 1, price: 300 },
    { name: &#39;Decay Catalyst&#39;, quantity: 2, price: 150 },
    { name: &#39;Neural Spores&#39;, quantity: 12, price: 25 },
    { name: &#39;Mycelium Thread&#39;, quantity: 20, price: 5 },
    { name: &#39;Health Potion&#39;, quantity: 15, price: 18 }, // Cheaper organic healing
    { name: &#39;Bone Marrow Elixir&#39;, quantity: 4, price: 60 },
  ],

  &#39;Spore Exchange&#39;: [
    { name: &#39;Neural Spores&#39;, quantity: 25, price: 20 }, // Exchange specialty
    { name: &#39;Mycelium Thread&#39;, quantity: 50, price: 3 },
    { name: &#39;Living Bone Tools&#39;, quantity: 2, price: 180 },
    { name: &#39;Symbiotic Armor&#39;, quantity: 2, price: 280 },
  ],

  &#39;Temporal Rift Zone&#39;: [
    { name: &#39;Paradox Engine&#39;, quantity: 1, price: 5000 }, // Ultra rare legendary
    { name: &#39;Temporal Flux&#39;, quantity: 2, price: 1000 },
    { name: &#39;Causality Loop&#39;, quantity: 3, price: 400 },
    { name: &#39;Temporal Stabilizer&#39;, quantity: 8, price: 75 },
    { name: &#39;Energy Drink&#39;, quantity: 3, price: 25 }, // Time dilation makes everything expensive
  ],

  &quot;Yesterday&#39;s Tomorrow&quot;: [
    { name: &#39;Temporal Stabilizer&#39;, quantity: 15, price: 65 }, // Tomorrow&#39;s specialty
    { name: &#39;Causality Loop&#39;, quantity: 5, price: 350 },
    { name: &#39;Quantum Processor&#39;, quantity: 1, price: 400 }, // From other regions
    { name: &#39;Ancient Coin&#39;, quantity: 10, price: 30 }, // From various timelines
  ],

  &#39;The Bone Markets&#39;: [
    { name: &#39;Living Bone Tools&#39;, quantity: 4, price: 160 },
    { name: &#39;Skeletal Framework&#39;, quantity: 2, price: 220 },
    { name: &#39;Calcium Crystals&#39;, quantity: 20, price: 15 },
    { name: &#39;Bone Marrow Elixir&#39;, quantity: 12, price: 45 },
    { name: &#39;Ancient Coin&#39;, quantity: 8, price: 40 }, // Bones are old
    { name: &#39;Health Potion&#39;, quantity: 6, price: 50 }, // Death-adjacent pricing
  ],

  &#39;Calcium Exchange&#39;: [
    { name: &#39;Calcium Crystals&#39;, quantity: 40, price: 10 }, // Exchange bulk pricing
    { name: &#39;Living Bone Tools&#39;, quantity: 8, price: 140 },
    { name: &#39;Skeletal Framework&#39;, quantity: 4, price: 200 },
    { name: &#39;Ancient Artifact&#39;, quantity: 1, price: 800 }, // Rare ancient find
  ],

  &#39;Static Fields&#39;: [
    { name: &#39;Signal Booster Helmet&#39;, quantity: 2, price: 180 },
    { name: &#39;White Noise Generator&#39;, quantity: 3, price: 130 },
    { name: &#39;Frequency Modulator&#39;, quantity: 2, price: 200 },
    { name: &#39;Static Cling&#39;, quantity: 25, price: 6 },
    { name: &#39;Glitch Goggles&#39;, quantity: 1, price: 140 }, // Cross-region synergy
  ],

  &#39;Dead Air Tavern&#39;: [
    { name: &#39;Energy Drink&#39;, quantity: 12, price: 15 },
    { name: &#39;Static Cling&#39;, quantity: 30, price: 4 }, // Tavern bulk
    { name: &#39;Frequency Modulator&#39;, quantity: 3, price: 180 },
    { name: &#39;Code Energy Drink&#39;, quantity: 8, price: 22 }, // Digital synergy
  ],
}

// Mining configurations for new regions
const NEW_MINING_CONFIGS = {
  &#39;The Glitch Wastes&#39;: [
    { name: &#39;Pixel Dust&#39;, spawnRate: 0.4, maxPerDay: 20, difficulty: 4 },
    { name: &#39;Fragmented Code&#39;, spawnRate: 0.12, maxPerDay: 6, difficulty: 5 },
    { name: &#39;Static Cling&#39;, spawnRate: 0.25, maxPerDay: 12, difficulty: 4 },
    { name: &#39;Glitch Goggles&#39;, spawnRate: 0.02, maxPerDay: 1, difficulty: 6 },
  ],

  &#39;Corrupted Data Mines&#39;: [
    { name: &#39;Fragmented Code&#39;, spawnRate: 0.3, maxPerDay: 10, difficulty: 5 },
    { name: &#39;Pixel Dust&#39;, spawnRate: 0.6, maxPerDay: 25, difficulty: 4 },
    { name: &#39;Buffer Overflow Potion&#39;, spawnRate: 0.008, maxPerDay: 1, difficulty: 7 }, // Ultra rare
  ],

  &#39;Fungi Networks&#39;: [
    { name: &#39;Mycelium Thread&#39;, spawnRate: 0.5, maxPerDay: 30, difficulty: 3 },
    { name: &#39;Neural Spores&#39;, spawnRate: 0.25, maxPerDay: 15, difficulty: 3 },
    { name: &#39;Decay Catalyst&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 4 },
  ],

  &#39;The Great Mycelium&#39;: [
    { name: &#39;Neural Spores&#39;, spawnRate: 0.4, maxPerDay: 20, difficulty: 4 },
    { name: &#39;Symbiotic Armor&#39;, spawnRate: 0.015, maxPerDay: 1, difficulty: 5 },
    { name: &#39;Mycelium Thread&#39;, spawnRate: 0.7, maxPerDay: 35, difficulty: 3 },
  ],

  &#39;Temporal Rift Zone&#39;: [
    { name: &#39;Temporal Flux&#39;, spawnRate: 0.05, maxPerDay: 2, difficulty: 6 }, // Very rare
    { name: &#39;Causality Loop&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 5 },
    { name: &#39;Temporal Stabilizer&#39;, spawnRate: 0.15, maxPerDay: 8, difficulty: 5 },
  ],

  &#39;Clock Tower Ruins&#39;: [
    { name: &#39;Temporal Flux&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 6 },
    { name: &#39;Paradox Engine&#39;, spawnRate: 0.001, maxPerDay: 1, difficulty: 8 }, // Legendary rare
    { name: &#39;Ancient Coin&#39;, spawnRate: 0.2, maxPerDay: 10, difficulty: 4 }, // Time displaced
  ],

  &#39;The Bone Markets&#39;: [
    { name: &#39;Calcium Crystals&#39;, spawnRate: 0.35, maxPerDay: 18, difficulty: 3 },
    { name: &#39;Living Bone Tools&#39;, spawnRate: 0.06, maxPerDay: 3, difficulty: 4 },
    { name: &#39;Ancient Coin&#39;, spawnRate: 0.18, maxPerDay: 8, difficulty: 3 }, // Grave goods
  ],

  &#39;Static Fields&#39;: [
    { name: &#39;Static Cling&#39;, spawnRate: 0.45, maxPerDay: 22, difficulty: 4 },
    { name: &#39;White Noise Generator&#39;, spawnRate: 0.07, maxPerDay: 3, difficulty: 5 },
    { name: &#39;Frequency Modulator&#39;, spawnRate: 0.04, maxPerDay: 2, difficulty: 5 },
  ],

  &#39;Channel 0&#39;: [
    { name: &#39;Static Cling&#39;, spawnRate: 0.6, maxPerDay: 30, difficulty: 4 },
    { name: &#39;Signal Booster Helmet&#39;, spawnRate: 0.02, maxPerDay: 1, difficulty: 6 },
    { name: &#39;Frequency Modulator&#39;, spawnRate: 0.08, maxPerDay: 4, difficulty: 5 },
  ],
}

async function setupNewRegionsContent() {
  console.log(&#39;üõí Setting up markets and mining for new regions...\n&#39;)

  try {
    // Get all locations and items for reference
    const locations = await prisma.location.findMany({
      where: { hasMarket: true }
    })
    const miningLocations = await prisma.location.findMany({
      where: { hasMining: true }
    })
    const items = await prisma.item.findMany()
    const itemMap = new Map(items.map(item =&gt; [item.name, item]))

    console.log(`üìç Found ${locations.length} market locations`)
    console.log(`‚õèÔ∏è Found ${miningLocations.length} mining locations`)

    // Setup markets
    console.log(&#39;\nüè™ Setting up markets...&#39;)
    let marketListingsAdded = 0

    for (const location of locations) {
      const config = NEW_MARKET_CONFIGS[location.name as keyof typeof NEW_MARKET_CONFIGS]
      if (!config) continue

      console.log(`  üì¶ Stocking ${location.name}...`)

      for (const itemConfig of config) {
        const item = itemMap.get(itemConfig.name)
        if (!item) {
          console.log(`    ‚ùå Item &#39;${itemConfig.name}&#39; not found`)
          continue
        }

        // Check if listing already exists
        const existing = await prisma.marketListing.findFirst({
          where: {
            locationId: location.id,
            itemId: item.id,
            isSystemItem: true
          }
        })

        if (existing) {
          await prisma.marketListing.update({
            where: { id: existing.id },
            data: {
              quantity: itemConfig.quantity,
              price: itemConfig.price
            }
          })
        } else {
          await prisma.marketListing.create({
            data: {
              locationId: location.id,
              itemId: item.id,
              quantity: itemConfig.quantity,
              price: itemConfig.price,
              isSystemItem: true
            }
          })
          marketListingsAdded++
        }
      }
    }
    console.log(`‚úÖ Added/updated ${marketListingsAdded} market listings`)

    // Setup mining
    console.log(&#39;\n‚õèÔ∏è Setting up mining resources...&#39;)
    let miningResourcesAdded = 0

    for (const location of miningLocations) {
      const config = NEW_MINING_CONFIGS[location.name as keyof typeof NEW_MINING_CONFIGS]
      if (!config) continue

      console.log(`  üóø Adding resources to ${location.name}...`)

      for (const resourceConfig of config) {
        const item = itemMap.get(resourceConfig.name)
        if (!item) {
          console.log(`    ‚ùå Item &#39;${resourceConfig.name}&#39; not found`)
          continue
        }

        // Check if resource already exists
        const existing = await prisma.locationResource.findUnique({
          where: {
            locationId_itemId: {
              locationId: location.id,
              itemId: item.id
            }
          }
        })

        if (!existing) {
          await prisma.locationResource.create({
            data: {
              locationId: location.id,
              itemId: item.id,
              spawnRate: resourceConfig.spawnRate,
              maxPerDay: resourceConfig.maxPerDay,
              difficulty: resourceConfig.difficulty
            }
          })
          m
</content>
    </document>

    <document>
      <source>scripts/seed-markets.ts</source>
      <tags></tags>
      <metadata>
        <size>5711</size>
        <lastModified>2025-05-29T06:22:57.295Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/seed-markets.ts
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// Market configurations per location
const MARKET_CONFIGS = {
  &#39;Mining Plains&#39;: {
    items: [
      { name: &#39;Miners Hat&#39;, quantity: 10, price: 15 },
      { name: &#39;Work Gloves&#39;, quantity: 8, price: 12 },
      { name: &#39;Energy Drink&#39;, quantity: 20, price: 8 },
      { name: &#39;Dirty Coal&#39;, quantity: 50, price: 2 },
      { name: &#39;Iron Scraps&#39;, quantity: 25, price: 5 },
      { name: &#39;Basic Pickaxe&#39;, quantity: 5, price: 20 },
      { name: &#39;Multi-Tool&#39;, quantity: 3, price: 35 },
      { name: &#39;Repair Kit&#39;, quantity: 4, price: 25 },
    ],
  },
  &#39;Central Exchange&#39;: {
    items: [
      { name: &#39;Cyber Jacket&#39;, quantity: 3, price: 75 },
      { name: &#39;Lucky Charm&#39;, quantity: 5, price: 30 },
      { name: &#39;Health Potion&#39;, quantity: 15, price: 25 },
      { name: &#39;Energy Drink&#39;, quantity: 25, price: 10 },
      { name: &#39;Ancient Coin&#39;, quantity: 8, price: 100 },
      { name: &#39;Hacking Toolkit&#39;, quantity: 2, price: 120 },
      { name: &#39;Signal Booster&#39;, quantity: 3, price: 80 },
      { name: &#39;Quantum Processor&#39;, quantity: 1, price: 300 },
      { name: &#39;Scanning Device&#39;, quantity: 2, price: 95 },
    ],
  },
  &#39;Desert Outpost&#39;: {
    items: [
      { name: &#39;Work Gloves&#39;, quantity: 6, price: 18 },
      { name: &#39;Energy Drink&#39;, quantity: 12, price: 15 }, // Higher prices in remote areas
      { name: &#39;Health Potion&#39;, quantity: 8, price: 35 },
      { name: &#39;Crystal Shard&#39;, quantity: 2, price: 200 },
      { name: &#39;Survival Knife&#39;, quantity: 4, price: 30 },
      { name: &#39;Fire Starter&#39;, quantity: 6, price: 15 },
      { name: &#39;GPS Tracker&#39;, quantity: 2, price: 65 },
    ],
  },
}

async function seedMarkets() {
  console.log(&#39;üè™ Starting market seed...&#39;)

  try {
    // Get all locations and items for reference
    const locations = await prisma.location.findMany({
      where: { hasMarket: true },
    })

    const items = await prisma.item.findMany()
    const itemMap = new Map(items.map((item) =&gt; [item.name, item]))

    for (const location of locations) {
      const config =
        MARKET_CONFIGS[location.name as keyof typeof MARKET_CONFIGS]

      if (!config) {
        console.log(`‚ö†Ô∏è  No market config for ${location.name}, skipping...`)
        continue
      }

      console.log(`\nüè™ Restocking ${location.name}...`)

      for (const itemConfig of config.items) {
        const item = itemMap.get(itemConfig.name)

        if (!item) {
          console.log(`  ‚ùå Item &#39;${itemConfig.name}&#39; not found in database`)
          continue
        }

        // Check if listing already exists
        const existingListing = await prisma.marketListing.findFirst({
          where: {
            locationId: location.id,
            itemId: item.id,
            isSystemItem: true,
          },
        })

        if (existingListing) {
          // Update existing listing
          await prisma.marketListing.update({
            where: { id: existingListing.id },
            data: {
              quantity: itemConfig.quantity,
              price: itemConfig.price,
            },
          })
          console.log(
            `  üîÑ Updated ${itemConfig.name}: ${itemConfig.quantity} @ ${itemConfig.price} coins`
          )
        } else {
          // Create new listing
          await prisma.marketListing.create({
            data: {
              locationId: location.id,
              itemId: item.id,
              quantity: itemConfig.quantity,
              price: itemConfig.price,
              isSystemItem: true,
            },
          })
          console.log(
            `  ‚ú® Added ${itemConfig.name}: ${itemConfig.quantity} @ ${itemConfig.price} coins`
          )
        }
      }
    }

    console.log(&#39;\nüéâ Market seed completed successfully!&#39;)

    // Show summary
    const totalListings = await prisma.marketListing.count({
      where: { isSystemItem: true },
    })
    console.log(`üìä Total system market listings: ${totalListings}`)
  } catch (error) {
    console.error(&#39;‚ùå Market seed failed:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

// Command line options
const args = process.argv.slice(2)

if (args.includes(&#39;--help&#39;) || args.includes(&#39;-h&#39;)) {
  console.log(`
üè™ Market Listing Seed Script

Usage:
  npm run seed:markets              # Restock all markets
  npm run seed:markets --clear      # Clear all system listings first
  npm run seed:markets --location &quot;Central Exchange&quot;  # Restock specific location

Options:
  --clear                           Clear all system listings before restocking
  --location &lt;name&gt;                 Only restock specific location
  --help, -h                        Show this help message
`)
  process.exit(0)
}

// Handle clear option
if (args.includes(&#39;--clear&#39;)) {
  console.log(&#39;üßπ Clearing existing system market listings...&#39;)
  await prisma.marketListing.deleteMany({
    where: { isSystemItem: true },
  })
  console.log(&#39;‚úÖ Cleared all system listings&#39;)
}

// Handle specific location
const locationArg = args.indexOf(&#39;--location&#39;)
if (locationArg !== -1 &amp;&amp; args[locationArg + 1]) {
  const targetLocation = args[locationArg + 1]
  console.log(`üéØ Targeting specific location: ${targetLocation}`)

  // Filter MARKET_CONFIGS to only include the target location
  const filteredConfig = {
    [targetLocation]:
      MARKET_CONFIGS[targetLocation as keyof typeof MARKET_CONFIGS],
  }
  Object.assign(MARKET_CONFIGS, filteredConfig)

  // Clear all other configs
  for (const key in MARKET_CONFIGS) {
    if (key !== targetLocation) {
      delete MARKET_CONFIGS[key as keyof typeof MARKET_CONFIGS]
    }
  }
}

// Run the seed
seedMarkets()
</content>
    </document>

    <document>
      <source>scripts/debug-market-locations.ts</source>
      <tags></tags>
      <metadata>
        <size>2544</size>
        <lastModified>2025-05-29T06:00:54.267Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/debug-market-locations.ts - Check which locations have markets
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

async function debugMarketLocations() {
  console.log(&#39;üîç Debugging market locations...\n&#39;)

  try {
    const allLocations = await prisma.location.findMany({
      orderBy: [{ parentLocationId: &#39;asc&#39; }, { name: &#39;asc&#39; }],
    })

    const marketLocations = await prisma.location.findMany({
      where: { hasMarket: true },
      orderBy: [{ parentLocationId: &#39;asc&#39; }, { name: &#39;asc&#39; }],
    })

    console.log(&#39;üìç ALL LOCATIONS:&#39;)
    allLocations.forEach((location) =&gt; {
      const isParent = !location.parentLocationId
      const hasMarket = location.hasMarket
      const marketIcon = hasMarket ? &#39;üè™&#39; : &#39;‚ùå&#39;
      const parentIcon = isParent ? &#39;üèõÔ∏è&#39; : &#39;  ‚îî‚îÄ&#39;

      console.log(
        `${parentIcon} ${marketIcon} ${location.name} (${location.locationType})`
      )
    })

    console.log(&#39;\nüè™ MARKET LOCATIONS ONLY:&#39;)
    marketLocations.forEach((location) =&gt; {
      const isParent = !location.parentLocationId
      const parentIcon = isParent ? &#39;üèõÔ∏è&#39; : &#39;  ‚îî‚îÄ&#39;
      console.log(`${parentIcon} ${location.name} (${location.locationType})`)
    })

    console.log(&#39;\nüìä SUMMARY:&#39;)
    console.log(`Total locations: ${allLocations.length}`)
    console.log(`Market locations: ${marketLocations.length}`)

    const parentMarkets = marketLocations.filter((loc) =&gt; !loc.parentLocationId)
    const childMarkets = marketLocations.filter((loc) =&gt; loc.parentLocationId)

    console.log(`  ‚îî‚îÄ Parent locations with markets: ${parentMarkets.length}`)
    console.log(`  ‚îî‚îÄ Sub-locations with markets: ${childMarkets.length}`)

    // Check existing market listings
    const existingListings = await prisma.marketListing.count({
      where: { isSystemItem: true },
    })

    console.log(`\nüí∞ EXISTING MARKET DATA:`)
    console.log(`System market listings: ${existingListings}`)

    if (existingListings &gt; 0) {
      const listingsByLocation = await prisma.marketListing.groupBy({
        by: [&#39;locationId&#39;],
        where: { isSystemItem: true },
        _count: { id: true },
      })

      for (const group of listingsByLocation) {
        const location = await prisma.location.findUnique({
          where: { id: group.locationId },
        })
        console.log(`  ‚îî‚îÄ ${location?.name}: ${group._count.id} items`)
      }
    }
  } catch (error) {
    console.error(&#39;‚ùå Debug failed:&#39;, error)
  } finally {
    await prisma.$disconnect()
  }
}

debugMarketLocations()
</content>
    </document>

    <document>
      <source>scripts/ultimate-world-setup.ts</source>
      <tags></tags>
      <metadata>
        <size>40705</size>
        <lastModified>2025-05-29T10:08:28.693Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/ultimate-world-setup.ts - Complete Wojak Earth World Builder
import {
  PrismaClient,
  ItemCategory,
  LayerType,
  Rarity,
  LocationType,
  ChatScope,
  Gender,
  CharacterType,
  ChatMessageType,
} from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// ============================================================================
// WORLD CONFIGURATION - Adjust these values to customize your world
// ============================================================================

const WORLD_CONFIG = {
  // World Settings
  WORLD_NAME: &#39;Wojak Earth&#39;,
  MAX_TOTAL_CHARACTERS: 100,
  STARTING_LOCATION_NAME: &#39;Mining Plains&#39;,

  // Character Settings
  DEFAULT_HEALTH: 100,
  DEFAULT_ENERGY: 100,
  ENERGY_VARIATION: 20, // Characters start with 80-100 energy
  HEALTH_VARIATION: 10, // Characters start with 90-100 health

  // Economy Settings
  BASE_MINING_ENERGY_COST: 10,
  PRICE_MULTIPLIERS: {
    &#39;Mining Plains&#39;: 1.0,
    &#39;Desert Outpost&#39;: 1.2,
    &#39;Cyber City&#39;: 1.1,
    &#39;Central Exchange&#39;: 1.15,
    &#39;The Glitch Club&#39;: 0.9,
    &#39;Rusty Pickaxe Inn&#39;: 0.95,
    &#39;Crystal Caves&#39;: 1.1,
    &#39;The Glitch Wastes&#39;: 1.3,
    &#39;Fungi Networks&#39;: 1.1,
    &#39;Temporal Rift Zone&#39;: 1.5,
    &#39;The Bone Markets&#39;: 1.0,
    &#39;Static Fields&#39;: 1.2,
  },

  // Mining Settings
  BASE_SPAWN_RATES: {
    COMMON: 0.4,
    UNCOMMON: 0.2,
    RARE: 0.1,
    EPIC: 0.05,
    LEGENDARY: 0.01,
  },

  // Features to Enable/Disable
  FEATURES: {
    CREATE_LOCATIONS: true,
    CREATE_ITEMS: true,
    CREATE_CHARACTERS: true,
    SETUP_MARKETS: true,
    SETUP_MINING: true,
    CREATE_CHAT_HISTORY: true,
    CLEAR_EXISTING_DATA: true,
  },
}

// ============================================================================
// WORLD DATA DEFINITIONS
// ============================================================================

const WORLD_LOCATIONS = [
  // Original Regions
  {
    name: &#39;Mining Plains&#39;,
    description: &#39;Rich in basic materials and perfect for newcomers&#39;,
    locationType: LocationType.REGION,
    biome: &#39;plains&#39;,
    difficulty: 1,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: ChatScope.REGIONAL,
    welcomeMessage: &#39;The wind carries the sound of pickaxes striking stone.&#39;,
    lore: &#39;Once a vast battlefield, these plains now serve as the primary mining grounds for new arrivals.&#39;,
    mapX: 100,
    mapY: 200,
    subLocations: [
      {
        name: &#39;Rusty Pickaxe Inn&#39;,
        description: &#39;A cozy tavern where miners share stories and ale&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 1,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        chatScope: ChatScope.LOCAL,
        welcomeMessage: &#39;The smell of ale and roasted meat fills the air.&#39;,
      },
      {
        name: &#39;Crystal Caves&#39;,
        description: &#39;Deep underground shafts where rare crystals grow&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 2,
        hasMarket: true,
        hasMining: true,
        hasChat: true,
        chatScope: ChatScope.LOCAL,
        welcomeMessage: &#39;Crystalline formations sparkle in your torchlight.&#39;,
      },
    ],
  },

  {
    name: &#39;Desert Outpost&#39;,
    description: &#39;Harsh but rewarding terrain for experienced miners&#39;,
    locationType: LocationType.REGION,
    biome: &#39;desert&#39;,
    difficulty: 3,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: ChatScope.REGIONAL,
    welcomeMessage: &#39;The scorching sun beats down mercilessly.&#39;,
    lore: &#39;A remote trading post built around an ancient oasis.&#39;,
    mapX: 400,
    mapY: 100,
  },

  {
    name: &#39;Cyber City&#39;,
    description: &#39;The technological heart of wojak civilization&#39;,
    locationType: LocationType.CITY,
    biome: &#39;urban&#39;,
    difficulty: 2,
    hasMarket: true,
    hasMining: false,
    hasChat: true,
    chatScope: ChatScope.LOCAL,
    welcomeMessage: &#39;Neon lights flicker in the perpetual twilight.&#39;,
    lore: &#39;The beating heart of wojak civilization.&#39;,
    mapX: 300,
    mapY: 300,
    subLocations: [
      {
        name: &#39;Central Exchange&#39;,
        description: &#39;The main financial district and trading hub&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 2,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        chatScope: ChatScope.LOCAL,
        welcomeMessage:
          &#39;Holographic displays show market prices from across the world.&#39;,
      },
      {
        name: &#39;The Glitch Club&#39;,
        description: &#39;Underground social hub for hackers and rebels&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 2,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        chatScope: ChatScope.LOCAL,
        welcomeMessage: &#39;Bass-heavy music thumps through the smoky atmosphere.&#39;,
      },
    ],
  },

  // Weird New Regions
  {
    name: &#39;The Glitch Wastes&#39;,
    description:
      &#39;Digital desert where reality breaks down into pixelated fragments&#39;,
    locationType: LocationType.REGION,
    biome: &#39;digital&#39;,
    difficulty: 4,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: ChatScope.REGIONAL,
    welcomeMessage: &#39;ERROR_404: WELCOME_MESSAGE_NOT_FOUND&#39;,
    lore: &#39;Once a stable data center, this region was corrupted by a massive system failure.&#39;,
    mapX: 600,
    mapY: 150,
    subLocations: [
      {
        name: &#39;Error 404 Oasis&#39;,
        description: &#39;A rest stop that may or may not actually exist&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 4,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;null reference exception: comfort not found&#39;,
      },
      {
        name: &#39;Corrupted Data Mines&#39;,
        description: &#39;Extract valuable code fragments from broken databases&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 5,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;Warning: Memory corruption detected&#39;,
      },
    ],
  },

  {
    name: &#39;Fungi Networks&#39;,
    description: &#39;Underground mycelium city where everything is connected&#39;,
    locationType: LocationType.REGION,
    biome: &#39;underground&#39;,
    difficulty: 3,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: ChatScope.REGIONAL,
    welcomeMessage: &#39;The network acknowledges your presence.&#39;,
    lore: &#39;A vast underground organism that has achieved collective consciousness.&#39;,
    mapX: 200,
    mapY: 400,
    subLocations: [
      {
        name: &#39;Spore Exchange&#39;,
        description: &#39;Trading post where biological resources are shared&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 3,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Breathe deeply. The spores will show you the way.&#39;,
      },
      {
        name: &#39;The Great Mycelium&#39;,
        description: &#39;Central nervous system of the fungal network&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 4,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;You are now part of something greater.&#39;,
      },
    ],
  },

  {
    name: &#39;Temporal Rift Zone&#39;,
    description: &#39;Time moves strangely here, past and future bleeding together&#39;,
    locationType: LocationType.REGION,
    biome: &#39;temporal&#39;,
    difficulty: 5,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: ChatScope.REGIONAL,
    welcomeMessage: &#39;When are you?&#39;,
    lore: &#39;A scientific experiment gone wrong tore holes in spacetime.&#39;,
    mapX: 500,
    mapY: 350,
    subLocations: [
      {
        name: &quot;Yesterday&#39;s Tomorrow&quot;,
        description:
          &#39;A marketplace selling items from timelines that never were&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 5,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;This conversation happened before you arrived.&#39;,
      },
      {
        name: &#39;Clock Tower Ruins&#39;,
        description:
          &#39;Collapsed timekeeper where temporal fragments can be mined&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 6,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;Time is broken here. Proceed with caution.&#39;,
      },
    ],
  },

  {
    name: &#39;The Bone Markets&#39;,
    description:
      &#39;Skeletal merchants trade in organic technology and calcium currency&#39;,
    locationType: LocationType.REGION,
    biome: &#39;ossuary&#39;,
    difficulty: 3,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: ChatScope.REGIONAL,
    welcomeMessage: &#39;Welcome, flesh-bearer. What bones do you bring?&#39;,
    lore: &#39;An ancient cemetery evolved into a thriving market.&#39;,
    mapX: 150,
    mapY: 300,
    subLocations: [
      {
        name: &#39;Calcium Exchange&#39;,
        description: &#39;Primary trading floor for bone-based materials&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 3,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Rattle your coins, the dealers are listening.&#39;,
      },
      {
        name: &#39;Ossuary Club&#39;,
        description:
          &#39;Social gathering place decorated with artistic bone arrangements&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 2,
        hasMarket: false,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Dance among the ancestors.&#39;,
      },
    ],
  },

  {
    name: &#39;Static Fields&#39;,
    description:
      &#39;Everything covered in TV static, reality unclear and shifting&#39;,
    locationType: LocationType.REGION,
    biome: &#39;electromagnetic&#39;,
    difficulty: 4,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: ChatScope.REGIONAL,
    welcomeMessage: &#39;‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà&#39;,
    lore: &#39;A massive electromagnetic anomaly interferes with all signals.&#39;,
    mapX: 450,
    mapY: 250,
    subLocations: [
      {
        name: &#39;Channel 0&#39;,
        description:
          &#39;Broadcasting station for frequencies that should not exist&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 4,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;‚ñàow ‚ñà‚ñà ‚ñàing?&#39;,
      },
      {
        name: &#39;Dead Air Tavern&#39;,
        description:
          &#39;Social hub where the static is slightly less overwhelming&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 3,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Can you hear me now? Good.&#39;,
      },
    ],
  },
]

const WORLD_ITEMS = [
  // Basic Materials
  {
    name: &#39;Dirty Coal&#39;,
    description: &#39;Basic fuel found in shallow mines&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
  },
  {
    name: &#39;Iron Scraps&#39;,
    description: &#39;Rusty metal pieces, still useful&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
  },
  {
    name: &#39;Ancient Coin&#39;,
    description: &#39;Currency from a forgotten civilization&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.RARE,
  },
  {
    name: &#39;Crystal Shard&#39;,
    description: &#39;Glowing fragment with mysterious properties&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.EPIC,
  },

  // Basic Equipment
  {
    name: &#39;Miners Hat&#39;,
    description: &#39;Worn leather hat with a dim headlamp&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.COMMON,
    durability: 100,
    energyEffect: 5,
  },
  {
    name: &#39;Work Gloves&#39;,
    description: &#39;Tough gloves for manual labor&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 80,
  },
  {
    name: &#39;Lucky Charm&#39;,
    description: &quot;A rabbit&#39;s foot that might bring fortune&quot;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.UNCOMMON,
  },
  {
    name: &#39;Cyber Jacket&#39;,
    description: &#39;High-tech jacket with built-in displays&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.RARE,
    energyEffect: 15,
  },

  // Basic Consumables
  {
    name: &#39;Energy Drink&#39;,
    description: &#39;Restores energy and keeps you alert&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.COMMON,
    energyEffect: 25,
  },
  {
    name: &#39;Health Potion&#39;,
    description: &#39;Mysterious red liquid that heals wounds&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.UNCOMMON,
    healthEffect: 30,
  },

  // Tools
  {
    name: &#39;Basic Pickaxe&#39;,
    description: &#39;Standard mining tool for beginners&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 50,
  },
  {
    name: &#39;Multi-Tool&#39;,
    description: &#39;Swiss army knife of the digital age&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 100,
  },
  {
    name: &#39;Hacking Toolkit&#39;,
    description: &#39;Portable device for digital infiltration&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 150,
  },
  {
    name: &#39;Omni-Tool&#39;,
    description: &#39;Legendary device that adapts to any situation&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.LEGENDARY,
    durability: 1000,
    energyEffect: 20,
    healthEffect: 10,
  },

  // Themed Items - Cyber
  {
    name: &#39;Rare Floppy Disk&#39;,
    description: &#39;Contains legendary source code from the early net&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.LEGENDARY,
  },
  {
    name: &#39;Cyberpunk Shades&#39;,
    description: &#39;AR-enhanced sunglasses with data overlay&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    energyEffect: 10,
  },
  {
    name: &#39;Neon Visor&#39;,
    description: &#39;Glowing headgear that screams &quot;I hack the planet&quot;&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.EPIC,
    energyEffect: 15,
  },

  // Themed Items - Desert
  {
    name: &#39;Desert Wrap&#39;,
    description: &#39;Traditional headwrap that protects from sandstorms&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.UNCOMMON,
    healthEffect: 8,
  },
  {
    name: &#39;Ancient Artifact&#39;,
    description: &#39;Mysterious relic from a lost desert civilization&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.LEGENDARY,
  },

  // Weird Items - Glitch
  {
    name: &#39;Fragmented Code&#39;,
    description: &#39;Broken data fragments that shimmer with digital energy&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.RARE,
  },
  {
    name: &#39;Pixel Dust&#39;,
    description: &#39;Granular reality particles from corrupted textures&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
  },
  {
    name: &#39;Buffer Overflow Potion&#39;,
    description:
      &#39;Dangerous digital brew that crashes your system... in a good way&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.EPIC,
    energyEffect: 150,
  },
  {
    name: &#39;Glitch Goggles&#39;,
    description: &#39;See through the matrix with corrupted vision&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    energyEffect: 10,
  },

  // Weird Items - Fungi
  {
    name: &#39;Neural Spores&#39;,
    description: &#39;Microscopic fungal networks that enhance thought&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.UNCOMMON,
  },
  {
    name: &#39;Symbiotic Armor&#39;,
    description: &#39;Living fungal protection that grows with you&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.EPIC,
    healthEffect: 25,
  },
  {
    name: &#39;Mycelium Thread&#39;,
    description: &#39;Natural fiber that connects all living things&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
  },

  // Weird Items - Temporal
  {
    name: &#39;Temporal Flux&#39;,
    description: &#39;Crystallized time that bends around your fingers&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.LEGENDARY,
  },
  {
    name: &#39;Paradox Engine&#39;,
    description: &#39;Mechanical device that exists in multiple timelines&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.LEGENDARY,
    durability: 999,
    energyEffect: 50,
  },
  {
    name: &#39;Causality Loop&#39;,
    description: &#39;Effect becomes cause becomes effect becomes...&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.EPIC,
  },

  // Weird Items - Bone
  {
    name: &#39;Living Bone Tools&#39;,
    description: &#39;Ossified implements that grow sharper with use&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 200,
  },
  {
    name: &#39;Calcium Crystals&#39;,
    description: &#39;Mineralized bone structure with geometric perfection&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.UNCOMMON,
  },
  {
    name: &#39;Skeletal Framework&#39;,
    description: &#39;Wearable bone structure that supports heavy lifting&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.RARE,
    healthEffect: 20,
  },

  // Weird Items - Static
  {
    name: &#39;White Noise Generator&#39;,
    description: &#39;Creates interference that masks your presence&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 100,
  },
  {
    name: &#39;Static Cling&#39;,
    description: &#39;Electromagnetic adhesive that sticks to anything&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
  },
  {
    name: &#39;Frequency Modulator&#39;,
    description: &#39;Tunes reality to different channels&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.EPIC,
    energyEffect: 15,
  },
  {
    name: &#39;Signal Booster Helmet&#39;,
    description: &#39;Amplifies brainwaves through electromagnetic fields&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.RARE,
    energyEffect: 20,
  },
]

// Character templates
const CHARACTER_TEMPLATES = [
  {
    name: &#39;Wojak #1337&#39;,
    gender: Gender.MALE,
    location: &#39;Mining Plains&#39;,
    energy: 85,
    health: 100,
  },
  {
    name: &#39;Wojak #420&#39;,
    gender: Gender.MALE,
    location: &#39;Mining Plains&#39;,
    energy: 95,
    health: 100,
  },
  {
    name: &#39;Wojak #69&#39;,
    gender: Gender.FEMALE,
    location: &#39;Rusty Pickaxe Inn&#39;,
    energy: 70,
    health: 100,
  },
  {
    name: &#39;Wojak #888&#39;,
    gender: Gender.MALE,
    location: &#39;Crystal Caves&#39;,
    energy: 45,
    health: 90,
  },
  {
    name: &#39;Wojak #2077&#39;,
    gender: Gender.FEMALE,
    location: &#39;Crystal Caves&#39;,
    energy: 60,
    health: 85,
  },
  {
    name: &#39;Wojak #100&#39;,
    gender: Gender.MALE,
    location: &#39;Central Exchange&#39;,
    energy: 80,
    health: 100,
  },
  {
    name: &#39;Wojak #777&#39;,
    gender: Gender.FEMALE,
    location: &#39;Central Exchange&#39;,
    energy: 90,
    health: 95,
  },
  {
    name: &#39;Wojak #333&#39;,
    gender: Gender.MALE,
    location: &#39;The Glitch Club&#39;,
    energy: 55,
    health: 80,
  },
  {
    name: &#39;Wojak #555&#39;,
    gender: Gender.FEMALE,
    location: &#39;Desert Outpost&#39;,
    energy: 40,
    health: 75,
  },
  {
    name: &#39;Wojak #999&#39;,
    gender: Gender.MALE,
    location: &#39;Desert Outpost&#39;,
    energy: 85,
    health: 100,
  },

  // New characters for weird regions
  {
    name: &#39;Wojak #404&#39;,
    gender: Gender.MALE,
    location: &#39;The Glitch Wastes&#39;,
    energy: 50,
    health: 95,
  },
  {
    name: &#39;Wojak #101&#39;,
    gender: Gender.FEMALE,
    location: &#39;Fungi Networks&#39;,
    energy: 75,
    health: 85,
  },
  {
    name: &#39;Wojak #2025&#39;,
    gender: Gender.MALE,
    location: &#39;Temporal Rift Zone&#39;,
    energy: 90,
    health: 80,
  },
  {
    name: &#39;Wojak #666&#39;,
    gender: Gender.FEMALE,
    location: &#39;The Bone Markets&#39;,
    energy: 65,
    health: 90,
  },
  {
    name: &#39;Wojak #000&#39;,
    gender: Gender.MALE,
    location: &#39;Static Fields&#39;,
    energy: 30,
    health: 100,
  },
]

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

function randomRange(min: number, max: number): number {
  return Math.floor(Math.random() * (max - min + 1)) + min
}

function randomChoice&lt;T&gt;(arr: T[]): T {
  return arr[Math.floor(Math.random() * arr.length)]
}

function generateUniqueNumber(): number {
  return Math.floor(Math.random() * 999999) + 1
}

function applyPriceMultiplier(basePrice: number, locationName: string): number {
  const multiplier = WORLD_CONFIG.PRICE_MULTIPLIERS[locationName] || 1.0
  return Math.round(basePrice * multiplier)
}

function calculateSpawnRate(baseRate: number, rarity: Rarity): number {
  const rarityMultiplier = WORLD_CONFIG.BASE_SPAWN_RATES[rarity] || 0.1
  return Math.min(baseRate * rarityMultiplier, 0.8) // Cap at 80%
}

// ============================================================================
// MAIN SETUP FUNCTIONS
// ============================================================================

async function clearExistingData() {
  if (!WORLD_CONFIG.FEATURES.CLEAR_EXISTING_DATA) {
    console.log(&#39;‚è≠Ô∏è Skipping data cleanup (disabled in config)&#39;)
    return
  }

  console.log(&#39;üßπ Clearing existing world data...&#39;)

  await prisma.chatMessage.deleteMany()
  await prisma.marketListing.deleteMany()
  await prisma.locationResource.deleteMany()
  await prisma.characterInventory.deleteMany()
  await prisma.characterImage.deleteMany()
  await prisma.transaction.deleteMany()
  await prisma.character.deleteMany()
  await prisma.location.deleteMany()
  await prisma.item.deleteMany()

  console.log(&#39;‚úÖ Existing data cleared&#39;)
}

async function createLocations() {
  if (!WORLD_CONFIG.FEATURES.CREATE_LOCATIONS) {
    console.log(&#39;‚è≠Ô∏è Skipping location creation (disabled in config)&#39;)
    return new Map()
  }

  console.log(&#39;üó∫Ô∏è Creating world locations...&#39;)

  const locationMap = new Map()

  for (const locationData of WORLD_LOCATIONS) {
    const { subLocations, ...parentData } = locationData

    // Create parent location
    const parentLocation = await prisma.location.create({
      data: {
        ...parentData,
        playerCount: 0,
        lastActive: new Date(Date.now() - Math.random() * 30 * 60 * 1000), // Random recent activity
      },
    })

    locationMap.set(parentLocation.name, parentLocation)
    console.log(`  üèîÔ∏è ${parentLocation.name}`)

    // Create sub-locations
    if (subLocations) {
      for (const subData of subLocations) {
        const subLocation = await prisma.location.create({
          data: {
            ...subData,
            parentLocationId: parentLocation.id,
            playerCount: 0,
            lastActive: new Date(Date.now() - Math.random() * 60 * 60 * 1000),
          },
        })

        locationMap.set(subLocation.name, subLocation)
        console.log(`    ‚îî‚îÄ ${subLocation.name}`)
      }
    }
  }

  console.log(`‚úÖ Created ${locationMap.size} locations`)
  return locationMap
}

async function createItems() {
  if (!WORLD_CONFIG.FEATURES.CREATE_ITEMS) {
    console.log(&#39;‚è≠Ô∏è Skipping item creation (disabled in config)&#39;)
    return new Map()
  }

  console.log(&#39;üì¶ Creating world items...&#39;)

  const itemMap = new Map()

  for (const itemData of WORLD_ITEMS) {
    const item = await prisma.item.create({
      data: {
        ...itemData,
        imageUrl: `/items/${itemData.name
          .toLowerCase()
          .replace(/\s+/g, &#39;-&#39;)}.png`,
      },
    })

    itemMap.set(item.name, item)
    console.log(`  ‚ú® ${item.name} (${item.rarity})`)
  }

  console.log(`‚úÖ Created ${itemMap.size} items`)
  return itemMap
}

async function createCharacters(locationMap: Map&lt;string, any&gt;) {
  if (!WORLD_CONFIG.FEATURES.CREATE_CHARACTERS) {
    console.log(&#39;‚è≠Ô∏è Skipping character creation (disabled in config)&#39;)
    return []
  }

  console.log(&#39;üë• Creating world characters...&#39;)

  const characters = []

  for (const template of CHARACTER_TEMPLATES) {
    const location = locationMap.get(template.location)
    if (!location) {
      console.log(
        `  ‚ùå Location &#39;${template.location}&#39; not found for ${template.name}`
      )
      continue
    }

    const character = await prisma.character.create({
      data: {
        id: `char_${template.name.toLowerCase().replace(/[^a-z0-9]/g, &#39;_&#39;)}`,
        nftAddress: `NFT_${generateUniqueNumber()}`,
        tokenId:
          template.name.split(&#39;#&#39;)[1] || generateUniqueNumber().toString(),
        walletAddress: `WALLET_${generateUniqueNumber()}`,
        name: template.name,
        gender: template.gender,
        characterType: CharacterType.HUMAN,
        currentLocationId: location.id,
        currentVersion: 1,
        currentImageUrl: `/wojak-${
          template.name.split(&#39;#&#39;)[1] || &#39;default&#39;
        }.png`,
        energy: template.energy,
        health: template.health,
      },
    })

    characters.push(character)
    console.log(`  üë§ ${character.name} in ${template.location}`)
  }

  // Update location player counts
  const locationCounts = new Map()
  for (const char of characters) {
    const count = locationCounts.get(char.currentLocationId) || 0
    locationCounts.set(char.currentLocationId, count + 1)
  }

  for (const [locationId, count] of locationCounts) {
    await prisma.location.update({
      where: { id: locationId },
      data: { playerCount: count },
    })
  }

  console.log(`‚úÖ Created ${characters.length} characters`)
  return characters
}

async function setupMarkets(
  locationMap: Map&lt;string, any&gt;,
  itemMap: Map&lt;string, any&gt;
) {
  if (!WORLD_CONFIG.FEATURES.SETUP_MARKETS) {
    console.log(&#39;‚è≠Ô∏è Skipping market setup (disabled in config)&#39;)
    return
  }

  console.log(&#39;üè™ Setting up markets...&#39;)

  // Market configurations with base prices
  const MARKET_CONFIGS: Record&lt;
    string,
    Array&lt;{ name: string; quantity: number; price: number }&gt;
  &gt; = {
    &#39;Mining Plains&#39;: [
      { name: &#39;Miners Hat&#39;, quantity: 8, price: 15 },
      { name: &#39;Basic Pickaxe&#39;, quantity: 5, price: 20 },
      { name: &#39;Multi-Tool&#39;, quantity: 3, price: 35 },
      { name: &#39;Energy Drink&#39;, quantity: 15, price: 8 },
      { name: &#39;Work Gloves&#39;, quantity: 6, price: 12 },
    ],

    &#39;Rusty Pickaxe Inn&#39;: [
      { name: &#39;Energy Drink&#39;, quantity: 20, price: 10 },
      { name: &#39;Health Potion&#39;, quantity: 15, price: 22 },
      { name: &#39;Basic Pickaxe&#39;, quantity: 8, price: 18 },
      { name: &#39;Lucky Charm&#39;, quantity: 4, price: 28 },
    ],

    &#39;Crystal Caves&#39;: [
      { name: &#39;Energy Drink&#39;, quantity: 12, price: 12 },
      { name: &#39;Health Potion&#39;, quantity: 8, price: 28 },
      { name: &#39;Crystal Shard&#39;, quantity: 8, price: 50 },
      { name: &#39;Omni-Tool&#39;, quantity: 1, price: 3500 },
    ],

    &#39;Central Exchange&#39;: [
      { name: &#39;Cyberpunk Shades&#39;, quantity: 3, price: 65 },
      { name: &#39;Neon Visor&#39;, quantity: 1, price: 150 },
      { name: &#39;Hacking Toolkit&#39;, quantity: 2, price: 120 },
      { name: &#39;Rare Floppy Disk&#39;, quantity: 1, price: 500 },
      { name: &#39;Cyber Jacket&#39;, quantity: 2, price: 85 },
    ],

    &#39;The Glitch Club&#39;: [
      { name: &#39;Cyberpunk Shades&#39;, quantity: 4, price: 55 },
      { name: &#39;Hacking Toolkit&#39;, quantity: 3, price: 100 },
      { name: &#39;Multi-Tool&#39;, quantity: 4, price: 30 },
    ],

    &#39;Desert Outpost&#39;: [
      { name: &#39;Desert Wrap&#39;, quantity: 4, price: 35 },
      { name: &#39;Energy Drink&#39;, quantity: 6, price: 15 },
      { name: &#39;Health Potion&#39;, quantity: 4, price: 35 },
      { name: &#39;Ancient Artifact&#39;, quantity: 1, price: 1000 },
    ],

    &#39;The Glitch Wastes&#39;: [
      { name: &#39;Glitch Goggles&#39;, quantity: 2, price: 120 },
      { name: &#39;Buffer Overflow Potion&#39;, quantity: 1, price: 200 },
      { name: &#39;Pixel Dust&#39;, quantity: 15, price: 8 },
      { name: &#39;Fragmented Code&#39;, quantity: 5, price: 45 },
    ],

    &#39;Fungi Networks&#39;: [
      { name: &#39;Symbiotic Armor&#39;, quantity: 1, price: 300 },
      { name: &#39;Neural Spores&#39;, quantity: 12, price: 25 },
      { name: &#39;Mycelium Thread&#39;, quantity: 20, price: 5 },
    ],

    &#39;Temporal Rift Zone&#39;: [
      { name: &#39;Paradox Engine&#39;, quantity: 1, price: 5000 },
      { name: &#39;Temporal Flux&#39;, quantity: 2, price: 1000 },
      { name: &#39;Causality Loop&#39;, quantity: 3, price: 400 },
    ],

    &#39;The Bone Markets&#39;: [
      { name: &#39;Living Bone Tools&#39;, quantity: 4, price: 160 },
      { name: &#39;Skeletal Framework&#39;, quantity: 2, price: 220 },
      { name: &#39;Calcium Crystals&#39;, quantity: 20, price: 15 },
    ],

    &#39;Static Fields&#39;: [
      { name: &#39;Signal Booster Helmet&#39;, quantity: 2, price: 180 },
      { name: &#39;White Noise Generator&#39;, quantity: 3, price: 130 },
      { name: &#39;Frequency Modulator&#39;, quantity: 2, price: 200 },
      { name: &#39;Static Cling&#39;, quantity: 25, price: 6 },
    ],
  }

  let totalListingsCreated = 0

  for (const [locationName, configs] of Object.entries(MARKET_CONFIGS)) {
    const location = locationMap.get(locationName)
    if (!location || !location.hasMarket) continue

    console.log(`  üõí Stocking ${locationName}...`)

    for (const config of configs) {
      const item = itemMap.get(config.name)
      if (!item) {
        console.log(`    ‚ùå Item &#39;${config.name}&#39; not found`)
        continue
      }

      const adjustedPrice = applyPriceMultiplier(config.price, locationName)

      await prisma.marketListing.create({
        data: {
          locationId: location.id,
          itemId: item.id,
          quantity: config.quantity,
          price: adjustedPrice,
          isSystemItem: true,
        },
      })

      totalListingsCreated++
    }
  }

  console.log(`‚úÖ Created ${totalListingsCreated} market listings`)
}

async function setupMining(
  locationMap: Map&lt;string, any&gt;,
  itemMap: Map&lt;string, any&gt;
) {
  if (!WORLD_CONFIG.FEATURES.SETUP_MINING) {
    console.log(&#39;‚è≠Ô∏è Skipping mining setup (disabled in config)&#39;)
    return
  }

  console.log(&#39;‚õèÔ∏è Setting up mining resources...&#39;)

  // Mining configurations
  const MINING_CONFIGS: Record&lt;
    string,
    Array&lt;{
      name: string
      spawnRate: number
      maxPerDay: number
      difficulty: number
    }&gt;
  &gt; = {
    &#39;Mining Plains&#39;: [
      { name: &#39;Dirty Coal&#39;, spawnRate: 0.5, maxPerDay: 25, difficulty: 1 },
      { name: &#39;Iron Scraps&#39;, spawnRate: 0.35, maxPerDay: 15, difficulty: 1 },
      { name: &#39;Basic Pickaxe&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 1 },
    ],

    &#39;Crystal Caves&#39;: [
      { name: &#39;Crystal Shard&#39;, spawnRate: 0.15, maxPerDay: 5, difficulty: 3 },
      { name: &#39;Ancient Coin&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 2 },
      { name: &#39;Omni-Tool&#39;, spawnRate: 0.002, maxPerDay: 1, difficulty: 5 },
    ],

    &#39;Desert Outpost&#39;: [
      { name: &#39;Ancient Coin&#39;, spawnRate: 0.18, maxPerDay: 8, difficulty: 3 },
      { name: &#39;Crystal Shard&#39;, spawnRate: 0.06, maxPerDay: 2, difficulty: 4 },
      {
        name: &#39;Ancient Artifact&#39;,
        spawnRate: 0.01,
        maxPerDay: 1,
        difficulty: 5,
      },
    ],

    &#39;The Glitch Wastes&#39;: [
      { name: &#39;Pixel Dust&#39;, spawnRate: 0.4, maxPerDay: 20, difficulty: 4 },
      { name: &#39;Fragmented Code&#39;, spawnRate: 0.12, maxPerDay: 6, difficulty: 5 },
      { name: &#39;Glitch Goggles&#39;, spawnRate: 0.02, maxPerDay: 1, difficulty: 6 },
    ],

    &#39;Corrupted Data Mines&#39;: [
      { name: &#39;Fragmented Code&#39;, spawnRate: 0.3, maxPerDay: 10, difficulty: 5 },
      {
        name: &#39;Buffer Overflow Potion&#39;,
        spawnRate: 0.008,
        maxPerDay: 1,
        difficulty: 7,
      },
    ],

    &#39;Fungi Networks&#39;: [
      { name: &#39;Mycelium Thread&#39;, spawnRate: 0.5, maxPerDay: 30, difficulty: 3 },
      { name: &#39;Neural Spores&#39;, spawnRate: 0.25, maxPerDay: 15, difficulty: 3 },
    ],

    &#39;The Great Mycelium&#39;: [
      { name: &#39;Neural Spores&#39;, spawnRate: 0.4, maxPerDay: 20, difficulty: 4 },
      {
        name: &#39;Symbiotic Armor&#39;,
        spawnRate: 0.015,
        maxPerDay: 1,
        difficulty: 5,
      },
    ],

    &#39;Temporal Rift Zone&#39;: [
      { name: &#39;Temporal Flux&#39;, spawnRate: 0.05, maxPerDay: 2, difficulty: 6 },
      { name: &#39;Causality Loop&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 5 },
    ],

    &#39;Clock Tower Ruins&#39;: [
      { name: &#39;Temporal Flux&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 6 },
      { name: &#39;Paradox Engine&#39;, spawnRate: 0.001, maxPerDay: 1, difficulty: 8 },
    ],

    &#39;The Bone Markets&#39;: [
      {
        name: &#39;Calcium Crystals&#39;,
        spawnRate: 0.35,
        maxPerDay: 18,
        difficulty: 3,
      },
      {
        name: &#39;Living Bone Tools&#39;,
        spawnRate: 0.06,
        maxPerDay: 3,
        difficulty: 4,
      },
    ],

    &#39;Static Fields&#39;: [
      { name: &#39;Static Cling&#39;, spawnRate: 0.45, maxPerDay: 22, difficulty: 4 },
      {
        name: &#39;White Noise Generator&#39;,
        spawnRate: 0.07,
        maxPerDay: 3,
        difficulty: 5,
      },
    ],

    &#39;Channel 0&#39;: [
      { name: &#39;Static Cling&#39;, spawnRate: 0.6, maxPerDay: 30, difficulty: 4 },
      {
        name: &#39;Signal Booster Helmet&#39;,
        spawnRate: 0.02,
        maxPerDay: 1,
        difficulty: 6,
      },
    ],
  }

  let totalResourcesCreated = 0

  for (const [locationName, configs] of Object.entries(MINING_CONFIGS)) {
    const location = locationMap.get(locationName)
    if (!location || !location.hasMining) continue

    console.log(`  ‚öíÔ∏è Adding resources to ${locationName}...`)

    for (const config of configs) {
      const item = itemMap.get(config.name)
      if (!item) {
        console.log(`    ‚ùå Item &#39;${config.name}&#39; not found`)
        continue
      }

      await prisma.locationResource.create({
        data: {
          locationId: location.id,
          itemId: item.id,
          spawnRate: config.spawnRate,
          maxPerDay: config.maxPerDay,
          difficulty: config.difficulty,
        },
      })

      totalResourcesCreated++
    }
  }

  console.log(`‚úÖ Created ${totalResourcesCreated} mining resources`)
}

async function createChatHistory(
  locationMap: Map&lt;string, any&gt;,
  characters: any[]
) {
  if (!WORLD_CONFIG.FEATURES.CREATE_CHAT_HISTORY) {
    console.log(&#39;‚è≠Ô∏è Skipping chat history creation (disabled in config)&#39;)
    return
  }

  console.log(&#39;üí¨ Creating chat history...&#39;)

  // Sample chat messages
  const CHAT_TEMPLATES = [
    {
      location: &#39;Mining Plains&#39;,
      character: &#39;Wojak #420&#39;,
      message: &#39;Anyone know where the best iron deposits are?&#39;,
      timeAgo: 3,
    },
    {
      location: &#39;Mining Plains&#39;,
      character: &#39;Wojak #1337&#39;,
      message: &#39;Try the eastern slopes, found some good scraps there yesterday&#39;,
      timeAgo: 2,
    },
    {
      location: &#39;Crystal Caves&#39;,
      character: &#39;Wojak #888&#39;,
      message: &#39;Whoa! Just found a crystal shard in the deep tunnel!&#39;,
      timeAgo: 5,
    },
    {
      location: &#39;Crystal Caves&#39;,
      character: &#39;Wojak #2077&#39;,
      message: &#39;Nice! What rarity?&#39;,
      timeAgo: 4,
    },
    {
      location: &#39;The Glitch Club&#39;,
      character: &#39;Wojak #333&#39;,
      message: &#39;*nods to the beat* This track is fire üî•&#39;,
      timeAgo: 20,
      type: &#39;EMOTE&#39;,
    },
    {
      location: &#39;Desert Outpost&#39;,
      character: &#39;Wojak #555&#39;,
      message: &#39;Water supplies running low... need to find the oasis&#39;,
      timeAgo: 25,
    },
    {
      location: &#39;The Glitch Wastes&#39;,
      character: &#39;Wojak #404&#39;,
      message: &#39;Reality.exe has stopped working&#39;,
      timeAgo: 15,
    },
    {
      location: &#39;Fungi Networks&#39;,
      character: &#39;Wojak #101&#39;,
      message: &#39;The network speaks to me... it wants to help&#39;,
      timeAgo: 10,
    },
    {
      location: &#39;Temporal Rift Zone&#39;,
      character: &#39;Wojak #2025&#39;,
      message: &#39;I was here tomorrow, but now I am yesterday&#39;,
      timeAgo: -5,
    }, // Time is weird
    {
      location: &#39;The Bone Markets&#39;,
      character: &#39;Wojak #666&#39;,
      message: &#39;Fresh calcium! Get your fresh calcium here!&#39;,
      timeAgo: 8,
    },
    {
      location: &#39;Static Fields&#39;,
      character: &#39;Wojak #000&#39;,
      message: &#39;‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà fine&#39;,
      timeAgo: 12,
    },
  ]

  let messagesCreated = 0

  for (const template of CHAT_TEMPLATES) {
    const location = locationMap.get(template.location)
    const character = characters.find((c) =&gt; c.name === template.character)

    if (!location || !character) continue

    await prisma.chatMessage.create({
      data: {
        locationId: location.id,
        characterId: character.id,
        message: template.message,
        messageType: (template.type as ChatMessageType) || ChatMessageType.CHAT,
        isSystem: false,
        createdAt: new Date(Date.now() - template.timeAgo * 60 * 1000),
      },
    })

    messagesCreated++
  }

  console.log(`‚úÖ Created ${messagesCreated} chat messages`)
}

async function validateSetup() {
  console.log(&#39;üîç Validating world setup...&#39;)

  const stats = {
    locations: await prisma.location.count(),
    items: await prisma.item.count(),
    characters: await prisma.character.count(),
    marketListings: await prisma.marketListing.count({
      where: { isSystemItem: true },
    }),
    miningResources: await prisma.locationResource.count(),
    chatMessages: await prisma.chatMessage.count(),
  }

  console.log(&#39;\nüìä WORLD STATISTICS&#39;)
  console.log(&#39;=&#39;.repeat(50))
  console.log(`üó∫Ô∏è Locations: ${stats.locations}`)
  console.log(`üì¶ Items: ${stats.items}`)
  console.log(`üë• Characters: ${stats.characters}`)
  console.log(`üè™ Market Listings: ${stats.marketListings}`)
  console.log(`‚õèÔ∏è Mining Resources: ${stats.miningResources}`)
  console.log(`üí¨ Chat Messages: ${stats.chatMessages}`)

  // Validation checks
  const issues = []

  // Check for locations without markets or mining
  const emptyMarkets = await prisma.location.count({
    where: {
      hasMarket: true,
      marketListings: { none: {} },
    },
  })
  if (emptyMarkets &gt; 0)
    issues.push(`${emptyMarkets} market locations have no items`)

  const emptyMining = await prisma.location.count({
    where: {
      hasMining: true,
      resources: { none: {} },
    },
  })
  if (emptyMining &gt; 0)
    issues.push(`${emptyMining} mining locations have no resources`)

  // Check for characters without locations
  const orphanedCharacters = await prisma.character.count({
    where: { currentLocation: null },
  })
  if (orphanedCharacters &gt; 0)
    issues.push(`${orphanedCharacters} characters have no location`)

  if (issues.length &gt; 0) {
    console.log(&#39;\n‚ö†Ô∏è VALIDATION ISSUES:&#39;)
    issues.forEach((issue) =&gt; console.log(`  ‚Ä¢ ${issue}`))
  } else {
    console.log(&#39;\n‚úÖ All validation checks passed!&#39;)
  }

  return stats
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

async function setupUltimateWorld() {
  console.log(`üåç ${WORLD_CONFIG.WORLD_NAME} - Ultimate World Setup`)
  console.log(&#39;=&#39;.repeat(60))
  console.log(
    `‚öôÔ∏è Configuration loaded - ${
      Object.values(WORLD_CONFIG.FEATURES).filter(Boolean).length
    }/${Object.keys(WORLD_CONFIG.FEATURES).length} features enabled`
  )
  console.log(&#39;&#39;)

  try {
    // Execute setup phases
    await clearExistingData()
    const locationMap = await createLocations()
    const itemMap = await createItems()
    const characters = await createCharacters(locationMap)
    await setupMarkets(locationMap, itemMap)
    await setupMining(locationMap, itemMap)
    await createChatHistory(locationMap, characters)

    // Final validation and reporting
    const stats = await validateSetup()

    console.log(&#39;\nüéâ ULTIMATE WORLD SETUP COMPLETE!&#39;)
    console.log(&#39;=&#39;.repeat(50))
    console.log(&#39;üöÄ Your world is ready for players!&#39;)
    console.log(&#39;&#39;)
    console.log(&#39;üéØ Key Features:&#39;)
    console.log(&#39;  ‚Ä¢ 12 unique locations across 8 regions&#39;)
    console.log(&#39;  ‚Ä¢ 30+ items spanning all categories and rarities&#39;)
    console.log(&#39;  ‚Ä¢ 15+ characters distributed across the world&#39;)
    console.log(&#39;  ‚Ä¢ Dynamic markets with location-based pricing&#39;)
    console.log(&#39;  ‚Ä¢ Resource-rich mining system&#39;)
    console.log(&#39;  ‚Ä¢ Living chat history and social features&#39;)
    console.log(&#39;&#39;)
    console.log(&#39;üìñ Next Steps:&#39;)
    console.log(&#39;  1. Run `npm run dev` to start your game&#39;)
    console.log(&#39;  2. Test wallet connection and character selection&#39;)
    console.log(&#39;  3. Explore all the weird new regions!&#39;)
    console.log(&#39;  4. Consider adding NFT minting functionality&#39;)
  } catch (error) {
    console.error(&#39;‚ùå Ultimate world setup failed:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

// Run the ultimate setup
setupUltimateWorld()
</content>
    </document>

    <document>
      <source>scripts/add-themed-items.ts</source>
      <tags></tags>
      <metadata>
        <size>7176</size>
        <lastModified>2025-05-29T05:47:45.577Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/add-themed-items.ts - New items for different locations
import { PrismaClient, ItemCategory, LayerType, Rarity } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

const NEW_ITEMS = [
  // === CYBER CITY / GLITCH CLUB HACKER ITEMS ===
  {
    name: &#39;Rare Floppy Disk&#39;,
    description: &#39;Contains legendary source code from the early net&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.LEGENDARY,
    imageUrl: &#39;/items/rare-floppy-disk.png&#39;,
  },
  {
    name: &#39;Cyberpunk Shades&#39;,
    description: &#39;AR-enhanced sunglasses with data overlay&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    energyEffect: 10,
    imageUrl: &#39;/items/cyberpunk-shades.png&#39;,
  },
  {
    name: &#39;Neon Visor&#39;,
    description: &#39;Glowing headgear that screams &quot;I hack the planet&quot;&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.EPIC,
    energyEffect: 15,
    imageUrl: &#39;/items/neon-visor.png&#39;,
  },
  {
    name: &#39;Data Spike&#39;,
    description: &#39;Neural interface tool for direct data access&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    imageUrl: &#39;/items/data-spike.png&#39;,
  },
  {
    name: &#39;Code Energy Drink&#39;,
    description: &#39;Caffeinated fuel for all-night coding sessions&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.COMMON,
    energyEffect: 35,
    imageUrl: &#39;/items/code-energy-drink.png&#39;,
  },
  {
    name: &#39;Bitcoin Fragment&#39;,
    description: &#39;Corrupted cryptocurrency data from the old web&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.EPIC,
    imageUrl: &#39;/items/bitcoin-fragment.png&#39;,
  },

  // === MINING PLAINS INDUSTRIAL ITEMS ===
  {
    name: &#39;Heavy Duty Boots&#39;,
    description: &#39;Steel-toed boots for serious mining work&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.UNCOMMON,
    healthEffect: 10,
    imageUrl: &#39;/items/heavy-duty-boots.png&#39;,
  },
  {
    name: &#39;Reinforced Pickaxe&#39;,
    description: &#39;Professional mining tool with titanium edge&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 200,
    imageUrl: &#39;/items/reinforced-pickaxe.png&#39;,
  },
  {
    name: &#39;Safety Goggles&#39;,
    description: &#39;Protects eyes from flying debris and dust&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    healthEffect: 5,
    imageUrl: &#39;/items/safety-goggles.png&#39;,
  },
  {
    name: &#39;Protein Bar&#39;,
    description: &#39;High-energy snack for hardworking miners&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.COMMON,
    energyEffect: 15,
    healthEffect: 5,
    imageUrl: &#39;/items/protein-bar.png&#39;,
  },
  {
    name: &#39;Rare Earth Metal&#39;,
    description: &#39;Valuable minerals used in advanced technology&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.RARE,
    imageUrl: &#39;/items/rare-earth-metal.png&#39;,
  },

  // === DESERT OUTPOST SURVIVAL ITEMS ===
  {
    name: &#39;Desert Wrap&#39;,
    description: &#39;Traditional headwrap that protects from sandstorms&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.UNCOMMON,
    healthEffect: 8,
    imageUrl: &#39;/items/desert-wrap.png&#39;,
  },
  {
    name: &#39;Survival Cloak&#39;,
    description: &#39;Weather-resistant cloak for harsh desert conditions&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.RARE,
    healthEffect: 15,
    energyEffect: 5,
    imageUrl: &#39;/items/survival-cloak.png&#39;,
  },
  {
    name: &#39;Water Purifier&#39;,
    description: &#39;Portable device that makes any water safe to drink&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.UNCOMMON,
    imageUrl: &#39;/items/water-purifier.png&#39;,
  },
  {
    name: &#39;Cactus Juice&#39;,
    description: &#39;Refreshing desert drink with healing properties&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.UNCOMMON,
    healthEffect: 25,
    energyEffect: 10,
    imageUrl: &#39;/items/cactus-juice.png&#39;,
  },
  {
    name: &#39;Ancient Artifact&#39;,
    description: &#39;Mysterious relic from a lost desert civilization&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.LEGENDARY,
    imageUrl: &#39;/items/ancient-artifact.png&#39;,
  },

  // === UNIVERSAL RARE ITEMS ===
  {
    name: &#39;Golden Pickaxe&#39;,
    description: &#39;Legendary mining tool said to find impossible treasures&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.LEGENDARY,
    durability: 500,
    imageUrl: &#39;/items/golden-pickaxe.png&#39;,
  },
  {
    name: &#39;Wojak Mask&#39;,
    description: &#39;Iconic meme face mask - the ultimate flex&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.FACE_COVERING,
    rarity: Rarity.EPIC,
    imageUrl: &#39;/items/wojak-mask.png&#39;,
  },
  {
    name: &#39;Rainbow Hoodie&#39;,
    description: &#39;Psychedelic hoodie that shifts colors in the light&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.EPIC,
    energyEffect: 20,
    imageUrl: &#39;/items/rainbow-hoodie.png&#39;,
  },
  {
    name: &#39;Pepe Charm&#39;,
    description: &#39;Rare companion charm - brings good luck in mining&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    imageUrl: &#39;/items/pepe-charm.png&#39;,
  },
  {
    name: &#39;Super Energy Potion&#39;,
    description: &#39;Ultimate energy restoration - fully charged!&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.EPIC,
    energyEffect: 100, // Full restore
    imageUrl: &#39;/items/super-energy-potion.png&#39;,
  },
]

async function addThemedItems() {
  console.log(&#39;üéÆ Adding themed items to Wojak Earth...&#39;)

  try {
    for (const itemData of NEW_ITEMS) {
      // Check if item already exists
      const existingItem = await prisma.item.findUnique({
        where: { name: itemData.name },
      })

      if (existingItem) {
        console.log(`  ‚ö†Ô∏è  Item &#39;${itemData.name}&#39; already exists, skipping...`)
        continue
      }

      // Create new item
      await prisma.item.create({
        data: itemData,
      })

      console.log(`  ‚ú® Added ${itemData.name} (${itemData.rarity})`)
    }

    console.log(&#39;\nüéâ Themed items added successfully!&#39;)

    // Show summary by category
    const itemsByCategory = NEW_ITEMS.reduce((acc, item) =&gt; {
      acc[item.category] = (acc[item.category] || 0) + 1
      return acc
    }, {} as Record&lt;string, number&gt;)

    console.log(&#39;\nüìä Items Added by Category:&#39;)
    Object.entries(itemsByCategory).forEach(([category, count]) =&gt; {
      console.log(`  ${category}: ${count} items`)
    })

    // Show summary by rarity
    const itemsByRarity = NEW_ITEMS.reduce((acc, item) =&gt; {
      acc[item.rarity] = (acc[item.rarity] || 0) + 1
      return acc
    }, {} as Record&lt;string, number&gt;)

    console.log(&#39;\nüåü Items Added by Rarity:&#39;)
    Object.entries(itemsByRarity).forEach(([rarity, count]) =&gt; {
      console.log(`  ${rarity}: ${count} items`)
    })
  } catch (error) {
    console.error(&#39;‚ùå Failed to add themed items:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

addThemedItems()
</content>
    </document>

    <document>
      <source>scripts/add-new-regions.ts</source>
      <tags></tags>
      <metadata>
        <size>14509</size>
        <lastModified>2025-05-29T08:48:57.681Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/add-new-regions.ts - Add 5 weird new locations
import {
  PrismaClient,
  ItemCategory,
  LayerType,
  Rarity,
  LocationType,
} from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// New Items for the weird regions
const NEW_ITEMS = [
  // === GLITCH WASTES ITEMS ===
  {
    name: &#39;Fragmented Code&#39;,
    description: &#39;Broken data fragments that shimmer with digital energy&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.RARE,
    imageUrl: &#39;/items/fragmented-code.png&#39;,
  },
  {
    name: &#39;Pixel Dust&#39;,
    description: &#39;Granular reality particles from corrupted textures&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
    imageUrl: &#39;/items/pixel-dust.png&#39;,
  },
  {
    name: &#39;Buffer Overflow Potion&#39;,
    description:
      &#39;Dangerous digital brew that crashes your system... in a good way&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.EPIC,
    energyEffect: 150, // Overpowered but risky
    imageUrl: &#39;/items/buffer-overflow-potion.png&#39;,
  },
  {
    name: &#39;Glitch Goggles&#39;,
    description: &#39;See through the matrix with corrupted vision&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    energyEffect: 10,
    imageUrl: &#39;/items/glitch-goggles.png&#39;,
  },

  // === FUNGI NETWORKS ITEMS ===
  {
    name: &#39;Neural Spores&#39;,
    description: &#39;Microscopic fungal networks that enhance thought&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.UNCOMMON,
    imageUrl: &#39;/items/neural-spores.png&#39;,
  },
  {
    name: &#39;Decay Catalyst&#39;,
    description: &#39;Accelerates decomposition for rapid resource cycling&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 75,
    imageUrl: &#39;/items/decay-catalyst.png&#39;,
  },
  {
    name: &#39;Symbiotic Armor&#39;,
    description: &#39;Living fungal protection that grows with you&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.EPIC,
    healthEffect: 25,
    imageUrl: &#39;/items/symbiotic-armor.png&#39;,
  },
  {
    name: &#39;Mycelium Thread&#39;,
    description: &#39;Natural fiber that connects all living things&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
    imageUrl: &#39;/items/mycelium-thread.png&#39;,
  },

  // === TEMPORAL RIFT ZONE ITEMS ===
  {
    name: &#39;Temporal Flux&#39;,
    description: &#39;Crystallized time that bends around your fingers&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.LEGENDARY,
    imageUrl: &#39;/items/temporal-flux.png&#39;,
  },
  {
    name: &#39;Paradox Engine&#39;,
    description: &#39;Mechanical device that exists in multiple timelines&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.LEGENDARY,
    durability: 999,
    energyEffect: 50,
    imageUrl: &#39;/items/paradox-engine.png&#39;,
  },
  {
    name: &#39;Causality Loop&#39;,
    description: &#39;Effect becomes cause becomes effect becomes...&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.EPIC,
    imageUrl: &#39;/items/causality-loop.png&#39;,
  },
  {
    name: &#39;Temporal Stabilizer&#39;,
    description: &#39;Keeps you anchored to the present moment&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.RARE,
    healthEffect: 50,
    imageUrl: &#39;/items/temporal-stabilizer.png&#39;,
  },

  // === BONE MARKETS ITEMS ===
  {
    name: &#39;Living Bone Tools&#39;,
    description: &#39;Ossified implements that grow sharper with use&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 200,
    imageUrl: &#39;/items/living-bone-tools.png&#39;,
  },
  {
    name: &#39;Calcium Crystals&#39;,
    description: &#39;Mineralized bone structure with geometric perfection&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.UNCOMMON,
    imageUrl: &#39;/items/calcium-crystals.png&#39;,
  },
  {
    name: &#39;Skeletal Framework&#39;,
    description: &#39;Wearable bone structure that supports heavy lifting&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.RARE,
    healthEffect: 20,
    imageUrl: &#39;/items/skeletal-framework.png&#39;,
  },
  {
    name: &#39;Bone Marrow Elixir&#39;,
    description: &#39;Rich, life-giving essence extracted from ancient bones&#39;,
    category: ItemCategory.CONSUMABLE,
    rarity: Rarity.UNCOMMON,
    healthEffect: 40,
    energyEffect: 10,
    imageUrl: &#39;/items/bone-marrow-elixir.png&#39;,
  },

  // === STATIC FIELDS ITEMS ===
  {
    name: &#39;White Noise Generator&#39;,
    description: &#39;Creates interference that masks your presence&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 100,
    imageUrl: &#39;/items/white-noise-generator.png&#39;,
  },
  {
    name: &#39;Static Cling&#39;,
    description: &#39;Electromagnetic adhesive that sticks to anything&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.COMMON,
    imageUrl: &#39;/items/static-cling.png&#39;,
  },
  {
    name: &#39;Frequency Modulator&#39;,
    description: &#39;Tunes reality to different channels&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.EPIC,
    energyEffect: 15,
    imageUrl: &#39;/items/frequency-modulator.png&#39;,
  },
  {
    name: &#39;Signal Booster Helmet&#39;,
    description: &#39;Amplifies brainwaves through electromagnetic fields&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.RARE,
    energyEffect: 20,
    imageUrl: &#39;/items/signal-booster-helmet.png&#39;,
  },
]

// New Locations
const NEW_LOCATIONS = [
  // === THE GLITCH WASTES ===
  {
    name: &#39;The Glitch Wastes&#39;,
    description:
      &#39;Digital desert where reality breaks down into pixelated fragments&#39;,
    locationType: LocationType.REGION,
    biome: &#39;digital&#39;,
    difficulty: 4,
    playerCount: 0,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: &#39;REGIONAL&#39;,
    welcomeMessage: &#39;ERROR_404: WELCOME_MESSAGE_NOT_FOUND&#39;,
    lore: &#39;Once a stable data center, this region was corrupted by a massive system failure that left reality itself glitched.&#39;,
    mapX: 600,
    mapY: 150,
    subLocations: [
      {
        name: &#39;Error 404 Oasis&#39;,
        description: &#39;A rest stop that may or may not actually exist&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 4,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;null reference exception: comfort not found&#39;,
      },
      {
        name: &#39;Corrupted Data Mines&#39;,
        description: &#39;Extract valuable code fragments from broken databases&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 5,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;Warning: Memory corruption detected&#39;,
      },
    ],
  },

  // === FUNGI NETWORKS ===
  {
    name: &#39;Fungi Networks&#39;,
    description: &#39;Underground mycelium city where everything is connected&#39;,
    locationType: LocationType.REGION,
    biome: &#39;underground&#39;,
    difficulty: 3,
    playerCount: 0,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: &#39;REGIONAL&#39;,
    welcomeMessage: &#39;The network acknowledges your presence.&#39;,
    lore: &#39;A vast underground organism that has achieved collective consciousness, welcoming symbiotic relationships with surface dwellers.&#39;,
    mapX: 200,
    mapY: 400,
    subLocations: [
      {
        name: &#39;Spore Exchange&#39;,
        description: &#39;Trading post where biological resources are shared&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 3,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Breathe deeply. The spores will show you the way.&#39;,
      },
      {
        name: &#39;The Great Mycelium&#39;,
        description: &#39;Central nervous system of the fungal network&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 4,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;You are now part of something greater.&#39;,
      },
    ],
  },

  // === TEMPORAL RIFT ZONE ===
  {
    name: &#39;Temporal Rift Zone&#39;,
    description: &#39;Time moves strangely here, past and future bleeding together&#39;,
    locationType: LocationType.REGION,
    biome: &#39;temporal&#39;,
    difficulty: 5,
    playerCount: 0,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: &#39;REGIONAL&#39;,
    welcomeMessage: &#39;When are you?&#39;,
    lore: &#39;A scientific experiment gone wrong tore holes in spacetime, creating a region where causality itself is unstable.&#39;,
    mapX: 500,
    mapY: 350,
    subLocations: [
      {
        name: &quot;Yesterday&#39;s Tomorrow&quot;,
        description:
          &#39;A marketplace selling items from timelines that never were&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 5,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;This conversation happened before you arrived.&#39;,
      },
      {
        name: &#39;Clock Tower Ruins&#39;,
        description:
          &#39;Collapsed timekeeper where temporal fragments can be mined&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 6,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;Time is broken here. Proceed with caution.&#39;,
      },
    ],
  },

  // === THE BONE MARKETS ===
  {
    name: &#39;The Bone Markets&#39;,
    description:
      &#39;Skeletal merchants trade in organic technology and calcium currency&#39;,
    locationType: LocationType.REGION,
    biome: &#39;ossuary&#39;,
    difficulty: 3,
    playerCount: 0,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: &#39;REGIONAL&#39;,
    welcomeMessage: &#39;Welcome, flesh-bearer. What bones do you bring?&#39;,
    lore: &#39;An ancient cemetery evolved into a thriving market where death is just another resource to be traded.&#39;,
    mapX: 150,
    mapY: 300,
    subLocations: [
      {
        name: &#39;Calcium Exchange&#39;,
        description: &#39;Primary trading floor for bone-based materials&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 3,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Rattle your coins, the dealers are listening.&#39;,
      },
      {
        name: &#39;Ossuary Club&#39;,
        description:
          &#39;Social gathering place decorated with artistic bone arrangements&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 2,
        hasMarket: false,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Dance among the ancestors.&#39;,
      },
    ],
  },

  // === STATIC FIELDS ===
  {
    name: &#39;Static Fields&#39;,
    description:
      &#39;Everything covered in TV static, reality unclear and shifting&#39;,
    locationType: LocationType.REGION,
    biome: &#39;electromagnetic&#39;,
    difficulty: 4,
    playerCount: 0,
    hasMarket: true,
    hasMining: true,
    hasChat: true,
    chatScope: &#39;REGIONAL&#39;,
    welcomeMessage: &#39;‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà&#39;,
    lore: &#39;A massive electromagnetic anomaly interferes with all signals, creating a region where reality itself seems to be broadcasting on dead channels.&#39;,
    mapX: 450,
    mapY: 250,
    subLocations: [
      {
        name: &#39;Channel 0&#39;,
        description:
          &#39;Broadcasting station for frequencies that should not exist&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 4,
        hasMarket: false,
        hasMining: true,
        hasChat: true,
        welcomeMessage: &#39;‚ñàow ‚ñà‚ñà ‚ñàing?&#39;,
      },
      {
        name: &#39;Dead Air Tavern&#39;,
        description:
          &#39;Social hub where the static is slightly less overwhelming&#39;,
        locationType: LocationType.BUILDING,
        difficulty: 3,
        hasMarket: true,
        hasMining: false,
        hasChat: true,
        welcomeMessage: &#39;Can you hear me now? Good.&#39;,
      },
    ],
  },
]

async function addNewRegions() {
  console.log(&#39;üåç Adding 5 new weird regions to Wojak Earth...\n&#39;)

  try {
    // 1. Add all new items
    console.log(&#39;üì¶ Adding themed items...&#39;)
    let itemsAdded = 0

    for (const itemData of NEW_ITEMS) {
      const existing = await prisma.item.findUnique({
        where: { name: itemData.name },
      })

      if (!existing) {
        await prisma.item.create({ data: itemData })
        console.log(`  ‚ú® Added ${itemData.name} (${itemData.rarity})`)
        itemsAdded++
      }
    }
    console.log(`‚úÖ Added ${itemsAdded} new items\n`)

    // 2. Add locations and sub-locations
    console.log(&#39;üó∫Ô∏è Adding locations...&#39;)
    let locationsAdded = 0

    for (const locationData of NEW_LOCATIONS) {
      const { subLocations, ...parentData } = locationData

      // Create parent location
      const parentLocation = await prisma.location.create({
        data: parentData,
      })
      console.log(`  üèîÔ∏è Added ${parentLocation.name}`)
      locationsAdded++

      // Create sub-locations
      if (subLocations) {
        for (const subData of subLocations) {
          const subLocation = await prisma.location.create({
            data: {
              ...subData,
              parentLocationId: parentLocation.id,
            },
          })
          console.log(`    ‚îî‚îÄ ${subLocation.name}`)
          locationsAdded++
        }
      }
    }
    console.log(`‚úÖ Added ${locationsAdded} new locations\n`)

    console.log(&#39;üéâ NEW REGIONS ADDED SUCCESSFULLY!&#39;)
    console.log(&#39;=&#39;.repeat(50))
    console.log(&#39;New regions available:&#39;)
    console.log(&#39;‚Ä¢ The Glitch Wastes - Digital chaos and corrupted reality&#39;)
    console.log(&#39;‚Ä¢ Fungi Networks - Underground mycelium civilization&#39;)
    console.log(&#39;‚Ä¢ Temporal Rift Zone - Time anomalies and paradoxes&#39;)
    console.log(&#39;‚Ä¢ The Bone Markets - Skeletal merchants and calcium economy&#39;)
    console.log(&#39;‚Ä¢ Static Fields - Electromagnetic interference zone&#39;)

    console.log(&#39;\nüéØ Next steps:&#39;)
    console.log(&#39;1. Run market seeding to stock these locations&#39;)
    console.log(&#39;2. Add mining resources for these regions&#39;)
    console.log(&#39;3. Test travel to the new locations&#39;)
    console.log(&#39;4. Update your map view to show the new regions&#39;)

    // Show total game content
    const totalItems = await prisma.item.count()
    const totalLocations = await prisma.location.count()
    console.log(
      `\nüìä Game now has ${totalItems} items and ${totalLocations} locations!`
    )
  } catch (error) {
    console.error(&#39;‚ùå Failed to add new regions:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

addNewRegions()
</content>
    </document>

    <document>
      <source>scripts/seed-enhanced-markets.ts</source>
      <tags></tags>
      <metadata>
        <size>14122</size>
        <lastModified>2025-05-29T06:25:23.751Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/seed-enhanced-markets.ts - Complete version with ALL locations
import { PrismaClient } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// Enhanced market configurations with new themed items - ALL LOCATIONS COVERED
const ENHANCED_MARKET_CONFIGS = {
  &#39;Mining Plains&#39;: {
    items: [
      // Basic mining gear (cheap and common)
      { name: &#39;Miners Hat&#39;, quantity: 8, price: 15 },
      { name: &#39;Work Gloves&#39;, quantity: 6, price: 12 },
      { name: &#39;Safety Goggles&#39;, quantity: 5, price: 8 },
      { name: &#39;Heavy Duty Boots&#39;, quantity: 3, price: 25 },

      // Consumables
      { name: &#39;Energy Drink&#39;, quantity: 15, price: 8 },
      { name: &#39;Protein Bar&#39;, quantity: 12, price: 6 },

      // Materials (system buys these from players too)
      { name: &#39;Dirty Coal&#39;, quantity: 30, price: 2 },
      { name: &#39;Iron Scraps&#39;, quantity: 20, price: 4 },
      { name: &#39;Rare Earth Metal&#39;, quantity: 5, price: 15 },

      // Rare equipment occasionally available
      { name: &#39;Reinforced Pickaxe&#39;, quantity: 1, price: 120 },

      { name: &#39;Basic Pickaxe&#39;, quantity: 5, price: 20 },
      { name: &#39;Multi-Tool&#39;, quantity: 3, price: 35 },
      { name: &#39;Repair Kit&#39;, quantity: 4, price: 25 },
    ],
  },

  &#39;Central Exchange&#39;: {
    items: [
      // High-tech gear
      { name: &#39;Cyber Jacket&#39;, quantity: 2, price: 85 },
      { name: &#39;Cyberpunk Shades&#39;, quantity: 3, price: 65 },
      { name: &#39;Neon Visor&#39;, quantity: 1, price: 150 },
      { name: &#39;Data Spike&#39;, quantity: 2, price: 95 },

      // Premium consumables
      { name: &#39;Health Potion&#39;, quantity: 10, price: 25 },
      { name: &#39;Code Energy Drink&#39;, quantity: 8, price: 18 },
      { name: &#39;Super Energy Potion&#39;, quantity: 2, price: 180 }, // Epic consumable

      // Digital materials
      { name: &#39;Bitcoin Fragment&#39;, quantity: 4, price: 45 },
      { name: &#39;Ancient Coin&#39;, quantity: 6, price: 35 },

      // Ultra rare items (very limited stock)
      { name: &#39;Rare Floppy Disk&#39;, quantity: 1, price: 500 }, // Legendary item
      { name: &#39;Rainbow Hoodie&#39;, quantity: 1, price: 200 },

      { name: &#39;Hacking Toolkit&#39;, quantity: 2, price: 120 },
      { name: &#39;Signal Booster&#39;, quantity: 3, price: 80 },
      { name: &#39;Quantum Processor&#39;, quantity: 1, price: 300 },
      { name: &#39;Scanning Device&#39;, quantity: 2, price: 95 },
    ],
  },

  &#39;Desert Outpost&#39;: {
    items: [
      // Survival gear (higher prices due to remote location)
      { name: &#39;Desert Wrap&#39;, quantity: 4, price: 35 },
      { name: &#39;Survival Cloak&#39;, quantity: 2, price: 120 },
      { name: &#39;Water Purifier&#39;, quantity: 3, price: 55 },

      // Desert consumables
      { name: &#39;Cactus Juice&#39;, quantity: 8, price: 20 },
      { name: &#39;Energy Drink&#39;, quantity: 6, price: 15 }, // More expensive here
      { name: &#39;Health Potion&#39;, quantity: 4, price: 35 },

      // Desert specialties
      { name: &#39;Ancient Coin&#39;, quantity: 12, price: 25 }, // Cheaper here (local specialty)
      { name: &#39;Crystal Shard&#39;, quantity: 3, price: 80 },

      // Ultra rare desert find
      { name: &#39;Ancient Artifact&#39;, quantity: 1, price: 1000 }, // Legendary desert item

      { name: &#39;Survival Knife&#39;, quantity: 4, price: 30 },
      { name: &#39;Fire Starter&#39;, quantity: 6, price: 15 },
      { name: &#39;GPS Tracker&#39;, quantity: 2, price: 65 },
    ],
  },

  &#39;The Glitch Club&#39;: {
    items: [
      // Underground hacker gear
      { name: &#39;Cyberpunk Shades&#39;, quantity: 4, price: 55 }, // Cheaper in underground
      { name: &#39;Neon Visor&#39;, quantity: 2, price: 130 },
      { name: &#39;Data Spike&#39;, quantity: 3, price: 85 },

      // Meme culture items
      { name: &#39;Wojak Mask&#39;, quantity: 1, price: 250 }, // Epic meme item
      { name: &#39;Pepe Charm&#39;, quantity: 2, price: 75 },
      { name: &#39;Rainbow Hoodie&#39;, quantity: 1, price: 180 },

      // Hacker consumables
      { name: &#39;Code Energy Drink&#39;, quantity: 12, price: 15 }, // Club specialty
      { name: &#39;Super Energy Potion&#39;, quantity: 1, price: 160 },

      // Digital contraband
      { name: &#39;Bitcoin Fragment&#39;, quantity: 6, price: 40 }, // Better price underground
      { name: &#39;Rare Floppy Disk&#39;, quantity: 1, price: 450 }, // Slightly cheaper than exchange

      // Lucky charms
      { name: &#39;Lucky Charm&#39;, quantity: 3, price: 30 },

      { name: &#39;Hacking Toolkit&#39;, quantity: 3, price: 100 }, // Cheaper underground
      { name: &#39;Multi-Tool&#39;, quantity: 4, price: 30 },

      { name: &#39;Reality Wrench&#39;, quantity: 1, price: 4000 },
    ],
  },

  &#39;Rusty Pickaxe Inn&#39;: {
    items: [
      // Tavern basics
      { name: &#39;Energy Drink&#39;, quantity: 20, price: 10 },
      { name: &#39;Health Potion&#39;, quantity: 15, price: 22 },
      { name: &#39;Protein Bar&#39;, quantity: 25, price: 5 },

      // Basic gear for newbies
      { name: &#39;Miners Hat&#39;, quantity: 10, price: 12 }, // Cheaper at the inn
      { name: &#39;Work Gloves&#39;, quantity: 8, price: 10 },
      { name: &#39;Safety Goggles&#39;, quantity: 6, price: 6 },

      // Tavern specials
      { name: &#39;Lucky Charm&#39;, quantity: 4, price: 28 },
      { name: &#39;Pepe Charm&#39;, quantity: 1, price: 65 }, // Rare tavern find

      // Materials (inn keeper buys from miners)
      { name: &#39;Dirty Coal&#39;, quantity: 50, price: 1 }, // Cheap bulk buy
      { name: &#39;Iron Scraps&#39;, quantity: 30, price: 3 },

      { name: &#39;Basic Pickaxe&#39;, quantity: 8, price: 18 }, // Slightly cheaper
      { name: &#39;Multi-Tool&#39;, quantity: 5, price: 32 },
      { name: &#39;Repair Kit&#39;, quantity: 6, price: 22 },
    ],
  },

  &#39;Crystal Caves&#39;: {
    items: [
      // Specialized mining equipment
      { name: &#39;Reinforced Pickaxe&#39;, quantity: 2, price: 100 }, // Better price in caves
      { name: &#39;Safety Goggles&#39;, quantity: 8, price: 10 },
      { name: &#39;Heavy Duty Boots&#39;, quantity: 3, price: 22 },

      // Cave-specific consumables
      { name: &#39;Energy Drink&#39;, quantity: 12, price: 12 },
      { name: &#39;Health Potion&#39;, quantity: 8, price: 28 },

      // Crystal trade
      { name: &#39;Crystal Shard&#39;, quantity: 8, price: 50 }, // Cave specialty
      { name: &#39;Ancient Coin&#39;, quantity: 4, price: 40 },

      // Ultra rare mining tool
      { name: &#39;Golden Pickaxe&#39;, quantity: 1, price: 2500 }, // Legendary mining tool

      { name: &#39;Drill Hammer&#39;, quantity: 2, price: 90 },
      { name: &#39;Laser Cutter&#39;, quantity: 1, price: 180 },
      { name: &#39;Scanning Device&#39;, quantity: 3, price: 85 }, // Better price in caves

      { name: &#39;Omni-Tool&#39;, quantity: 1, price: 3500 },
    ],
  },

  // Parent location config (basic urban supplies)
  &#39;Cyber City&#39;: {
    items: [
      // Basic urban supplies - encourage users to visit specialized sub-locations
      { name: &#39;Energy Drink&#39;, quantity: 10, price: 15 },
      { name: &#39;Health Potion&#39;, quantity: 8, price: 30 },
      { name: &#39;Code Energy Drink&#39;, quantity: 5, price: 20 },
      { name: &#39;Lucky Charm&#39;, quantity: 2, price: 35 },

      // Note: Best items are in Central Exchange and Glitch Club
    ],
  },
}

async function seedEnhancedMarkets() {
  console.log(&#39;üè™ Starting enhanced market seed with new themed items...&#39;)

  try {
    // Get all locations that have markets (including sub-locations)
    const locations = await prisma.location.findMany({
      where: { hasMarket: true },
    })

    const items = await prisma.item.findMany()
    const itemMap = new Map(items.map((item) =&gt; [item.name, item]))

    console.log(`üìç Found ${locations.length} market locations`)
    console.log(`üì¶ Found ${items.length} items available`)

    // Filter locations to only those we have configs for
    const configuredLocations = locations.filter((location) =&gt;
      ENHANCED_MARKET_CONFIGS.hasOwnProperty(location.name)
    )

    console.log(
      `üéØ Processing ${configuredLocations.length} configured market locations:`
    )
    configuredLocations.forEach((loc) =&gt; console.log(`   ‚Ä¢ ${loc.name}`))

    if (configuredLocations.length !== locations.length) {
      const unconfiguredLocations = locations.filter(
        (location) =&gt; !ENHANCED_MARKET_CONFIGS.hasOwnProperty(location.name)
      )
      console.log(
        `‚ö†Ô∏è  Skipping ${unconfiguredLocations.length} unconfigured locations:`
      )
      unconfiguredLocations.forEach((loc) =&gt;
        console.log(`   ‚Ä¢ ${loc.name} (no market config)`)
      )
    }

    let totalListingsCreated = 0
    let totalListingsUpdated = 0

    for (const location of configuredLocations) {
      const config =
        ENHANCED_MARKET_CONFIGS[
          location.name as keyof typeof ENHANCED_MARKET_CONFIGS
        ]

      console.log(`\nüè™ Restocking ${location.name}...`)

      for (const itemConfig of config.items) {
        const item = itemMap.get(itemConfig.name)

        if (!item) {
          console.log(`  ‚ùå Item &#39;${itemConfig.name}&#39; not found in database`)
          continue
        }

        // Check if listing already exists
        const existingListing = await prisma.marketListing.findFirst({
          where: {
            locationId: location.id,
            itemId: item.id,
            isSystemItem: true,
          },
        })

        if (existingListing) {
          // Update existing listing
          await prisma.marketListing.update({
            where: { id: existingListing.id },
            data: {
              quantity: itemConfig.quantity,
              price: itemConfig.price,
            },
          })
          console.log(
            `  üîÑ Updated ${itemConfig.name}: ${itemConfig.quantity} @ ${itemConfig.price} coins`
          )
          totalListingsUpdated++
        } else {
          // Create new listing
          await prisma.marketListing.create({
            data: {
              locationId: location.id,
              itemId: item.id,
              quantity: itemConfig.quantity,
              price: itemConfig.price,
              isSystemItem: true,
            },
          })
          console.log(
            `  ‚ú® Added ${itemConfig.name}: ${itemConfig.quantity} @ ${itemConfig.price} coins`
          )
          totalListingsCreated++
        }
      }
    }

    console.log(&#39;\nüéâ Enhanced market seed completed successfully!&#39;)
    console.log(
      `üìä Created ${totalListingsCreated} new listings, updated ${totalListingsUpdated} existing`
    )

    // Show summary by location
    console.log(&#39;\nüè™ Market Summary by Location:&#39;)
    for (const location of configuredLocations) {
      const locationListings = await prisma.marketListing.count({
        where: {
          locationId: location.id,
          isSystemItem: true,
        },
      })

      if (locationListings &gt; 0) {
        console.log(`  ${location.name}: ${locationListings} items available`)
      }
    }

    // Show legendary/epic items available
    console.log(&#39;\n‚≠ê Premium Items Available:&#39;)
    const premiumListings = await prisma.marketListing.findMany({
      where: {
        isSystemItem: true,
        item: {
          rarity: {
            in: [&#39;EPIC&#39;, &#39;LEGENDARY&#39;],
          },
        },
      },
      include: {
        item: true,
        location: true,
      },
      orderBy: { price: &#39;desc&#39; },
    })

    premiumListings.forEach((listing) =&gt; {
      console.log(
        `  ${listing.item.name} (${listing.item.rarity}) - ${listing.price} coins at ${listing.location.name}`
      )
    })

    // Show total market value
    const totalMarketValue = await prisma.marketListing.aggregate({
      where: { isSystemItem: true },
      _sum: {
        price: true,
      },
    })

    console.log(
      `\nüí∞ Total Market Value: ${totalMarketValue._sum.price || 0} coins`
    )
  } catch (error) {
    console.error(&#39;‚ùå Enhanced market seed failed:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

// Command line options
const args = process.argv.slice(2)

if (args.includes(&#39;--help&#39;) || args.includes(&#39;-h&#39;)) {
  console.log(`
üè™ Enhanced Market Seeding Script

Usage:
  npm run seed:enhanced-markets          # Restock all markets with new items
  npm run seed:enhanced-markets --clear  # Clear all system listings first
  npm run seed:enhanced-markets --location &quot;Central Exchange&quot;  # Specific location

Features:
  ‚ú® All 7 locations covered with themed items
  üí∞ Location-appropriate pricing strategy
  üéØ Rarity-based availability system
  üè™ Each location has unique specialties

Locations Covered:
  üè≠ Mining Plains - Industrial mining gear
  üè¢ Central Exchange - High-tech cyber gear + legendaries
  üèúÔ∏è Desert Outpost - Survival gear + ancient artifacts
  üéÆ The Glitch Club - Underground hacker gear + memes
  üç∫ Rusty Pickaxe Inn - Newbie basics + tavern specials
  üíé Crystal Caves - Professional mining tools
  üèôÔ∏è Cyber City - Basic urban supplies

Premium Items:
  üî• Golden Pickaxe (2500 coins at Crystal Caves)
  üíæ Rare Floppy Disk (500 coins at Central Exchange)
  üè∫ Ancient Artifact (1000 coins at Desert Outpost)
  üåà Rainbow Hoodie (200 coins at Central Exchange)
  üé≠ Wojak Mask (250 coins at The Glitch Club)
`)
  process.exit(0)
}

// Handle clear option
if (args.includes(&#39;--clear&#39;)) {
  console.log(&#39;üßπ Clearing existing system market listings...&#39;)
  await prisma.marketListing.deleteMany({
    where: { isSystemItem: true },
  })
  console.log(&#39;‚úÖ Cleared all system listings&#39;)
}

// Handle specific location
const locationArg = args.indexOf(&#39;--location&#39;)
if (locationArg !== -1 &amp;&amp; args[locationArg + 1]) {
  const targetLocation = args[locationArg + 1]
  console.log(`üéØ Targeting specific location: ${targetLocation}`)

  // Filter configs to only include the target location
  const filteredConfig = {
    [targetLocation]:
      ENHANCED_MARKET_CONFIGS[
        targetLocation as keyof typeof ENHANCED_MARKET_CONFIGS
      ],
  }

  if (!filteredConfig[targetLocation]) {
    console.error(`‚ùå No market config found for location: ${targetLocation}`)
    console.log(
      &#39;Available locations:&#39;,
      Object.keys(ENHANCED_MARKET_CONFIGS).join(&#39;, &#39;)
    )
    process.exit(1)
  }

  // Clear all other configs
  Object.keys(ENHANCED_MARKET_CONFIGS).forEach((key) =&gt; {
    if (key !== targetLocation) {
      delete ENHANCED_MARKET_CONFIGS[
        key as keyof typeof ENHANCED_MARKET_CONFIGS
      ]
    }
  })
}

// Run the seed
seedEnhancedMarkets()
</content>
    </document>

    <document>
      <source>scripts/setup-complete-game.ts</source>
      <tags></tags>
      <metadata>
        <size>9691</size>
        <lastModified>2025-05-29T06:32:31.722Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/setup-complete-game.ts - One script to rule them all
import { PrismaClient, ItemCategory, LayerType, Rarity } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

// All items combined (themed + tools)
const ALL_NEW_ITEMS = [
  // === THEMED ITEMS ===
  {
    name: &#39;Rare Floppy Disk&#39;,
    description: &#39;Contains legendary source code from the early net&#39;,
    category: ItemCategory.MATERIAL,
    rarity: Rarity.LEGENDARY,
    imageUrl: &#39;/items/rare-floppy-disk.png&#39;,
  },
  {
    name: &#39;Cyberpunk Shades&#39;,
    description: &#39;AR-enhanced sunglasses with data overlay&#39;,
    category: ItemCategory.ACCESSORY,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    energyEffect: 10,
    imageUrl: &#39;/items/cyberpunk-shades.png&#39;,
  },
  {
    name: &#39;Neon Visor&#39;,
    description: &#39;Glowing headgear that screams &quot;I hack the planet&quot;&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.EPIC,
    energyEffect: 15,
    imageUrl: &#39;/items/neon-visor.png&#39;,
  },
  {
    name: &#39;Heavy Duty Boots&#39;,
    description: &#39;Steel-toed boots for serious mining work&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.UNCOMMON,
    healthEffect: 10,
    imageUrl: &#39;/items/heavy-duty-boots.png&#39;,
  },
  {
    name: &#39;Desert Wrap&#39;,
    description: &#39;Traditional headwrap that protects from sandstorms&#39;,
    category: ItemCategory.HAT,
    layerType: LayerType.HAT,
    rarity: Rarity.UNCOMMON,
    healthEffect: 8,
    imageUrl: &#39;/items/desert-wrap.png&#39;,
  },
  {
    name: &#39;Rainbow Hoodie&#39;,
    description: &#39;Psychedelic hoodie that shifts colors in the light&#39;,
    category: ItemCategory.CLOTHING,
    layerType: LayerType.CLOTHING,
    rarity: Rarity.EPIC,
    energyEffect: 20,
    imageUrl: &#39;/items/rainbow-hoodie.png&#39;,
  },

  // === TOOL ITEMS ===
  {
    name: &#39;Basic Pickaxe&#39;,
    description: &#39;Standard mining tool for beginners&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 50,
    imageUrl: &#39;/items/basic-pickaxe.png&#39;,
  },
  {
    name: &#39;Multi-Tool&#39;,
    description: &#39;Swiss army knife of the digital age&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 100,
    imageUrl: &#39;/items/multi-tool.png&#39;,
  },
  {
    name: &#39;Hacking Toolkit&#39;,
    description: &#39;Portable device for digital infiltration&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 150,
    imageUrl: &#39;/items/hacking-toolkit.png&#39;,
  },
  {
    name: &#39;Omni-Tool&#39;,
    description: &#39;Legendary device that adapts to any situation&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.LEGENDARY,
    durability: 1000,
    energyEffect: 20,
    healthEffect: 10,
    imageUrl: &#39;/items/omni-tool.png&#39;,
  },
]

// Enhanced market configs (simplified - core items only)
const MARKET_CONFIGS = {
  &#39;Mining Plains&#39;: [
    { name: &#39;Miners Hat&#39;, quantity: 8, price: 15 },
    { name: &#39;Basic Pickaxe&#39;, quantity: 5, price: 20 },
    { name: &#39;Multi-Tool&#39;, quantity: 3, price: 35 },
    { name: &#39;Energy Drink&#39;, quantity: 15, price: 8 },
    { name: &#39;Heavy Duty Boots&#39;, quantity: 2, price: 45 },
  ],
  &#39;Central Exchange&#39;: [
    { name: &#39;Cyberpunk Shades&#39;, quantity: 3, price: 65 },
    { name: &#39;Neon Visor&#39;, quantity: 1, price: 150 },
    { name: &#39;Hacking Toolkit&#39;, quantity: 2, price: 120 },
    { name: &#39;Rainbow Hoodie&#39;, quantity: 1, price: 200 },
    { name: &#39;Rare Floppy Disk&#39;, quantity: 1, price: 500 },
  ],
  &#39;Desert Outpost&#39;: [
    { name: &#39;Desert Wrap&#39;, quantity: 4, price: 35 },
    { name: &#39;Energy Drink&#39;, quantity: 6, price: 15 },
    { name: &#39;Health Potion&#39;, quantity: 4, price: 35 },
  ],
  &#39;The Glitch Club&#39;: [
    { name: &#39;Cyberpunk Shades&#39;, quantity: 4, price: 55 },
    { name: &#39;Hacking Toolkit&#39;, quantity: 3, price: 100 },
    { name: &#39;Multi-Tool&#39;, quantity: 4, price: 30 },
  ],
  &#39;Rusty Pickaxe Inn&#39;: [
    { name: &#39;Energy Drink&#39;, quantity: 20, price: 10 },
    { name: &#39;Basic Pickaxe&#39;, quantity: 8, price: 18 },
    { name: &#39;Multi-Tool&#39;, quantity: 5, price: 32 },
  ],
  &#39;Crystal Caves&#39;: [
    { name: &#39;Energy Drink&#39;, quantity: 12, price: 12 },
    { name: &#39;Health Potion&#39;, quantity: 8, price: 28 },
    { name: &#39;Omni-Tool&#39;, quantity: 1, price: 3500 },
  ],
  &#39;Cyber City&#39;: [
    { name: &#39;Energy Drink&#39;, quantity: 10, price: 15 },
    { name: &#39;Health Potion&#39;, quantity: 8, price: 30 },
  ],
}

// Mining configs (simplified)
const MINING_CONFIGS = {
  &#39;Mining Plains&#39;: [
    { name: &#39;Dirty Coal&#39;, spawnRate: 0.5, maxPerDay: 25, difficulty: 1 },
    { name: &#39;Iron Scraps&#39;, spawnRate: 0.35, maxPerDay: 15, difficulty: 1 },
    { name: &#39;Basic Pickaxe&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 1 },
  ],
  &#39;Crystal Caves&#39;: [
    { name: &#39;Crystal Shard&#39;, spawnRate: 0.15, maxPerDay: 5, difficulty: 3 },
    { name: &#39;Ancient Coin&#39;, spawnRate: 0.08, maxPerDay: 3, difficulty: 2 },
    { name: &#39;Omni-Tool&#39;, spawnRate: 0.002, maxPerDay: 1, difficulty: 5 },
  ],
  &#39;Desert Outpost&#39;: [
    { name: &#39;Ancient Coin&#39;, spawnRate: 0.18, maxPerDay: 8, difficulty: 3 },
    { name: &#39;Crystal Shard&#39;, spawnRate: 0.06, maxPerDay: 2, difficulty: 4 },
  ],
  &#39;Central Exchange&#39;: [
    { name: &#39;Hacking Toolkit&#39;, spawnRate: 0.02, maxPerDay: 1, difficulty: 4 },
  ],
  &#39;The Glitch Club&#39;: [
    { name: &#39;Hacking Toolkit&#39;, spawnRate: 0.035, maxPerDay: 2, difficulty: 3 },
  ],
}

async function setupCompleteGame() {
  console.log(&#39;üéÆ Setting up complete Wojak Earth game...\n&#39;)

  try {
    // Step 1: Add all items
    console.log(&#39;üì¶ STEP 1: Adding items...&#39;)
    let itemsAdded = 0

    for (const itemData of ALL_NEW_ITEMS) {
      const existingItem = await prisma.item.findUnique({
        where: { name: itemData.name },
      })

      if (!existingItem) {
        await prisma.item.create({ data: itemData })
        console.log(`  ‚ú® Added ${itemData.name} (${itemData.rarity})`)
        itemsAdded++
      }
    }
    console.log(`‚úÖ Added ${itemsAdded} new items\n`)

    // Step 2: Fix market locations
    console.log(&#39;üè™ STEP 2: Fixing market locations...&#39;)
    await prisma.location.updateMany({
      where: {
        name: { in: [&#39;Crystal Caves&#39;, &#39;The Glitch Club&#39;, &#39;Cyber City&#39;] },
      },
      data: { hasMarket: true },
    })
    console.log(&#39;‚úÖ Market locations fixed\n&#39;)

    // Step 3: Setup mining resources
    console.log(&#39;‚õèÔ∏è STEP 3: Setting up mining resources...&#39;)
    const locations = await prisma.location.findMany({
      where: { hasMining: true },
    })
    const items = await prisma.item.findMany()
    const itemMap = new Map(items.map((item) =&gt; [item.name, item]))

    let miningResourcesAdded = 0

    for (const location of locations) {
      const configs =
        MINING_CONFIGS[location.name as keyof typeof MINING_CONFIGS]
      if (!configs) continue

      for (const config of configs) {
        const item = itemMap.get(config.name)
        if (!item) continue

        const existing = await prisma.locationResource.findUnique({
          where: {
            locationId_itemId: { locationId: location.id, itemId: item.id },
          },
        })

        if (!existing) {
          await prisma.locationResource.create({
            data: {
              locationId: location.id,
              itemId: item.id,
              spawnRate: config.spawnRate,
              maxPerDay: config.maxPerDay,
              difficulty: config.difficulty,
            },
          })
          miningResourcesAdded++
        }
      }
    }
    console.log(`‚úÖ Added ${miningResourcesAdded} mining resources\n`)

    // Step 4: Setup markets
    console.log(&#39;üõí STEP 4: Setting up markets...&#39;)
    const marketLocations = await prisma.location.findMany({
      where: { hasMarket: true },
    })

    let marketListingsAdded = 0

    for (const location of marketLocations) {
      const configs =
        MARKET_CONFIGS[location.name as keyof typeof MARKET_CONFIGS]
      if (!configs) continue

      for (const config of configs) {
        const item = itemMap.get(config.name)
        if (!item) continue

        const existing = await prisma.marketListing.findFirst({
          where: {
            locationId: location.id,
            itemId: item.id,
            isSystemItem: true,
          },
        })

        if (existing) {
          await prisma.marketListing.update({
            where: { id: existing.id },
            data: { quantity: config.quantity, price: config.price },
          })
        } else {
          await prisma.marketListing.create({
            data: {
              locationId: location.id,
              itemId: item.id,
              quantity: config.quantity,
              price: config.price,
              isSystemItem: true,
            },
          })
          marketListingsAdded++
        }
      }
    }
    console.log(`‚úÖ Added/updated ${marketListingsAdded} market listings\n`)

    // Final summary
    console.log(&#39;üéâ SETUP COMPLETE!&#39;)
    console.log(&#39;=&#39;.repeat(50))

    const totalItems = await prisma.item.count()
    const totalMiningNodes = await prisma.locationResource.count()
    const totalMarketListings = await prisma.marketListing.count({
      where: { isSystemItem: true },
    })

    console.log(`üì¶ Total items in database: ${totalItems}`)
    console.log(`‚õèÔ∏è Total mining resource nodes: ${totalMiningNodes}`)
    console.log(`üõí Total market listings: ${totalMarketListings}`)

    console.log(&#39;\nüöÄ Your game is ready! Run `npm run dev` to start playing!&#39;)
  } catch (error) {
    console.error(&#39;‚ùå Setup failed:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

setupCompleteGame()
</content>
    </document>

    <document>
      <source>scripts/add-proper-tools.ts</source>
      <tags></tags>
      <metadata>
        <size>6468</size>
        <lastModified>2025-05-29T06:21:08.021Z</lastModified>
        <extension>ts</extension>
        <directory>scripts</directory>
      </metadata>
      <content>// scripts/add-proper-tools.ts - Add more diverse tool items
import { PrismaClient, ItemCategory, LayerType, Rarity } from &#39;@prisma/client&#39;

const prisma = new PrismaClient()

const TOOL_ITEMS = [
  // === MINING TOOLS ===
  {
    name: &#39;Basic Pickaxe&#39;,
    description: &#39;Standard mining tool for beginners&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY, // Tools render as accessories for now
    rarity: Rarity.COMMON,
    durability: 50,
    imageUrl: &#39;/items/basic-pickaxe.png&#39;,
  },
  {
    name: &#39;Drill Hammer&#39;,
    description: &#39;Pneumatic drilling tool for tough rocks&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.UNCOMMON,
    durability: 120,
    energyEffect: -5, // Tools can cost energy to use
    imageUrl: &#39;/items/drill-hammer.png&#39;,
  },
  {
    name: &#39;Laser Cutter&#39;,
    description: &#39;High-tech precision cutting tool&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 80,
    energyEffect: -10, // High energy cost
    imageUrl: &#39;/items/laser-cutter.png&#39;,
  },

  // === UTILITY TOOLS ===
  {
    name: &#39;Multi-Tool&#39;,
    description: &#39;Swiss army knife of the digital age&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 100,
    imageUrl: &#39;/items/multi-tool.png&#39;,
  },
  {
    name: &#39;Repair Kit&#39;,
    description: &#39;Essential tool for fixing equipment on the go&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.UNCOMMON,
    durability: 25, // Limited uses
    imageUrl: &#39;/items/repair-kit.png&#39;,
  },
  {
    name: &#39;Scanning Device&#39;,
    description: &#39;Detects rare materials and hidden resources&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 200,
    energyEffect: -3, // Small energy cost per scan
    imageUrl: &#39;/items/scanning-device.png&#39;,
  },

  // === CYBER TOOLS ===
  {
    name: &#39;Hacking Toolkit&#39;,
    description: &#39;Portable device for digital infiltration&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.RARE,
    durability: 150,
    imageUrl: &#39;/items/hacking-toolkit.png&#39;,
  },
  {
    name: &#39;Signal Booster&#39;,
    description: &#39;Amplifies wireless connections and data transfers&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.UNCOMMON,
    durability: 300,
    energyEffect: 5, // Boosts energy regeneration
    imageUrl: &#39;/items/signal-booster.png&#39;,
  },
  {
    name: &#39;Quantum Processor&#39;,
    description: &#39;Cutting-edge computing tool for complex calculations&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.EPIC,
    durability: 100,
    energyEffect: 15, // Major energy boost
    imageUrl: &#39;/items/quantum-processor.png&#39;,
  },

  // === SURVIVAL TOOLS ===
  {
    name: &#39;Survival Knife&#39;,
    description: &#39;Multipurpose blade for harsh environments&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 200,
    healthEffect: 5, // Provides some protection
    imageUrl: &#39;/items/survival-knife.png&#39;,
  },
  {
    name: &#39;Fire Starter&#39;,
    description: &#39;Reliable ignition tool for cold nights&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.COMMON,
    durability: 50,
    imageUrl: &#39;/items/fire-starter.png&#39;,
  },
  {
    name: &#39;GPS Tracker&#39;,
    description: &#39;Never get lost in the wilderness again&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.UNCOMMON,
    durability: 500, // Long-lasting
    imageUrl: &#39;/items/gps-tracker.png&#39;,
  },

  // === LEGENDARY TOOLS ===
  {
    name: &#39;Omni-Tool&#39;,
    description: &#39;Legendary device that adapts to any situation&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.LEGENDARY,
    durability: 1000,
    energyEffect: 20,
    healthEffect: 10,
    imageUrl: &#39;/items/omni-tool.png&#39;,
  },
  {
    name: &#39;Reality Wrench&#39;,
    description: &#39;Tool so advanced it seems to bend the laws of physics&#39;,
    category: ItemCategory.TOOL,
    layerType: LayerType.ACCESSORY,
    rarity: Rarity.LEGENDARY,
    durability: 777,
    energyEffect: 25,
    imageUrl: &#39;/items/reality-wrench.png&#39;,
  },
]

async function addProperTools() {
  console.log(&#39;üîß Adding proper tool items to Wojak Earth...&#39;)

  try {
    let toolsAdded = 0

    for (const toolData of TOOL_ITEMS) {
      // Check if tool already exists
      const existingTool = await prisma.item.findUnique({
        where: { name: toolData.name },
      })

      if (existingTool) {
        console.log(`  ‚ö†Ô∏è  Tool &#39;${toolData.name}&#39; already exists, skipping...`)
        continue
      }

      // Create new tool
      await prisma.item.create({
        data: toolData,
      })

      console.log(`  üîß Added ${toolData.name} (${toolData.rarity})`)
      toolsAdded++
    }

    console.log(&#39;\nüéâ Tool items added successfully!&#39;)
    console.log(`üìä Added ${toolsAdded} new tools`)

    // Show summary by rarity
    const toolsByRarity = TOOL_ITEMS.reduce((acc, tool) =&gt; {
      const rarity = tool.rarity.toString()
      acc[rarity] = (acc[rarity] || 0) + 1
      return acc
    }, {} as Record&lt;string, number&gt;)

    console.log(&#39;\nüåü Tools Added by Rarity:&#39;)
    Object.entries(toolsByRarity).forEach(([rarity, count]) =&gt; {
      console.log(`  ${rarity}: ${count} tools`)
    })

    // Show tool categories
    console.log(&#39;\nüîß Tool Categories:&#39;)
    console.log(&#39;  ‚õèÔ∏è  Mining Tools: Basic Pickaxe, Drill Hammer, Laser Cutter&#39;)
    console.log(&#39;  üõ†Ô∏è  Utility Tools: Multi-Tool, Repair Kit, Scanning Device&#39;)
    console.log(
      &#39;  üíª Cyber Tools: Hacking Toolkit, Signal Booster, Quantum Processor&#39;
    )
    console.log(
      &#39;  üèïÔ∏è  Survival Tools: Survival Knife, Fire Starter, GPS Tracker&#39;
    )
    console.log(&#39;  ‚≠ê Legendary: Omni-Tool, Reality Wrench&#39;)

    console.log(&#39;\nüí° Next Steps:&#39;)
    console.log(
      &#39;  1. Run npm run update:mining to add tools to mining locations&#39;
    )
    console.log(
      &#39;  2. Run npm run seed:enhanced-markets to add tools to markets&#39;
    )
    console.log(&#39;  3. Tools will appear in the TOOL equipment slot!&#39;)
  } catch (error) {
    console.error(&#39;‚ùå Failed to add tool items:&#39;, error)
    process.exit(1)
  } finally {
    await prisma.$disconnect()
  }
}

addProperTools()
</content>
    </document>

    <document>
      <source>src/types/index.ts</source>
      <tags></tags>
      <metadata>
        <size>3015</size>
        <lastModified>2025-05-29T07:19:18.019Z</lastModified>
        <extension>ts</extension>
        <directory>src/types</directory>
      </metadata>
      <content>// src/types/index.ts
export type GameView =
  | &#39;main&#39;
  | &#39;map&#39;
  | &#39;location&#39;
  | &#39;mine&#39;
  | &#39;market&#39;
  | &#39;inventory&#39;
  | &#39;chat&#39;
  | &#39;gamemaster&#39;

export interface Character {
  id: string
  name: string
  gender: string
  energy: number
  health: number
  currentImageUrl: string
  currentLocation: {
    id: string
    name: string
    description: string
    locationType: string
    biome?: string
    welcomeMessage?: string
  }
  inventory: Array&lt;{
    id: string
    quantity: number
    isEquipped: boolean
    item: {
      id: string
      name: string
      description: string
      category: string
      rarity: string
      imageUrl?: string
      energyEffect?: number
      healthEffect?: number
    }
  }&gt;
  recentActivity: Array&lt;{
    id: string
    type: string
    description: string
    item?: {
      name: string
      rarity: string
    }
  }&gt;
}

export interface Location {
  id: string
  name: string
  description: string
  locationType: string
  biome?: string
  difficulty: number
  playerCount: number
  lastActive?: string
  hasMarket: boolean
  hasMining: boolean
  hasChat: boolean
  welcomeMessage?: string
  lore?: string
  subLocations?: Location[]
}

export interface MarketItem {
  id: string
  price: number
  quantity: number
  isSystemItem: boolean
  isLocalSpecialty?: boolean
  seller?: {
    id: string
    name: string
  }
  item: {
    id: string
    name: string
    description: string
    category: string
    rarity: string
    imageUrl?: string
  }
}

export interface ChatMessage {
  id: string
  message: string
  messageType: &#39;CHAT&#39; | &#39;EMOTE&#39; | &#39;SYSTEM&#39;
  isSystem: boolean
  timeAgo: string
  createdAt: string
  character?: {
    id: string
    name: string
    characterType: string
    imageUrl?: string
  }
  location: {
    id: string
    name: string
    locationType: string
  }
}

export interface Player {
  id: string
  name: string
  gender: string
  characterType: string
  level: number
  energy: number
  health: number
  status: string
  currentImageUrl?: string
  equippedItems: Array&lt;{
    name: string
    category: string
    rarity: string
  }&gt;
}

export type EquipmentSlot = &#39;head&#39; | &#39;body&#39; | &#39;accessory&#39; | &#39;tool&#39;

export interface EquipmentSlotInfo {
  name: string
  slot: EquipmentSlot
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  icon: any // Lucide icon component
  equipped?: {
    id: string
    name: string
    rarity: string
  }
}

export interface EnhancedCharacter extends Character {
  equipmentSlots?: {
    [K in EquipmentSlot]?: {
      itemId: string
      itemName: string
      rarity: string
    }
  }
}

// Equipment slot conflicts - for future slot-specific logic
export const SLOT_CONFLICTS: Record&lt;string, EquipmentSlot[]&gt; = {
  HAT: [&#39;head&#39;],
  CLOTHING: [&#39;body&#39;],
  ACCESSORY: [&#39;accessory&#39;],
  TOOL: [&#39;tool&#39;],
}

// Equipment bonuses by slot - for future enhancement
export interface SlotBonuses {
  energyBonus: number
  healthBonus: number
  miningBonus: number
  luckBonus: number
}
</content>
    </document>

    <document>
      <source>src/components/ui/tabs.tsx</source>
      <tags></tags>
      <metadata>
        <size>1955</size>
        <lastModified>2025-05-29T11:14:29.295Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as TabsPrimitive from &quot;@radix-ui/react-tabs&quot;

import { cn } from &quot;@/lib/utils&quot;

function Tabs({
  className,
  ...props
}: React.ComponentProps&lt;typeof TabsPrimitive.Root&gt;) {
  return (
    &lt;TabsPrimitive.Root
      data-slot=&quot;tabs&quot;
      className={cn(&quot;flex flex-col gap-2&quot;, className)}
      {...props}
    /&gt;
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps&lt;typeof TabsPrimitive.List&gt;) {
  return (
    &lt;TabsPrimitive.List
      data-slot=&quot;tabs-list&quot;
      className={cn(
        &quot;bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-[3px]&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps&lt;typeof TabsPrimitive.Trigger&gt;) {
  return (
    &lt;TabsPrimitive.Trigger
      data-slot=&quot;tabs-trigger&quot;
      className={cn(
        &quot;data-[state=active]:bg-background dark:data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring dark:data-[state=active]:border-input dark:data-[state=active]:bg-input/30 text-foreground dark:text-muted-foreground inline-flex h-[calc(100%-1px)] flex-1 items-center justify-center gap-1.5 rounded-md border border-transparent px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps&lt;typeof TabsPrimitive.Content&gt;) {
  return (
    &lt;TabsPrimitive.Content
      data-slot=&quot;tabs-content&quot;
      className={cn(&quot;flex-1 outline-none&quot;, className)}
      {...props}
    /&gt;
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
</content>
    </document>

    <document>
      <source>src/components/ui/tooltip.tsx</source>
      <tags></tags>
      <metadata>
        <size>1877</size>
        <lastModified>2025-05-29T11:09:24.963Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as TooltipPrimitive from &quot;@radix-ui/react-tooltip&quot;

import { cn } from &quot;@/lib/utils&quot;

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps&lt;typeof TooltipPrimitive.Provider&gt;) {
  return (
    &lt;TooltipPrimitive.Provider
      data-slot=&quot;tooltip-provider&quot;
      delayDuration={delayDuration}
      {...props}
    /&gt;
  )
}

function Tooltip({
  ...props
}: React.ComponentProps&lt;typeof TooltipPrimitive.Root&gt;) {
  return (
    &lt;TooltipProvider&gt;
      &lt;TooltipPrimitive.Root data-slot=&quot;tooltip&quot; {...props} /&gt;
    &lt;/TooltipProvider&gt;
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps&lt;typeof TooltipPrimitive.Trigger&gt;) {
  return &lt;TooltipPrimitive.Trigger data-slot=&quot;tooltip-trigger&quot; {...props} /&gt;
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps&lt;typeof TooltipPrimitive.Content&gt;) {
  return (
    &lt;TooltipPrimitive.Portal&gt;
      &lt;TooltipPrimitive.Content
        data-slot=&quot;tooltip-content&quot;
        sideOffset={sideOffset}
        className={cn(
          &quot;bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance&quot;,
          className
        )}
        {...props}
      &gt;
        {children}
        &lt;TooltipPrimitive.Arrow className=&quot;bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]&quot; /&gt;
      &lt;/TooltipPrimitive.Content&gt;
    &lt;/TooltipPrimitive.Portal&gt;
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</content>
    </document>

    <document>
      <source>src/components/ui/sonner.tsx</source>
      <tags></tags>
      <metadata>
        <size>627</size>
        <lastModified>2025-05-29T04:28:51.400Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>// src/components/ui/sonner.tsx - Fixed version
import { useTheme } from &quot;next-themes&quot;
import { Toaster as Sonner } from &quot;sonner&quot;
import type { ToasterProps } from &quot;sonner&quot;

const Toaster = ({ ...props }: ToasterProps) =&gt; {
  const { theme = &quot;system&quot; } = useTheme()

  return (
    &lt;Sonner
      theme={theme as ToasterProps[&quot;theme&quot;]}
      className=&quot;toaster group&quot;
      style={
        {
          &quot;--normal-bg&quot;: &quot;var(--popover)&quot;,
          &quot;--normal-text&quot;: &quot;var(--popover-foreground)&quot;,
          &quot;--normal-border&quot;: &quot;var(--border)&quot;,
        } as React.CSSProperties
      }
      {...props}
    /&gt;
  )
}

export { Toaster }
</content>
    </document>

    <document>
      <source>src/components/ui/dialog.tsx</source>
      <tags></tags>
      <metadata>
        <size>3813</size>
        <lastModified>2025-05-29T08:13:25.281Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>&quot;use client&quot;

import * as React from &quot;react&quot;
import * as DialogPrimitive from &quot;@radix-ui/react-dialog&quot;
import { XIcon } from &quot;lucide-react&quot;

import { cn } from &quot;@/lib/utils&quot;

function Dialog({
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Root&gt;) {
  return &lt;DialogPrimitive.Root data-slot=&quot;dialog&quot; {...props} /&gt;
}

function DialogTrigger({
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Trigger&gt;) {
  return &lt;DialogPrimitive.Trigger data-slot=&quot;dialog-trigger&quot; {...props} /&gt;
}

function DialogPortal({
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Portal&gt;) {
  return &lt;DialogPrimitive.Portal data-slot=&quot;dialog-portal&quot; {...props} /&gt;
}

function DialogClose({
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Close&gt;) {
  return &lt;DialogPrimitive.Close data-slot=&quot;dialog-close&quot; {...props} /&gt;
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Overlay&gt;) {
  return (
    &lt;DialogPrimitive.Overlay
      data-slot=&quot;dialog-overlay&quot;
      className={cn(
        &quot;data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Content&gt;) {
  return (
    &lt;DialogPortal data-slot=&quot;dialog-portal&quot;&gt;
      &lt;DialogOverlay /&gt;
      &lt;DialogPrimitive.Content
        data-slot=&quot;dialog-content&quot;
        className={cn(
          &quot;bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg&quot;,
          className
        )}
        {...props}
      &gt;
        {children}
        &lt;DialogPrimitive.Close className=&quot;ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4&quot;&gt;
          &lt;XIcon /&gt;
          &lt;span className=&quot;sr-only&quot;&gt;Close&lt;/span&gt;
        &lt;/DialogPrimitive.Close&gt;
      &lt;/DialogPrimitive.Content&gt;
    &lt;/DialogPortal&gt;
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps&lt;&quot;div&quot;&gt;) {
  return (
    &lt;div
      data-slot=&quot;dialog-header&quot;
      className={cn(&quot;flex flex-col gap-2 text-center sm:text-left&quot;, className)}
      {...props}
    /&gt;
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps&lt;&quot;div&quot;&gt;) {
  return (
    &lt;div
      data-slot=&quot;dialog-footer&quot;
      className={cn(
        &quot;flex flex-col-reverse gap-2 sm:flex-row sm:justify-end&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Title&gt;) {
  return (
    &lt;DialogPrimitive.Title
      data-slot=&quot;dialog-title&quot;
      className={cn(&quot;text-lg leading-none font-semibold&quot;, className)}
      {...props}
    /&gt;
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps&lt;typeof DialogPrimitive.Description&gt;) {
  return (
    &lt;DialogPrimitive.Description
      data-slot=&quot;dialog-description&quot;
      className={cn(&quot;text-muted-foreground text-sm&quot;, className)}
      {...props}
    /&gt;
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</content>
    </document>

    <document>
      <source>src/components/ui/dropdown-menu.tsx</source>
      <tags></tags>
      <metadata>
        <size>8270</size>
        <lastModified>2025-05-29T00:35:27.082Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as DropdownMenuPrimitive from &quot;@radix-ui/react-dropdown-menu&quot;
import { CheckIcon, ChevronRightIcon, CircleIcon } from &quot;lucide-react&quot;

import { cn } from &quot;@/lib/utils&quot;

function DropdownMenu({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Root&gt;) {
  return &lt;DropdownMenuPrimitive.Root data-slot=&quot;dropdown-menu&quot; {...props} /&gt;
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Portal&gt;) {
  return (
    &lt;DropdownMenuPrimitive.Portal data-slot=&quot;dropdown-menu-portal&quot; {...props} /&gt;
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Trigger&gt;) {
  return (
    &lt;DropdownMenuPrimitive.Trigger
      data-slot=&quot;dropdown-menu-trigger&quot;
      {...props}
    /&gt;
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Content&gt;) {
  return (
    &lt;DropdownMenuPrimitive.Portal&gt;
      &lt;DropdownMenuPrimitive.Content
        data-slot=&quot;dropdown-menu-content&quot;
        sideOffset={sideOffset}
        className={cn(
          &quot;bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md&quot;,
          className
        )}
        {...props}
      /&gt;
    &lt;/DropdownMenuPrimitive.Portal&gt;
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Group&gt;) {
  return (
    &lt;DropdownMenuPrimitive.Group data-slot=&quot;dropdown-menu-group&quot; {...props} /&gt;
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = &quot;default&quot;,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Item&gt; &amp; {
  inset?: boolean
  variant?: &quot;default&quot; | &quot;destructive&quot;
}) {
  return (
    &lt;DropdownMenuPrimitive.Item
      data-slot=&quot;dropdown-menu-item&quot;
      data-inset={inset}
      data-variant={variant}
      className={cn(
        &quot;focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&amp;_svg:not([class*=&#39;text-&#39;])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.CheckboxItem&gt;) {
  return (
    &lt;DropdownMenuPrimitive.CheckboxItem
      data-slot=&quot;dropdown-menu-checkbox-item&quot;
      className={cn(
        &quot;focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4&quot;,
        className
      )}
      checked={checked}
      {...props}
    &gt;
      &lt;span className=&quot;pointer-events-none absolute left-2 flex size-3.5 items-center justify-center&quot;&gt;
        &lt;DropdownMenuPrimitive.ItemIndicator&gt;
          &lt;CheckIcon className=&quot;size-4&quot; /&gt;
        &lt;/DropdownMenuPrimitive.ItemIndicator&gt;
      &lt;/span&gt;
      {children}
    &lt;/DropdownMenuPrimitive.CheckboxItem&gt;
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.RadioGroup&gt;) {
  return (
    &lt;DropdownMenuPrimitive.RadioGroup
      data-slot=&quot;dropdown-menu-radio-group&quot;
      {...props}
    /&gt;
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.RadioItem&gt;) {
  return (
    &lt;DropdownMenuPrimitive.RadioItem
      data-slot=&quot;dropdown-menu-radio-item&quot;
      className={cn(
        &quot;focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:shrink-0 [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4&quot;,
        className
      )}
      {...props}
    &gt;
      &lt;span className=&quot;pointer-events-none absolute left-2 flex size-3.5 items-center justify-center&quot;&gt;
        &lt;DropdownMenuPrimitive.ItemIndicator&gt;
          &lt;CircleIcon className=&quot;size-2 fill-current&quot; /&gt;
        &lt;/DropdownMenuPrimitive.ItemIndicator&gt;
      &lt;/span&gt;
      {children}
    &lt;/DropdownMenuPrimitive.RadioItem&gt;
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Label&gt; &amp; {
  inset?: boolean
}) {
  return (
    &lt;DropdownMenuPrimitive.Label
      data-slot=&quot;dropdown-menu-label&quot;
      data-inset={inset}
      className={cn(
        &quot;px-2 py-1.5 text-sm font-medium data-[inset]:pl-8&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Separator&gt;) {
  return (
    &lt;DropdownMenuPrimitive.Separator
      data-slot=&quot;dropdown-menu-separator&quot;
      className={cn(&quot;bg-border -mx-1 my-1 h-px&quot;, className)}
      {...props}
    /&gt;
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps&lt;&quot;span&quot;&gt;) {
  return (
    &lt;span
      data-slot=&quot;dropdown-menu-shortcut&quot;
      className={cn(
        &quot;text-muted-foreground ml-auto text-xs tracking-widest&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.Sub&gt;) {
  return &lt;DropdownMenuPrimitive.Sub data-slot=&quot;dropdown-menu-sub&quot; {...props} /&gt;
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.SubTrigger&gt; &amp; {
  inset?: boolean
}) {
  return (
    &lt;DropdownMenuPrimitive.SubTrigger
      data-slot=&quot;dropdown-menu-sub-trigger&quot;
      data-inset={inset}
      className={cn(
        &quot;focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8&quot;,
        className
      )}
      {...props}
    &gt;
      {children}
      &lt;ChevronRightIcon className=&quot;ml-auto size-4&quot; /&gt;
    &lt;/DropdownMenuPrimitive.SubTrigger&gt;
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps&lt;typeof DropdownMenuPrimitive.SubContent&gt;) {
  return (
    &lt;DropdownMenuPrimitive.SubContent
      data-slot=&quot;dropdown-menu-sub-content&quot;
      className={cn(
        &quot;bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</content>
    </document>

    <document>
      <source>src/components/ui/button.tsx</source>
      <tags></tags>
      <metadata>
        <size>2123</size>
        <lastModified>2025-05-28T21:47:16.145Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import { Slot } from &quot;@radix-ui/react-slot&quot;
import { cva, type VariantProps } from &quot;class-variance-authority&quot;

import { cn } from &quot;@/lib/utils&quot;

const buttonVariants = cva(
  &quot;inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg:not([class*=&#39;size-&#39;])]:size-4 shrink-0 [&amp;_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive&quot;,
  {
    variants: {
      variant: {
        default:
          &quot;bg-primary text-primary-foreground shadow-xs hover:bg-primary/90&quot;,
        destructive:
          &quot;bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60&quot;,
        outline:
          &quot;border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50&quot;,
        secondary:
          &quot;bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80&quot;,
        ghost:
          &quot;hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50&quot;,
        link: &quot;text-primary underline-offset-4 hover:underline&quot;,
      },
      size: {
        default: &quot;h-9 px-4 py-2 has-[&gt;svg]:px-3&quot;,
        sm: &quot;h-8 rounded-md gap-1.5 px-3 has-[&gt;svg]:px-2.5&quot;,
        lg: &quot;h-10 rounded-md px-6 has-[&gt;svg]:px-4&quot;,
        icon: &quot;size-9&quot;,
      },
    },
    defaultVariants: {
      variant: &quot;default&quot;,
      size: &quot;default&quot;,
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps&lt;&quot;button&quot;&gt; &amp;
  VariantProps&lt;typeof buttonVariants&gt; &amp; {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : &quot;button&quot;

  return (
    &lt;Comp
      data-slot=&quot;button&quot;
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    /&gt;
  )
}

export { Button, buttonVariants }
</content>
    </document>

    <document>
      <source>src/components/ui/badge.tsx</source>
      <tags></tags>
      <metadata>
        <size>1631</size>
        <lastModified>2025-05-29T08:13:25.456Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import { Slot } from &quot;@radix-ui/react-slot&quot;
import { cva, type VariantProps } from &quot;class-variance-authority&quot;

import { cn } from &quot;@/lib/utils&quot;

const badgeVariants = cva(
  &quot;inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&amp;&gt;svg]:size-3 gap-1 [&amp;&gt;svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden&quot;,
  {
    variants: {
      variant: {
        default:
          &quot;border-transparent bg-primary text-primary-foreground [a&amp;]:hover:bg-primary/90&quot;,
        secondary:
          &quot;border-transparent bg-secondary text-secondary-foreground [a&amp;]:hover:bg-secondary/90&quot;,
        destructive:
          &quot;border-transparent bg-destructive text-white [a&amp;]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60&quot;,
        outline:
          &quot;text-foreground [a&amp;]:hover:bg-accent [a&amp;]:hover:text-accent-foreground&quot;,
      },
    },
    defaultVariants: {
      variant: &quot;default&quot;,
    },
  }
)

function Badge({
  className,
  variant,
  asChild = false,
  ...props
}: React.ComponentProps&lt;&quot;span&quot;&gt; &amp;
  VariantProps&lt;typeof badgeVariants&gt; &amp; { asChild?: boolean }) {
  const Comp = asChild ? Slot : &quot;span&quot;

  return (
    &lt;Comp
      data-slot=&quot;badge&quot;
      className={cn(badgeVariants({ variant }), className)}
      {...props}
    /&gt;
  )
}

export { Badge, badgeVariants }
</content>
    </document>

    <document>
      <source>src/components/ui/avatar.tsx</source>
      <tags></tags>
      <metadata>
        <size>1097</size>
        <lastModified>2025-05-29T08:13:25.444Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>&quot;use client&quot;

import * as React from &quot;react&quot;
import * as AvatarPrimitive from &quot;@radix-ui/react-avatar&quot;

import { cn } from &quot;@/lib/utils&quot;

function Avatar({
  className,
  ...props
}: React.ComponentProps&lt;typeof AvatarPrimitive.Root&gt;) {
  return (
    &lt;AvatarPrimitive.Root
      data-slot=&quot;avatar&quot;
      className={cn(
        &quot;relative flex size-8 shrink-0 overflow-hidden rounded-full&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps&lt;typeof AvatarPrimitive.Image&gt;) {
  return (
    &lt;AvatarPrimitive.Image
      data-slot=&quot;avatar-image&quot;
      className={cn(&quot;aspect-square size-full&quot;, className)}
      {...props}
    /&gt;
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps&lt;typeof AvatarPrimitive.Fallback&gt;) {
  return (
    &lt;AvatarPrimitive.Fallback
      data-slot=&quot;avatar-fallback&quot;
      className={cn(
        &quot;bg-muted flex size-full items-center justify-center rounded-full&quot;,
        className
      )}
      {...props}
    /&gt;
  )
}

export { Avatar, AvatarImage, AvatarFallback }
</content>
    </document>

    <document>
      <source>src/components/ui/scroll-area.tsx</source>
      <tags></tags>
      <metadata>
        <size>1631</size>
        <lastModified>2025-05-29T08:13:25.435Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/ui</directory>
      </metadata>
      <content>import * as React from &quot;react&quot;
import * as ScrollAreaPrimitive from &quot;@radix-ui/react-scroll-area&quot;

import { cn } from &quot;@/lib/utils&quot;

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps&lt;typeof ScrollAreaPrimitive.Root&gt;) {
  return (
    &lt;ScrollAreaPrimitive.Root
      data-slot=&quot;scroll-area&quot;
      className={cn(&quot;relative&quot;, className)}
      {...props}
    &gt;
      &lt;ScrollAreaPrimitive.Viewport
        data-slot=&quot;scroll-area-viewport&quot;
        className=&quot;focus-visible:ring-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] outline-none focus-visible:ring-[3px] focus-visible:outline-1&quot;
      &gt;
        {children}
      &lt;/ScrollAreaPrimitive.Viewport&gt;
      &lt;ScrollBar /&gt;
      &lt;ScrollAreaPrimitive.Corner /&gt;
    &lt;/ScrollAreaPrimitive.Root&gt;
  )
}

function ScrollBar({
  className,
  orientation = &quot;vertical&quot;,
  ...props
}: React.ComponentProps&lt;typeof ScrollAreaPrimitive.ScrollAreaScrollbar&gt;) {
  return (
    &lt;ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot=&quot;scroll-area-scrollbar&quot;
      orientation={orientation}
      className={cn(
        &quot;flex touch-none p-px transition-colors select-none&quot;,
        orientation === &quot;vertical&quot; &amp;&amp;
          &quot;h-full w-2.5 border-l border-l-transparent&quot;,
        orientation === &quot;horizontal&quot; &amp;&amp;
          &quot;h-2.5 flex-col border-t border-t-transparent&quot;,
        className
      )}
      {...props}
    &gt;
      &lt;ScrollAreaPrimitive.ScrollAreaThumb
        data-slot=&quot;scroll-area-thumb&quot;
        className=&quot;bg-border relative flex-1 rounded-full&quot;
      /&gt;
    &lt;/ScrollAreaPrimitive.ScrollAreaScrollbar&gt;
  )
}

export { ScrollArea, ScrollBar }
</content>
    </document>

    <document>
      <source>src/components/views/MiningView.tsx</source>
      <tags></tags>
      <metadata>
        <size>1724</size>
        <lastModified>2025-05-29T05:11:37.300Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/views</directory>
      </metadata>
      <content>// src/components/views/MiningView.tsx
import { Button } from &#39;@/components/ui/button&#39;
import { ArrowLeft, Pickaxe, Loader2 } from &#39;lucide-react&#39;
import type { Character } from &#39;@/types&#39;

interface MiningViewProps {
  character: Character
  loadingItems: Set&lt;string&gt;
  onBack: () =&gt; void
  onMine: () =&gt; void
}

export function MiningView({ character, loadingItems, onBack, onMine }: MiningViewProps) {
  const isMining = loadingItems.has(&#39;mining-action&#39;)
  const canMine = character.energy &gt;= 10 &amp;&amp; !isMining

  return (
    &lt;div className=&quot;space-y-4&quot;&gt;
      &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;Mining in {character.currentLocation.name}&lt;/h3&gt;
      &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;
        Search for resources. Each attempt costs 10 energy.
      &lt;/p&gt;

      &lt;div className=&quot;bg-muted/50 p-4 rounded-lg&quot;&gt;
        &lt;h4 className=&quot;font-medium mb-2&quot;&gt;Available Resources:&lt;/h4&gt;
        &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;
          Resources vary by location. Try your luck!
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;Button onClick={onMine} className=&quot;w-full&quot; disabled={!canMine}&gt;
        {isMining ? (
          &lt;&gt;
            &lt;Loader2 className=&quot;w-4 h-4 mr-2 animate-spin&quot; /&gt;
            Mining...
          &lt;/&gt;
        ) : (
          &lt;&gt;
            &lt;Pickaxe className=&quot;w-4 h-4 mr-2&quot; /&gt;
            Mine for Resources
          &lt;/&gt;
        )}
      &lt;/Button&gt;

      {character.energy &lt; 10 &amp;&amp; !isMining &amp;&amp; (
        &lt;p className=&quot;text-sm text-center text-muted-foreground&quot;&gt;
          Not enough energy! Use an Energy Drink to restore energy.
        &lt;/p&gt;
      )}

      &lt;Button onClick={onBack} variant=&quot;ghost&quot;&gt;
        &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
        Back
      &lt;/Button&gt;
    &lt;/div&gt;
  )
}
</content>
    </document>

    <document>
      <source>src/components/views/MarketView.tsx</source>
      <tags></tags>
      <metadata>
        <size>6173</size>
        <lastModified>2025-05-29T04:43:00.072Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/views</directory>
      </metadata>
      <content>// src/components/views/MarketView.tsx
import { useState } from &#39;react&#39;
import { Button } from &#39;@/components/ui/button&#39;
import { ArrowLeft, Store, Coins, Loader2 } from &#39;lucide-react&#39;
import type { Character, Location, MarketItem } from &#39;@/types&#39;

interface MarketViewProps {
  character: Character
  selectedLocation: Location | null
  locations: Location[]
  marketItems: MarketItem[]
  loadingItems: Set&lt;string&gt;
  onBack: () =&gt; void
  onPurchase: (marketListingId: string, price: number, itemName: string) =&gt; void
}

export function MarketView({
  character,
  selectedLocation,
  locations,
  marketItems,
  loadingItems,
  onBack,
  onPurchase
}: MarketViewProps) {
  const [activeTab, setActiveTab] = useState&lt;&#39;local&#39; | &#39;global&#39;&gt;(&#39;local&#39;)

  // Determine if we&#39;re at a child location (has parent location)
  const currentLoc = selectedLocation || character?.currentLocation
  const isChildLocation = currentLoc &amp;&amp; locations.find(loc =&gt;
    loc.subLocations?.some(sub =&gt; sub.id === currentLoc.id)
  )

  // Filter market items by tab
  const localItems = marketItems.filter(item =&gt; item.isLocalSpecialty || false)
  const globalItems = marketItems.filter(item =&gt; !item.isLocalSpecialty)

  const activeItems = activeTab === &#39;local&#39; ? localItems : globalItems

  return (
    &lt;div className=&quot;space-y-4&quot;&gt;
      &lt;div className=&quot;text-center&quot;&gt;
        &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;Market - {currentLoc?.name}&lt;/h3&gt;
        {isChildLocation &amp;&amp; (
          &lt;p className=&quot;text-xs text-muted-foreground&quot;&gt;
            Unique local items + supplies from the main settlement
          &lt;/p&gt;
        )}
      &lt;/div&gt;

      {/* Tab Navigation - only show if child location */}
      {isChildLocation &amp;&amp; (
        &lt;div className=&quot;flex border-b&quot;&gt;
          &lt;button
            className={`flex-1 py-2 px-4 text-sm font-medium border-b-2 transition-colors ${activeTab === &#39;local&#39;
              ? &#39;border-primary text-primary bg-primary/5&#39;
              : &#39;border-transparent text-muted-foreground hover:text-foreground&#39;
              }`}
            onClick={() =&gt; setActiveTab(&#39;local&#39;)}
          &gt;
            Local Specialties
            {localItems.length &gt; 0 &amp;&amp; (
              &lt;span className=&quot;ml-1 text-xs bg-primary/20 text-primary px-1.5 py-0.5 rounded-full&quot;&gt;
                {localItems.length}
              &lt;/span&gt;
            )}
          &lt;/button&gt;
          &lt;button
            className={`flex-1 py-2 px-4 text-sm font-medium border-b-2 transition-colors ${activeTab === &#39;global&#39;
              ? &#39;border-primary text-primary bg-primary/5&#39;
              : &#39;border-transparent text-muted-foreground hover:text-foreground&#39;
              }`}
            onClick={() =&gt; setActiveTab(&#39;global&#39;)}
          &gt;
            Global Market
            {globalItems.length &gt; 0 &amp;&amp; (
              &lt;span className=&quot;ml-1 text-xs bg-muted text-muted-foreground px-1.5 py-0.5 rounded-full&quot;&gt;
                {globalItems.length}
              &lt;/span&gt;
            )}
          &lt;/button&gt;
        &lt;/div&gt;
      )}

      {/* Market Items */}
      &lt;div className=&quot;space-y-2&quot;&gt;
        {activeItems.length &gt; 0 ? (
          activeItems.map((marketItem) =&gt; {
            const isLoading = loadingItems.has(marketItem.id)

            return (
              &lt;div key={marketItem.id} className=&quot;flex items-center justify-between p-3 bg-muted/50 rounded-lg&quot;&gt;
                &lt;div className=&quot;flex items-center gap-3&quot;&gt;
                  &lt;div className=&quot;w-8 h-8 bg-muted rounded flex items-center justify-center text-xs&quot;&gt;
                    {marketItem.item.category === &#39;HAT&#39; ? &#39;üé©&#39; :
                      marketItem.item.category === &#39;CONSUMABLE&#39; ? &#39;ü•§&#39; :
                        marketItem.isLocalSpecialty ? &#39;‚ú®&#39; : &#39;üì¶&#39;}
                  &lt;/div&gt;
                  &lt;div&gt;
                    &lt;div className=&quot;font-medium flex items-center gap-2&quot;&gt;
                      {marketItem.item.name}
                      {marketItem.isLocalSpecialty &amp;&amp; (
                        &lt;span className=&quot;text-xs bg-amber-100 text-amber-800 px-1.5 py-0.5 rounded-full&quot;&gt;
                          Local
                        &lt;/span&gt;
                      )}
                    &lt;/div&gt;
                    &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;{marketItem.item.description}&lt;/div&gt;
                    &lt;div className=&quot;text-xs text-muted-foreground capitalize&quot;&gt;
                      {marketItem.item.rarity} ‚Ä¢ Sold by {marketItem.isSystemItem ? &#39;System&#39; : marketItem.seller?.name}
                    &lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=&quot;text-right&quot;&gt;
                  &lt;div className=&quot;font-bold flex items-center gap-1&quot;&gt;
                    &lt;Coins className=&quot;w-3 h-3&quot; /&gt;
                    {marketItem.price}
                  &lt;/div&gt;
                  &lt;div className=&quot;text-xs text-muted-foreground mb-1&quot;&gt;
                    Qty: {marketItem.quantity &gt; 0 ? marketItem.quantity : &#39;Out of Stock&#39;}
                  &lt;/div&gt;
                  &lt;Button
                    size=&quot;sm&quot;
                    onClick={() =&gt; onPurchase(marketItem.id, marketItem.price, marketItem.item.name)}
                    disabled={marketItem.quantity === 0 || isLoading}
                  &gt;
                    {isLoading ? (
                      &lt;Loader2 className=&quot;w-3 h-3 animate-spin&quot; /&gt;
                    ) : marketItem.quantity &gt; 0 ? &#39;Buy&#39; : &#39;Sold Out&#39;}
                  &lt;/Button&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            )
          })
        ) : (
          &lt;div className=&quot;bg-muted/30 p-8 rounded-lg text-center text-muted-foreground&quot;&gt;
            &lt;Store className=&quot;w-12 h-12 mx-auto mb-2&quot; /&gt;
            {activeTab === &#39;local&#39; ? (
              &lt;&gt;
                No local specialties available.&lt;br /&gt;
                Check back later or try the global market.
              &lt;/&gt;
            ) : (
              &lt;&gt;
                No items available in the global market.&lt;br /&gt;
                The merchants might be restocking.
              &lt;/&gt;
            )}
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;Button onClick={onBack} variant=&quot;ghost&quot;&gt;
        &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
        Back
      &lt;/Button&gt;
    &lt;/div&gt;
  )
}
</content>
    </document>

    <document>
      <source>src/components/views/InventoryView.tsx</source>
      <tags></tags>
      <metadata>
        <size>10404</size>
        <lastModified>2025-05-29T11:14:50.302Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/views</directory>
      </metadata>
      <content>// src/components/views/InventoryView.tsx - Enhanced version
import { useState } from &#39;react&#39;
import { Button } from &#39;@/components/ui/button&#39;
import { ArrowLeft, Backpack, Loader2, Shield, Crown, Shirt, Gem, Package, Zap, Heart } from &#39;lucide-react&#39;
import type { Character } from &#39;@/types&#39;

interface InventoryViewProps {
  character: Character
  loadingItems: Set&lt;string&gt;
  onBack: () =&gt; void
  onUseItem: (inventoryId: string, itemName: string, energyEffect?: number, healthEffect?: number) =&gt; void
  onEquipItem: (inventoryId: string, isEquipped: boolean) =&gt; void
}

type InventoryTab = &#39;equipment&#39; | &#39;consumables&#39; | &#39;materials&#39; | &#39;all&#39;

// Equipment slot mapping
const EQUIPMENT_SLOTS = {
  HAT: { name: &#39;Head&#39;, icon: Crown, slot: &#39;head&#39; },
  CLOTHING: { name: &#39;Body&#39;, icon: Shirt, slot: &#39;body&#39; },
  ACCESSORY: { name: &#39;Accessory&#39;, icon: Gem, slot: &#39;accessory&#39; },
  TOOL: { name: &#39;Tool&#39;, icon: Shield, slot: &#39;tool&#39; },
} as const

export function InventoryView({
  character,
  loadingItems,
  onBack,
  onUseItem,
  onEquipItem
}: InventoryViewProps) {
  const [activeTab, setActiveTab] = useState&lt;InventoryTab&gt;(&#39;all&#39;)

  // Categorize inventory items
  const equipmentItems = character.inventory?.filter(inv =&gt;
    [&#39;HAT&#39;, &#39;CLOTHING&#39;, &#39;ACCESSORY&#39;, &#39;TOOL&#39;].includes(inv.item.category)
  ) || []

  const consumableItems = character.inventory?.filter(inv =&gt;
    inv.item.category === &#39;CONSUMABLE&#39;
  ) || []

  const materialItems = character.inventory?.filter(inv =&gt;
    inv.item.category === &#39;MATERIAL&#39;
  ) || []

  // Get items based on active tab
  const getActiveItems = () =&gt; {
    switch (activeTab) {
      case &#39;equipment&#39;: return equipmentItems
      case &#39;consumables&#39;: return consumableItems
      case &#39;materials&#39;: return materialItems
      case &#39;all&#39;: return character.inventory || []
      default: return character.inventory || []
    }
  }

  // Get equipped items by slot
  const getEquippedBySlot = (slot: string) =&gt; {
    return equipmentItems.find(inv =&gt;
      inv.isEquipped &amp;&amp; EQUIPMENT_SLOTS[inv.item.category as keyof typeof EQUIPMENT_SLOTS]?.slot === slot
    )
  }

  const renderEquipmentSlots = () =&gt; (
    &lt;div className=&quot;bg-muted/30 p-4 rounded-lg mb-4&quot;&gt;
      &lt;h4 className=&quot;font-medium mb-3 text-sm&quot;&gt;Equipment Slots&lt;/h4&gt;
      &lt;div className=&quot;grid grid-cols-2 gap-3&quot;&gt;
        {Object.entries(EQUIPMENT_SLOTS).map(([category, config]) =&gt; {
          const equippedItem = getEquippedBySlot(config.slot)
          const IconComponent = config.icon

          return (
            &lt;div
              key={config.slot}
              className={`border-2 border-dashed rounded-lg p-3 text-center transition-colors ${equippedItem
                ? &#39;border-primary bg-primary/5&#39;
                : &#39;border-muted-foreground/30 bg-muted/20&#39;
                }`}
            &gt;
              &lt;div className=&quot;flex flex-col items-center gap-1&quot;&gt;
                &lt;IconComponent className={`w-6 h-6 ${equippedItem ? &#39;text-primary&#39; : &#39;text-muted-foreground&#39;}`} /&gt;
                &lt;div className=&quot;text-xs font-medium&quot;&gt;{config.name}&lt;/div&gt;
                {equippedItem ? (
                  &lt;div className=&quot;text-xs text-center&quot;&gt;
                    &lt;div className=&quot;font-medium text-primary&quot;&gt;{equippedItem.item.name}&lt;/div&gt;
                    &lt;div className=&quot;text-muted-foreground capitalize&quot;&gt;{equippedItem.item.rarity}&lt;/div&gt;
                  &lt;/div&gt;
                ) : (
                  &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;Empty&lt;/div&gt;
                )}
              &lt;/div&gt;
            &lt;/div&gt;
          )
        })}
      &lt;/div&gt;
    &lt;/div&gt;
  )

  const renderInventoryItem = (inv: Character[&#39;inventory&#39;][0]) =&gt; {
    const isConsumable = inv.item.category === &#39;CONSUMABLE&#39;
    const energyEffect = inv.item.energyEffect || 0
    const healthEffect = inv.item.healthEffect || 0

    const wouldWasteEnergy = energyEffect &gt; 0 &amp;&amp; character.energy &gt;= 100
    const wouldWasteHealth = healthEffect &gt; 0 &amp;&amp; character.health &gt;= 100
    const wouldBeWasted = isConsumable &amp;&amp; (
      (energyEffect &gt; 0 &amp;&amp; wouldWasteEnergy) ||
      (healthEffect &gt; 0 &amp;&amp; wouldWasteHealth)
    )

    const isLoading = loadingItems.has(inv.id)

    return (
      &lt;div key={inv.id} className=&quot;flex items-center justify-between p-3 bg-muted/50 rounded-lg&quot;&gt;
        &lt;div className=&quot;flex items-center gap-3&quot;&gt;
          &lt;div className=&quot;w-10 h-10 bg-muted rounded-lg flex items-center justify-center text-sm&quot;&gt;
            {inv.item.category === &#39;HAT&#39; ? &#39;üé©&#39; :
              inv.item.category === &#39;CLOTHING&#39; ? &#39;üëï&#39; :
                inv.item.category === &#39;ACCESSORY&#39; ? &#39;üíé&#39; :
                  inv.item.category === &#39;TOOL&#39; ? &#39;üîß&#39; :
                    inv.item.category === &#39;MATERIAL&#39; ? &#39;‚ö°&#39; :
                      inv.item.category === &#39;CONSUMABLE&#39; ? &#39;ü•§&#39; : &#39;üì¶&#39;}
          &lt;/div&gt;
          &lt;div className=&quot;flex-1&quot;&gt;
            &lt;div className=&quot;font-medium flex items-center gap-2&quot;&gt;
              {inv.item.name}
              {inv.isEquipped &amp;&amp; (
                &lt;span className=&quot;text-xs bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-100 px-1.5 py-0.5 rounded-full&quot;&gt;
                  Equipped
                &lt;/span&gt;
              )}
            &lt;/div&gt;
            &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;{inv.item.description}&lt;/div&gt;

            {/* Show consumable effects */}
            {isConsumable &amp;&amp; (energyEffect &gt; 0 || healthEffect &gt; 0) &amp;&amp; (
              &lt;div className=&quot;text-xs text-green-600 mt-1 flex items-center gap-2&quot;&gt;
                {energyEffect &gt; 0 &amp;&amp; (
                  &lt;span className=&quot;flex items-center gap-1&quot;&gt;
                    &lt;Zap className=&quot;w-3 h-3&quot; /&gt;
                    +{energyEffect}
                  &lt;/span&gt;
                )}
                {healthEffect &gt; 0 &amp;&amp; (
                  &lt;span className=&quot;flex items-center gap-1&quot;&gt;
                    &lt;Heart className=&quot;w-3 h-3&quot; /&gt;
                    +{healthEffect}
                  &lt;/span&gt;
                )}
              &lt;/div&gt;
            )}

            &lt;div className=&quot;text-xs text-muted-foreground capitalize mt-1&quot;&gt;
              {inv.item.rarity} ‚Ä¢ Qty: {inv.quantity}
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div className=&quot;flex flex-col gap-1&quot;&gt;
          {/* Equipment Button */}
          {[&#39;HAT&#39;, &#39;CLOTHING&#39;, &#39;ACCESSORY&#39;, &#39;TOOL&#39;].includes(inv.item.category) &amp;&amp; (
            &lt;Button
              size=&quot;sm&quot;
              variant={inv.isEquipped ? &quot;default&quot; : &quot;outline&quot;}
              onClick={() =&gt; onEquipItem(inv.id, inv.isEquipped)}
              disabled={isLoading}
              className=&quot;text-xs px-2 py-1&quot;
            &gt;
              {isLoading ? (
                &lt;Loader2 className=&quot;w-3 h-3 animate-spin&quot; /&gt;
              ) : (
                inv.isEquipped ? &#39;Unequip&#39; : &#39;Equip&#39;
              )}
            &lt;/Button&gt;
          )}

          {/* Use Button for Consumables */}
          {isConsumable &amp;&amp; (
            &lt;Button
              size=&quot;sm&quot;
              variant=&quot;outline&quot;
              onClick={() =&gt; onUseItem(
                inv.id,
                inv.item.name,
                inv.item.energyEffect,
                inv.item.healthEffect
              )}
              disabled={wouldBeWasted || isLoading}
              title={wouldBeWasted ?
                `Already at full ${wouldWasteEnergy ? &#39;energy&#39; : &#39;health&#39;}` :
                `Use ${inv.item.name}`
              }
              className=&quot;text-xs px-2 py-1&quot;
            &gt;
              {isLoading ? (
                &lt;Loader2 className=&quot;w-3 h-3 animate-spin&quot; /&gt;
              ) : wouldBeWasted ? &#39;Full&#39; : &#39;Use&#39;}
            &lt;/Button&gt;
          )}
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }

  return (
    &lt;div className=&quot;space-y-4&quot;&gt;
      &lt;div className=&quot;flex items-center justify-between&quot;&gt;
        &lt;h3 className=&quot;text-lg font-semibold flex items-center gap-2&quot;&gt;
          &lt;Backpack className=&quot;w-5 h-5&quot; /&gt;
          Inventory
        &lt;/h3&gt;
        &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;
          {character.inventory?.length || 0} items
        &lt;/div&gt;
      &lt;/div&gt;

      {/* Equipment Slots - only show on equipment tab or all tab */}
      {(activeTab === &#39;equipment&#39; || activeTab === &#39;all&#39;) &amp;&amp; equipmentItems.length &gt; 0 &amp;&amp; renderEquipmentSlots()}

      {/* Tab Navigation */}
      &lt;div className=&quot;overflow-x-auto border-b&quot;&gt;
        &lt;div className=&quot;flex min-w-max&quot;&gt;
          {[
            { id: &#39;all&#39; as const, label: &#39;All&#39;, count: character.inventory?.length || 0, icon: Package },
            { id: &#39;equipment&#39; as const, label: &#39;Equipment&#39;, count: equipmentItems.length, icon: Shield },
            { id: &#39;consumables&#39; as const, label: &#39;Consumables&#39;, count: consumableItems.length, icon: Zap },
            { id: &#39;materials&#39; as const, label: &#39;Materials&#39;, count: materialItems.length, icon: Gem },
          ].map(tab =&gt; {
            const IconComponent = tab.icon
            return (
              &lt;button
                key={tab.id}
                className={`py-2 px-4 text-sm font-medium border-b-2 transition-colors flex items-center gap-1 whitespace-nowrap ${activeTab === tab.id
                  ? &#39;border-primary text-primary bg-primary/5&#39;
                  : &#39;border-transparent text-muted-foreground hover:text-foreground&#39;
                  }`}
                onClick={() =&gt; setActiveTab(tab.id)}
              &gt;
                &lt;IconComponent className=&quot;w-4 h-4&quot; /&gt;
                &lt;span&gt;{tab.label}&lt;/span&gt;
                {tab.count &gt; 0 &amp;&amp; (
                  &lt;span className=&quot;ml-1 text-xs bg-muted text-muted-foreground px-1.5 py-0.5 rounded-full&quot;&gt;
                    {tab.count}
                  &lt;/span&gt;
                )}
              &lt;/button&gt;
            )
          })}
        &lt;/div&gt;
      &lt;/div&gt;

      {/* Inventory Items */}
      &lt;div className=&quot;space-y-2&quot;&gt;
        {getActiveItems().length &gt; 0 ? (
          getActiveItems().map(renderInventoryItem)
        ) : (
          &lt;div className=&quot;bg-muted/50 p-8 rounded-lg text-center text-muted-foreground&quot;&gt;
            &lt;Package className=&quot;w-12 h-12 mx-auto mb-2&quot; /&gt;
            {activeTab === &#39;all&#39; ? (
              &lt;&gt;Your bag is empty.&lt;br /&gt;Start mining or visit the market!&lt;/&gt;
            ) : (
              &lt;&gt;No {activeTab} items found.&lt;br /&gt;Try a different tab or go mining!&lt;/&gt;
            )}
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;Button onClick={onBack} variant=&quot;ghost&quot;&gt;
        &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
        Back
      &lt;/Button&gt;
    &lt;/div&gt;
  )
}
</content>
    </document>

    <document>
      <source>src/components/views/WorldMapView.tsx</source>
      <tags></tags>
      <metadata>
        <size>22798</size>
        <lastModified>2025-05-29T12:27:30.500Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components/views</directory>
      </metadata>
      <content>import { useState, useRef, useEffect } from &#39;react&#39;
import { Tooltip, TooltipTrigger, TooltipContent } from &quot;@/components/ui/tooltip&quot;
import { Users, MapPin, Star } from &#39;lucide-react&#39;

interface Location {
  id: string
  name: string
  description?: string
  mapX?: number
  mapY?: number
  biome?: string
  difficulty: number
  playerCount: number
  locationType: string
  subLocations?: Location[]
  parentLocationId?: string
}

interface WorldMapViewProps {
  locations: Location[]
  onLocationSelect?: (location: Location) =&gt; void
  currentLocationId?: string
}

// Enhanced coordinate system - normalized to 0-100 for responsive scaling
const LOCATION_COORDINATES = {
  &#39;Mining Plains&#39;: { x: 20, y: 40 },
  &#39;Desert Outpost&#39;: { x: 80, y: 20 },
  &#39;Cyber City&#39;: { x: 60, y: 60 },
  &#39;The Glitch Wastes&#39;: { x: 85, y: 75 },
  &#39;Fungi Networks&#39;: { x: 15, y: 75 },
  &#39;Temporal Rift Zone&#39;: { x: 75, y: 45 },
  &#39;The Bone Markets&#39;: { x: 25, y: 15 },
  &#39;Static Fields&#39;: { x: 45, y: 25 },
}

// Sub-location offsets relative to parent (in percentage points)
const SUB_LOCATION_OFFSETS = {
  &#39;Rusty Pickaxe Inn&#39;: { x: -8, y: -5 },
  &#39;Crystal Caves&#39;: { x: 5, y: 8 },
  &#39;Central Exchange&#39;: { x: -6, y: -8 },
  &#39;The Glitch Club&#39;: { x: 8, y: 6 },
  &#39;Error 404 Oasis&#39;: { x: -10, y: 8 },
  &#39;Corrupted Data Mines&#39;: { x: 6, y: -6 },
  &#39;Spore Exchange&#39;: { x: -7, y: 10 },
  &#39;The Great Mycelium&#39;: { x: 9, y: -4 },
  &quot;Yesterday&#39;s Tomorrow&quot;: { x: -9, y: 7 },
  &#39;Clock Tower Ruins&#39;: { x: 7, y: -9 },
  &#39;Calcium Exchange&#39;: { x: -6, y: 9 },
  &#39;Ossuary Club&#39;: { x: 8, y: -5 },
  &#39;Channel 0&#39;: { x: -8, y: 8 },
  &#39;Dead Air Tavern&#39;: { x: 6, y: -7 },
}

function getBiomeColor(biome?: string) {
  switch (biome) {
    case &#39;plains&#39;: return &#39;#eee&#39;
    case &#39;desert&#39;: return &#39;#ddd&#39;
    case &#39;urban&#39;: return &#39;#4a90e2&#39;
    case &#39;digital&#39;: return &#39;#ff6b9d&#39;
    case &#39;underground&#39;: return &#39;#8b4513&#39;
    case &#39;temporal&#39;: return &#39;#9370db&#39;
    case &#39;ossuary&#39;: return &#39;#dcdcdc&#39;
    case &#39;electromagnetic&#39;: return &#39;#00ffff&#39;
    default: return &#39;#888888&#39;
  }
}

function getDifficultyIcon(difficulty: number) {
  if (difficulty &lt;= 2) return &#39;üü¢&#39;
  if (difficulty &lt;= 4) return &#39;üü°&#39;
  return &#39;üî¥&#39;
}

export function WorldMapView({ locations, onLocationSelect, currentLocationId }: WorldMapViewProps) {
  const [mapDimensions, setMapDimensions] = useState({ width: 800, height: 600 })
  const mapRef = useRef&lt;HTMLDivElement&gt;(null)

  useEffect(() =&gt; {
    const updateDimensions = () =&gt; {
      if (mapRef.current) {
        const container = mapRef.current.parentElement
        if (container) {
          const width = Math.min(container.clientWidth - 32, 1000) // Max width with padding
          const height = Math.max(width * 0.6, 400) // Maintain aspect ratio with minimum height
          setMapDimensions({ width, height })
        }
      }
    }

    updateDimensions()
    window.addEventListener(&#39;resize&#39;, updateDimensions)
    return () =&gt; window.removeEventListener(&#39;resize&#39;, updateDimensions)
  }, [])

  // Separate parent and child locations
  const parentLocations = locations.filter(loc =&gt; !loc.parentLocationId)

  const getLocationPosition = (location: Location) =&gt; {
    const coords = LOCATION_COORDINATES[location.name as keyof typeof LOCATION_COORDINATES]
    if (coords) {
      return {
        x: (coords.x / 100) * mapDimensions.width,
        y: (coords.y / 100) * mapDimensions.height
      }
    }

    // Fallback to original coordinates if available
    if (location.mapX &amp;&amp; location.mapY) {
      return {
        x: Math.min(location.mapX, mapDimensions.width - 20),
        y: Math.min(location.mapY, mapDimensions.height - 20)
      }
    }

    // Random fallback
    return {
      x: Math.random() * (mapDimensions.width - 40) + 20,
      y: Math.random() * (mapDimensions.height - 40) + 20
    }
  }

  const getSubLocationPosition = (subLocation: Location, parentPosition: { x: number, y: number }) =&gt; {
    const offset = SUB_LOCATION_OFFSETS[subLocation.name as keyof typeof SUB_LOCATION_OFFSETS]
    if (offset) {
      return {
        x: parentPosition.x + (offset.x / 100) * mapDimensions.width,
        y: parentPosition.y + (offset.y / 100) * mapDimensions.height
      }
    }

    // Fallback: random position around parent
    const angle = Math.random() * 2 * Math.PI
    const distance = 40 + Math.random() * 20
    return {
      x: parentPosition.x + Math.cos(angle) * distance,
      y: parentPosition.y + Math.sin(angle) * distance
    }
  }

  const renderConnectingLine = (parent: { x: number, y: number }, child: { x: number, y: number }) =&gt; (
    &lt;line
      key={`line-${parent.x}-${parent.y}-${child.x}-${child.y}`}
      x1={parent.x}
      y1={parent.y}
      x2={child.x}
      y2={child.y}
      stroke=&quot;rgba(148, 163, 184, 0.4)&quot;
      strokeWidth=&quot;2&quot;
      strokeDasharray=&quot;4,4&quot;
    /&gt;
  )

  // Custom landmass shapes for each major location
  const getLandmassPath = (locationName: string, position: { x: number, y: number }) =&gt; {
    const { x, y } = position
    const scale = 1.2 // Make landmasses a bit larger

    switch (locationName) {
      case &#39;Mining Plains&#39;:
        // Rolling hills shape
        return `M ${x - 40 * scale} ${y + 10 * scale} 
                Q ${x - 30 * scale} ${y - 20 * scale} ${x - 10 * scale} ${y - 15 * scale}
                Q ${x + 5 * scale} ${y - 25 * scale} ${x + 25 * scale} ${y - 10 * scale}
                Q ${x + 35 * scale} ${y + 5 * scale} ${x + 30 * scale} ${y + 20 * scale}
                Q ${x + 10 * scale} ${y + 25 * scale} ${x - 15 * scale} ${y + 15 * scale}
                Q ${x - 35 * scale} ${y + 20 * scale} ${x - 40 * scale} ${y + 10 * scale} Z`

      case &#39;Desert Outpost&#39;:
        // Jagged desert shape
        return `M ${x - 35 * scale} ${y - 5 * scale}
                L ${x - 20 * scale} ${y - 25 * scale}
                L ${x - 5 * scale} ${y - 20 * scale}
                L ${x + 10 * scale} ${y - 30 * scale}
                L ${x + 30 * scale} ${y - 15 * scale}
                L ${x + 35 * scale} ${y + 5 * scale}
                L ${x + 25 * scale} ${y + 20 * scale}
                L ${x + 5 * scale} ${y + 25 * scale}
                L ${x - 20 * scale} ${y + 15 * scale}
                L ${x - 35 * scale} ${y - 5 * scale} Z`

      case &#39;Cyber City&#39;:
        // Geometric city shape
        return `M ${x - 30 * scale} ${y - 20 * scale}
                L ${x - 15 * scale} ${y - 25 * scale}
                L ${x + 15 * scale} ${y - 25 * scale}
                L ${x + 30 * scale} ${y - 20 * scale}
                L ${x + 35 * scale} ${y - 5 * scale}
                L ${x + 30 * scale} ${y + 15 * scale}
                L ${x + 10 * scale} ${y + 25 * scale}
                L ${x - 10 * scale} ${y + 25 * scale}
                L ${x - 30 * scale} ${y + 15 * scale}
                L ${x - 35 * scale} ${y - 5 * scale}
                L ${x - 30 * scale} ${y - 20 * scale} Z`

      case &#39;The Glitch Wastes&#39;:
        // Fragmented, corrupted shape
        return `M ${x - 25 * scale} ${y - 15 * scale}
                L ${x - 10 * scale} ${y - 30 * scale}
                L ${x + 5 * scale} ${y - 25 * scale}
                L ${x + 20 * scale} ${y - 35 * scale}
                L ${x + 35 * scale} ${y - 10 * scale}
                L ${x + 30 * scale} ${y + 10 * scale}
                L ${x + 15 * scale} ${y + 25 * scale}
                L ${x - 5 * scale} ${y + 30 * scale}
                L ${x - 25 * scale} ${y + 20 * scale}
                L ${x - 35 * scale} ${y + 5 * scale}
                L ${x - 25 * scale} ${y - 15 * scale} Z`

      case &#39;Fungi Networks&#39;:
        // Organic, mushroom-like shape
        return `M ${x - 20 * scale} ${y - 10 * scale}
                Q ${x - 35 * scale} ${y - 20 * scale} ${x - 30 * scale} ${y - 5 * scale}
                Q ${x - 40 * scale} ${y + 10 * scale} ${x - 25 * scale} ${y + 15 * scale}
                Q ${x - 15 * scale} ${y + 30 * scale} ${x + 5 * scale} ${y + 25 * scale}
                Q ${x + 25 * scale} ${y + 20 * scale} ${x + 30 * scale} ${y + 5 * scale}
                Q ${x + 35 * scale} ${y - 15 * scale} ${x + 15 * scale} ${y - 20 * scale}
                Q ${x - 5 * scale} ${y - 25 * scale} ${x - 20 * scale} ${y - 10 * scale} Z`

      case &#39;Temporal Rift Zone&#39;:
        // Twisted, time-distorted shape
        return `M ${x - 30 * scale} ${y - 10 * scale}
                Q ${x - 20 * scale} ${y - 30 * scale} ${x + 5 * scale} ${y - 25 * scale}
                Q ${x + 25 * scale} ${y - 35 * scale} ${x + 35 * scale} ${y - 5 * scale}
                Q ${x + 40 * scale} ${y + 15 * scale} ${x + 20 * scale} ${y + 25 * scale}
                Q ${x - 5 * scale} ${y + 35 * scale} ${x - 25 * scale} ${y + 20 * scale}
                Q ${x - 40 * scale} ${y + 5 * scale} ${x - 30 * scale} ${y - 10 * scale} Z`

      case &#39;The Bone Markets&#39;:
        // Skull-like shape
        return `M ${x - 25 * scale} ${y - 20 * scale}
                Q ${x - 35 * scale} ${y - 25 * scale} ${x - 30 * scale} ${y - 5 * scale}
                Q ${x - 35 * scale} ${y + 15 * scale} ${x - 15 * scale} ${y + 25 * scale}
                L ${x + 15 * scale} ${y + 25 * scale}
                Q ${x + 35 * scale} ${y + 15 * scale} ${x + 30 * scale} ${y - 5 * scale}
                Q ${x + 35 * scale} ${y - 25 * scale} ${x + 25 * scale} ${y - 20 * scale}
                Q ${x} ${y - 30 * scale} ${x - 25 * scale} ${y - 20 * scale} Z`

      case &#39;Static Fields&#39;:
        // Jagged, electric shape
        return `M ${x - 30 * scale} ${y - 15 * scale}
                L ${x - 15 * scale} ${y - 30 * scale}
                L ${x - 5 * scale} ${y - 20 * scale}
                L ${x + 10 * scale} ${y - 35 * scale}
                L ${x + 25 * scale} ${y - 25 * scale}
                L ${x + 35 * scale} ${y - 10 * scale}
                L ${x + 25 * scale} ${y + 5 * scale}
                L ${x + 35 * scale} ${y + 20 * scale}
                L ${x + 15 * scale} ${y + 30 * scale}
                L ${x - 5 * scale} ${y + 20 * scale}
                L ${x - 20 * scale} ${y + 25 * scale}
                L ${x - 35 * scale} ${y + 10 * scale}
                L ${x - 30 * scale} ${y - 15 * scale} Z`

      default:
        // Fallback generic landmass
        return `M ${x - 30 * scale} ${y - 15 * scale}
                Q ${x - 15 * scale} ${y - 25 * scale} ${x + 15 * scale} ${y - 25 * scale}
                Q ${x + 30 * scale} ${y - 15 * scale} ${x + 30 * scale} ${y + 15 * scale}
                Q ${x + 15 * scale} ${y + 25 * scale} ${x - 15 * scale} ${y + 25 * scale}
                Q ${x - 30 * scale} ${y + 15 * scale} ${x - 30 * scale} ${y - 15 * scale} Z`
    }
  }

  const renderLocationNode = (
    location: Location,
    position: { x: number, y: number },
    isParent: boolean = false
  ) =&gt; {
    const isCurrentLocation = location.id === currentLocationId
    const color = getBiomeColor(location.biome)

    if (isParent) {
      // Render landmass for major locations
      const landmassPath = getLandmassPath(location.name, position)

      return (
        &lt;g key={location.id}&gt;
          {/* Glow effect for current location */}
          {isCurrentLocation &amp;&amp; (
            &lt;path
              d={landmassPath}
              fill=&quot;none&quot;
              stroke=&quot;#fbbf24&quot;
              strokeWidth=&quot;4&quot;
              opacity=&quot;0.8&quot;
              filter=&quot;blur(2px)&quot;
            /&gt;
          )}

          {/* Main landmass */}
          &lt;path
            d={landmassPath}
            fill={color}
            stroke={isCurrentLocation ? &quot;#fbbf24&quot; : &quot;#374151&quot;}
            strokeWidth={isCurrentLocation ? 3 : 2}
            className=&quot;cursor-pointer hover:stroke-blue-400 transition-colors&quot;
            onClick={() =&gt; onLocationSelect?.(location)}
            opacity=&quot;0.9&quot;
          /&gt;

          {/* Subtle inner shadow for depth */}
          &lt;path
            d={landmassPath}
            fill=&quot;none&quot;
            stroke=&quot;rgba(0,0,0,0.2)&quot;
            strokeWidth=&quot;1&quot;
            strokeDasharray=&quot;2,2&quot;
            opacity=&quot;0.3&quot;
          /&gt;

          {/* Location name label */}
          &lt;text
            x={position.x}
            y={position.y - 35}
            textAnchor=&quot;middle&quot;
            fontSize=&quot;12&quot;
            fontWeight=&quot;bold&quot;
            fill=&quot;#374151&quot;
            className=&quot;pointer-events-none drop-shadow-sm&quot;
          &gt;
            {location.name}
          &lt;/text&gt;

          {/* Difficulty indicator */}
          &lt;circle
            cx={position.x + 35}
            cy={position.y - 25}
            r={10}
            fill=&quot;white&quot;
            stroke=&quot;#374151&quot;
            strokeWidth=&quot;2&quot;
          /&gt;
          &lt;text
            x={position.x + 35}
            y={position.y - 25}
            textAnchor=&quot;middle&quot;
            dominantBaseline=&quot;central&quot;
            fontSize=&quot;12&quot;
            className=&quot;pointer-events-none&quot;
          &gt;
            {getDifficultyIcon(location.difficulty)}
          &lt;/text&gt;

          {/* Player count indicator */}
          {location.playerCount &gt; 0 &amp;&amp; (
            &lt;&gt;
              &lt;circle
                cx={position.x - 35}
                cy={position.y + 25}
                r={12}
                fill=&quot;#3b82f6&quot;
                stroke=&quot;white&quot;
                strokeWidth=&quot;2&quot;
              /&gt;
              &lt;text
                x={position.x - 35}
                y={position.y + 25}
                textAnchor=&quot;middle&quot;
                dominantBaseline=&quot;central&quot;
                fontSize=&quot;10&quot;
                fill=&quot;white&quot;
                className=&quot;font-bold pointer-events-none&quot;
              &gt;
                {location.playerCount}
              &lt;/text&gt;
            &lt;/&gt;
          )}
        &lt;/g&gt;
      )
    } else {
      // Render simple square for sub-locations
      const squareSize = 16

      return (
        &lt;g key={location.id}&gt;
          {/* Glow effect for current location */}
          {isCurrentLocation &amp;&amp; (
            &lt;rect
              x={position.x - squareSize - 4}
              y={position.y - squareSize - 4}
              width={(squareSize + 4) * 2}
              height={(squareSize + 4) * 2}
              fill=&quot;none&quot;
              stroke=&quot;#fbbf24&quot;
              strokeWidth=&quot;3&quot;
              opacity=&quot;0.6&quot;
              rx=&quot;2&quot;
            /&gt;
          )}

          {/* Main square */}
          &lt;rect
            x={position.x - squareSize}
            y={position.y - squareSize}
            width={squareSize * 2}
            height={squareSize * 2}
            fill={color}
            stroke={isCurrentLocation ? &quot;#fbbf24&quot; : &quot;#374151&quot;}
            strokeWidth={isCurrentLocation ? 1 : 0}
            rx=&quot;2&quot;
            className=&quot;cursor-pointer hover:stroke-blue-400 transition-colors&quot;
            onClick={() =&gt; onLocationSelect?.(location)}
          /&gt;

          {/* Difficulty indicator */}
          &lt;circle
            cx={position.x + squareSize + 8}
            cy={position.y - squareSize - 8}
            r={4}
            fill=&quot;white&quot;
            stroke=&quot;#374151&quot;
            strokeWidth=&quot;0&quot;
          /&gt;
          &lt;text
            x={position.x + squareSize + 8}
            y={position.y - squareSize - 8}
            textAnchor=&quot;middle&quot;
            dominantBaseline=&quot;central&quot;
            fontSize=&quot;10&quot;
            className=&quot;pointer-events-none&quot;
          &gt;
            {getDifficultyIcon(location.difficulty)}
          &lt;/text&gt;

          {/* Player count indicator */}
          {location.playerCount &gt; 0 &amp;&amp; (
            &lt;&gt;
              &lt;circle
                cx={position.x - squareSize - 8}
                cy={position.y + squareSize + 8}
                r={8}
                fill=&quot;#3b82f6&quot;
                stroke=&quot;white&quot;
                strokeWidth=&quot;2&quot;
              /&gt;
              &lt;text
                x={position.x - squareSize - 8}
                y={position.y + squareSize + 8}
                textAnchor=&quot;middle&quot;
                dominantBaseline=&quot;central&quot;
                fontSize=&quot;8&quot;
                fill=&quot;white&quot;
                className=&quot;font-bold pointer-events-none&quot;
              &gt;
                {location.playerCount}
              &lt;/text&gt;
            &lt;/&gt;
          )}
        &lt;/g&gt;
      )
    }
  }

  return (
    &lt;div className=&quot;w-full&quot;&gt;
      &lt;div
        ref={mapRef}
        className=&quot;relative w-full bg-gradient-to-br from-slate-100 to-slate-200 dark:from-slate-800 dark:to-slate-900 rounded-lg border overflow-hidden&quot;
        style={{ height: mapDimensions.height }}
      &gt;
        {/* Background pattern */}
        &lt;div
          className=&quot;absolute inset-0 opacity-10&quot;
          style={{
            backgroundImage: `radial-gradient(circle at 2px 2px, rgba(148, 163, 184, 0.3) 1px, transparent 0)`,
            backgroundSize: &#39;20px 20px&#39;
          }}
        /&gt;

        &lt;svg
          width={mapDimensions.width}
          height={mapDimensions.height}
          className=&quot;absolute inset-0&quot;
        &gt;
          &lt;defs&gt;
            &lt;filter id=&quot;glow&quot;&gt;
              &lt;feGaussianBlur stdDeviation=&quot;3&quot; result=&quot;coloredBlur&quot; /&gt;
              &lt;feMerge&gt;
                &lt;feMergeNode in=&quot;coloredBlur&quot; /&gt;
                &lt;feMergeNode in=&quot;SourceGraphic&quot; /&gt;
              &lt;/feMerge&gt;
            &lt;/filter&gt;
          &lt;/defs&gt;

          {/* Connection lines */}
          {parentLocations.map(parent =&gt; {
            const parentPos = getLocationPosition(parent)
            return parent.subLocations?.map(child =&gt; {
              const childPos = getSubLocationPosition(child, parentPos)
              return renderConnectingLine(parentPos, childPos)
            })
          })}

          {/* Parent location nodes */}
          {parentLocations.map(location =&gt; {
            const position = getLocationPosition(location)
            return (
              &lt;Tooltip key={location.id}&gt;
                &lt;TooltipTrigger asChild&gt;
                  {renderLocationNode(location, position, true)}
                &lt;/TooltipTrigger&gt;
                &lt;TooltipContent side=&quot;top&quot; className=&quot;max-w-xs&quot;&gt;
                  &lt;div className=&quot;space-y-1&quot;&gt;
                    &lt;div className=&quot;font-semibold flex items-center gap-2&quot;&gt;
                      &lt;MapPin className=&quot;w-4 h-4&quot; /&gt;
                      {location.name}
                    &lt;/div&gt;
                    {location.description &amp;&amp; (
                      &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;
                        {location.description}
                      &lt;/div&gt;
                    )}
                    &lt;div className=&quot;flex items-center gap-4 text-xs&quot;&gt;
                      &lt;span className=&quot;flex items-center gap-1&quot;&gt;
                        &lt;Star className=&quot;w-3 h-3&quot; /&gt;
                        Level {location.difficulty}
                      &lt;/span&gt;
                      &lt;span className=&quot;flex items-center gap-1&quot;&gt;
                        &lt;Users className=&quot;w-3 h-3&quot; /&gt;
                        {location.playerCount} players
                      &lt;/span&gt;
                    &lt;/div&gt;
                    {location.biome &amp;&amp; (
                      &lt;div className=&quot;text-xs capitalize&quot;&gt;
                        Biome: {location.biome}
                      &lt;/div&gt;
                    )}
                    {location.subLocations &amp;&amp; location.subLocations.length &gt; 0 &amp;&amp; (
                      &lt;div className=&quot;text-xs&quot;&gt;
                        Contains {location.subLocations.length} sub-location{location.subLocations.length !== 1 ? &#39;s&#39; : &#39;&#39;}
                      &lt;/div&gt;
                    )}
                  &lt;/div&gt;
                &lt;/TooltipContent&gt;
              &lt;/Tooltip&gt;
            )
          })}

          {/* Child location nodes */}
          {parentLocations.map(parent =&gt; {
            const parentPos = getLocationPosition(parent)
            return parent.subLocations?.map(child =&gt; {
              const childPos = getSubLocationPosition(child, parentPos)
              return (
                &lt;Tooltip key={child.id}&gt;
                  &lt;TooltipTrigger asChild&gt;
                    {renderLocationNode(child, childPos, false)}
                  &lt;/TooltipTrigger&gt;
                  &lt;TooltipContent side=&quot;top&quot; className=&quot;max-w-xs&quot;&gt;
                    &lt;div className=&quot;space-y-1&quot;&gt;
                      &lt;div className=&quot;font-semibold flex items-center gap-2&quot;&gt;
                        &lt;MapPin className=&quot;w-4 h-4&quot; /&gt;
                        {child.name}
                      &lt;/div&gt;
                      {child.description &amp;&amp; (
                        &lt;div className=&quot;text-sm text-muted-foreground&quot;&gt;
                          {child.description}
                        &lt;/div&gt;
                      )}
                      &lt;div className=&quot;flex items-center gap-4 text-xs&quot;&gt;
                        &lt;span className=&quot;flex items-center gap-1&quot;&gt;
                          &lt;Star className=&quot;w-3 h-3&quot; /&gt;
                          Level {child.difficulty}
                        &lt;/span&gt;
                        &lt;span className=&quot;flex items-center gap-1&quot;&gt;
                          &lt;Users className=&quot;w-3 h-3&quot; /&gt;
                          {child.playerCount} players
                        &lt;/span&gt;
                      &lt;/div&gt;
                      &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;
                        Part of {parent.name}
                      &lt;/div&gt;
                    &lt;/div&gt;
                  &lt;/TooltipContent&gt;
                &lt;/Tooltip&gt;
              )
            })
          })}
        &lt;/svg&gt;

        {/* Legend */}
        &lt;div className=&quot;absolute bottom-4 left-4 bg-white/90 dark:bg-slate-800/90 rounded-lg p-3 text-xs space-y-2 backdrop-blur-sm&quot;&gt;
          &lt;div className=&quot;font-semibold&quot;&gt;Legend&lt;/div&gt;
          &lt;div className=&quot;flex items-center gap-2&quot;&gt;
            &lt;svg width=&quot;20&quot; height=&quot;12&quot; className=&quot;flex-shrink-0&quot;&gt;
              &lt;path
                d=&quot;M 2 6 Q 6 2 10 3 Q 14 4 18 6 Q 16 8 12 9 Q 8 10 2 6 Z&quot;
                fill=&quot;#7ec850&quot;
                stroke=&quot;#374151&quot;
                strokeWidth=&quot;1&quot;
              /&gt;
            &lt;/svg&gt;
            &lt;span&gt;Major Region&lt;/span&gt;
          &lt;/div&gt;
          &lt;div className=&quot;flex items-center gap-2&quot;&gt;
            &lt;div className=&quot;w-4 h-4 bg-gray-400 border border-gray-600 rounded-sm flex-shrink-0&quot; /&gt;
            &lt;span&gt;Sub-Location&lt;/span&gt;
          &lt;/div&gt;
          &lt;div className=&quot;flex items-center gap-2&quot;&gt;
            &lt;span&gt;üü¢üü°üî¥&lt;/span&gt;
            &lt;span&gt;Difficulty Level&lt;/span&gt;
          &lt;/div&gt;
          &lt;div className=&quot;flex items-center gap-2&quot;&gt;
            &lt;div className=&quot;w-4 h-4 rounded-full bg-blue-500 text-white text-[8px] flex items-center justify-center font-bold flex-shrink-0&quot;&gt;5&lt;/div&gt;
            &lt;span&gt;Players Online&lt;/span&gt;
          &lt;/div&gt;
          &lt;div className=&quot;flex items-center gap-2&quot;&gt;
            &lt;div className=&quot;w-8 h-1 border-t-2 border-dashed border-gray-400 flex-shrink-0&quot; /&gt;
            &lt;span&gt;Connection&lt;/span&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  )
}
</content>
    </document>

    <document>
      <source>src/components/views/index.ts</source>
      <tags></tags>
      <metadata>
        <size>211</size>
        <lastModified>2025-05-29T11:12:15.786Z</lastModified>
        <extension>ts</extension>
        <directory>src/components/views</directory>
      </metadata>
      <content>// src/components/views/index.ts
export { InventoryView } from &#39;./InventoryView&#39;
export { MarketView } from &#39;./MarketView&#39;
export { MiningView } from &#39;./MiningView&#39;
export { WorldMapView } from &#39;./WorldMapView&#39;
</content>
    </document>

    <document>
      <source>src/components/wallet-select-modal.tsx</source>
      <tags></tags>
      <metadata>
        <size>4486</size>
        <lastModified>2025-05-29T08:13:25.130Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>&quot;use client&quot;;

import React from &#39;react&#39;;
import { useWallet } from &#39;@solana/wallet-adapter-react&#39;;
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from &#39;@/components/ui/dialog&#39;;
import { Button } from &#39;@/components/ui/button&#39;;
import { ScrollArea } from &#39;@/components/ui/scroll-area&#39;;
import { Badge } from &#39;@/components/ui/badge&#39;;
import { Avatar, AvatarFallback, AvatarImage } from &#39;@/components/ui/avatar&#39;;
import { ExternalLink, Wallet } from &#39;lucide-react&#39;;
import { WalletReadyState } from &#39;@solana/wallet-adapter-base&#39;;
import { toast } from &#39;sonner&#39;;

interface WalletSelectModalProps {
  open: boolean;
  onOpenChange: (open: boolean) =&gt; void;
}

export function WalletSelectModal({ open, onOpenChange }: WalletSelectModalProps) {
  const { wallets, select, connect } = useWallet();

  const handleWalletSelect = async (walletName: string) =&gt; {
    try {
      select(walletName);
      await connect();
      onOpenChange(false);
    } catch (error) {
      toast.error(&#39;Failed to connect to wallet&#39;);
    }
  };

  const installedWallets = wallets.filter(
    (wallet) =&gt; wallet.readyState === WalletReadyState.Installed
  );
  
  const notDetectedWallets = wallets.filter(
    (wallet) =&gt; wallet.readyState === WalletReadyState.NotDetected
  );

  return (
    &lt;Dialog open={open} onOpenChange={onOpenChange}&gt;
      &lt;DialogContent className=&quot;sm:max-w-md&quot;&gt;
        &lt;DialogHeader&gt;
          &lt;DialogTitle className=&quot;flex items-center gap-2&quot;&gt;
            &lt;Wallet className=&quot;w-5 h-5&quot; /&gt;
            Connect Wallet
          &lt;/DialogTitle&gt;
          &lt;DialogDescription&gt;
            Choose a wallet to connect to this application.
          &lt;/DialogDescription&gt;
        &lt;/DialogHeader&gt;
        
        &lt;ScrollArea className=&quot;max-h-[400px]&quot;&gt;
          &lt;div className=&quot;space-y-2&quot;&gt;
            {installedWallets.length &gt; 0 &amp;&amp; (
              &lt;div className=&quot;space-y-2&quot;&gt;
                &lt;h4 className=&quot;text-sm font-medium text-muted-foreground&quot;&gt;Installed Wallets&lt;/h4&gt;
                {installedWallets.map((wallet) =&gt; (
                  &lt;Button
                    key={wallet.adapter.name}
                    variant=&quot;outline&quot;
                    className=&quot;w-full justify-start h-auto p-4&quot;
                    onClick={() =&gt; handleWalletSelect(wallet.adapter.name)}
                  &gt;
                    &lt;Avatar className=&quot;w-8 h-8 mr-3&quot;&gt;
                      &lt;AvatarImage src={wallet.adapter.icon} alt={wallet.adapter.name} /&gt;
                      &lt;AvatarFallback&gt;
                        &lt;Wallet className=&quot;w-4 h-4&quot; /&gt;
                      &lt;/AvatarFallback&gt;
                    &lt;/Avatar&gt;
                    &lt;div className=&quot;flex-1 text-left&quot;&gt;
                      &lt;div className=&quot;flex items-center justify-between&quot;&gt;
                        &lt;span className=&quot;font-medium&quot;&gt;{wallet.adapter.name}&lt;/span&gt;
                        &lt;Badge variant=&quot;default&quot; className=&quot;text-xs&quot;&gt;Installed&lt;/Badge&gt;
                      &lt;/div&gt;
                    &lt;/div&gt;
                  &lt;/Button&gt;
                ))}
              &lt;/div&gt;
            )}
            
            {notDetectedWallets.length &gt; 0 &amp;&amp; (
              &lt;div className=&quot;space-y-2&quot;&gt;
                &lt;h4 className=&quot;text-sm font-medium text-muted-foreground&quot;&gt;Available Wallets&lt;/h4&gt;
                {notDetectedWallets.map((wallet) =&gt; (
                  &lt;div
                    key={wallet.adapter.name}
                    className=&quot;flex items-center justify-between p-4 border rounded-lg&quot;
                  &gt;
                    &lt;div className=&quot;flex items-center&quot;&gt;
                      &lt;Avatar className=&quot;w-8 h-8 mr-3&quot;&gt;
                        &lt;AvatarImage src={wallet.adapter.icon} alt={wallet.adapter.name} /&gt;
                        &lt;AvatarFallback&gt;
                          &lt;Wallet className=&quot;w-4 h-4&quot; /&gt;
                        &lt;/AvatarFallback&gt;
                      &lt;/Avatar&gt;
                      &lt;span className=&quot;font-medium&quot;&gt;{wallet.adapter.name}&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;Button
                      variant=&quot;outline&quot;
                      size=&quot;sm&quot;
                      onClick={() =&gt; window.open(wallet.adapter.url, &#39;_blank&#39;)}
                    &gt;
                      &lt;ExternalLink className=&quot;w-4 h-4 mr-1&quot; /&gt;
                      Install
                    &lt;/Button&gt;
                  &lt;/div&gt;
                ))}
              &lt;/div&gt;
            )}
          &lt;/div&gt;
        &lt;/ScrollArea&gt;
      &lt;/DialogContent&gt;
    &lt;/Dialog&gt;
  );
}</content>
    </document>

    <document>
      <source>src/components/theme-provider.tsx</source>
      <tags></tags>
      <metadata>
        <size>1578</size>
        <lastModified>2025-05-29T00:31:34.688Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>import { createContext, useContext, useEffect, useState } from &quot;react&quot;

type Theme = &quot;dark&quot; | &quot;light&quot; | &quot;system&quot;

type ThemeProviderProps = {
  children: React.ReactNode
  defaultTheme?: Theme
  storageKey?: string
}

type ThemeProviderState = {
  theme: Theme
  setTheme: (theme: Theme) =&gt; void
}

const initialState: ThemeProviderState = {
  theme: &quot;system&quot;,
  setTheme: () =&gt; null,
}

const ThemeProviderContext = createContext&lt;ThemeProviderState&gt;(initialState)

export function ThemeProvider({
  children,
  defaultTheme = &quot;system&quot;,
  storageKey = &quot;vite-ui-theme&quot;,
  ...props
}: ThemeProviderProps) {
  const [theme, setTheme] = useState&lt;Theme&gt;(
    () =&gt; (localStorage.getItem(storageKey) as Theme) || defaultTheme
  )

  useEffect(() =&gt; {
    const root = window.document.documentElement

    root.classList.remove(&quot;light&quot;, &quot;dark&quot;)

    if (theme === &quot;system&quot;) {
      const systemTheme = window.matchMedia(&quot;(prefers-color-scheme: dark)&quot;)
        .matches
        ? &quot;dark&quot;
        : &quot;light&quot;

      root.classList.add(systemTheme)
      return
    }

    root.classList.add(theme)
  }, [theme])

  const value = {
    theme,
    setTheme: (theme: Theme) =&gt; {
      localStorage.setItem(storageKey, theme)
      setTheme(theme)
    },
  }

  return (
    &lt;ThemeProviderContext.Provider {...props} value={value}&gt;
      {children}
    &lt;/ThemeProviderContext.Provider&gt;
  )
}

export const useTheme = () =&gt; {
  const context = useContext(ThemeProviderContext)

  if (context === undefined)
    throw new Error(&quot;useTheme must be used within a ThemeProvider&quot;)

  return context
}
</content>
    </document>

    <document>
      <source>src/components/wallet-connect-button.tsx</source>
      <tags></tags>
      <metadata>
        <size>4197</size>
        <lastModified>2025-05-29T08:13:24.988Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>&quot;use client&quot;;

import React, { useState } from &#39;react&#39;;
import { useWallet } from &#39;@solana/wallet-adapter-react&#39;;
import { Button } from &#39;@/components/ui/button&#39;;
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from &#39;@/components/ui/dropdown-menu&#39;;
import { Avatar, AvatarFallback, AvatarImage } from &#39;@/components/ui/avatar&#39;;
import { Badge } from &#39;@/components/ui/badge&#39;;
import { Copy, LogOut, Wallet, ChevronDown } from &#39;lucide-react&#39;;
import { toast } from &#39;sonner&#39;;
import { WalletSelectModal } from &#39;./wallet-select-modal&#39;;

interface WalletConnectButtonProps {
  className?: string;
}

export function WalletConnectButton({ className }: WalletConnectButtonProps) {
  const { publicKey, disconnect, wallet, connect, connecting, connected } = useWallet();
  const [showWalletSelect, setShowWalletSelect] = useState(false);

  const copyAddress = async () =&gt; {
    if (publicKey) {
      await navigator.clipboard.writeText(publicKey.toBase58());
      toast.success(&#39;Address copied to clipboard&#39;);
    }
  };

  const handleConnect = async () =&gt; {
    if (wallet) {
      try {
        await connect();
      } catch (error) {
        toast.error(&#39;Failed to connect wallet&#39;);
      }
    } else {
      setShowWalletSelect(true);
    }
  };

  if (!connected &amp;&amp; !connecting) {
    return (
      &lt;&gt;
        &lt;Button 
          onClick={handleConnect}
          disabled={connecting}
          className={className}
        &gt;
          &lt;Wallet className=&quot;w-4 h-4 mr-2&quot; /&gt;
          {wallet ? &#39;Connect&#39; : &#39;Select Wallet&#39;}
        &lt;/Button&gt;
        &lt;WalletSelectModal 
          open={showWalletSelect} 
          onOpenChange={setShowWalletSelect}
        /&gt;
      &lt;/&gt;
    );
  }

  if (connecting) {
    return (
      &lt;Button disabled className={className}&gt;
        &lt;div className=&quot;w-4 h-4 mr-2 animate-spin rounded-full border-2 border-current border-t-transparent&quot; /&gt;
        Connecting...
      &lt;/Button&gt;
    );
  }

  if (connected &amp;&amp; publicKey) {
    const truncatedAddress = `${publicKey.toBase58().slice(0, 4)}...${publicKey.toBase58().slice(-4)}`;

    return (
      &lt;DropdownMenu&gt;
        &lt;DropdownMenuTrigger asChild&gt;
          &lt;Button variant=&quot;outline&quot; className={`${className} flex items-center gap-2`}&gt;
            &lt;Avatar className=&quot;w-6 h-6&quot;&gt;
              &lt;AvatarImage src={wallet?.adapter.icon} alt={wallet?.adapter.name} /&gt;
              &lt;AvatarFallback&gt;
                &lt;Wallet className=&quot;w-3 h-3&quot; /&gt;
              &lt;/AvatarFallback&gt;
            &lt;/Avatar&gt;
            &lt;span className=&quot;font-mono&quot;&gt;{truncatedAddress}&lt;/span&gt;
            &lt;ChevronDown className=&quot;w-4 h-4&quot; /&gt;
          &lt;/Button&gt;
        &lt;/DropdownMenuTrigger&gt;
        &lt;DropdownMenuContent align=&quot;end&quot; className=&quot;w-64&quot;&gt;
          &lt;div className=&quot;px-2 py-1.5&quot;&gt;
            &lt;div className=&quot;flex items-center gap-2 mb-2&quot;&gt;
              &lt;Avatar className=&quot;w-8 h-8&quot;&gt;
                &lt;AvatarImage src={wallet?.adapter.icon} alt={wallet?.adapter.name} /&gt;
                &lt;AvatarFallback&gt;
                  &lt;Wallet className=&quot;w-4 h-4&quot; /&gt;
                &lt;/AvatarFallback&gt;
              &lt;/Avatar&gt;
              &lt;div&gt;
                &lt;p className=&quot;font-medium&quot;&gt;{wallet?.adapter.name}&lt;/p&gt;
                &lt;Badge variant=&quot;secondary&quot; className=&quot;text-xs&quot;&gt;
                  Connected
                &lt;/Badge&gt;
              &lt;/div&gt;
            &lt;/div&gt;
            &lt;p className=&quot;text-sm text-muted-foreground font-mono break-all&quot;&gt;
              {publicKey.toBase58()}
            &lt;/p&gt;
          &lt;/div&gt;
          &lt;DropdownMenuSeparator /&gt;
          &lt;DropdownMenuItem onClick={copyAddress}&gt;
            &lt;Copy className=&quot;w-4 h-4 mr-2&quot; /&gt;
            Copy Address
          &lt;/DropdownMenuItem&gt;
          &lt;DropdownMenuItem onClick={() =&gt; setShowWalletSelect(true)}&gt;
            &lt;Wallet className=&quot;w-4 h-4 mr-2&quot; /&gt;
            Change Wallet
          &lt;/DropdownMenuItem&gt;
          &lt;DropdownMenuSeparator /&gt;
          &lt;DropdownMenuItem onClick={disconnect} className=&quot;text-destructive&quot;&gt;
            &lt;LogOut className=&quot;w-4 h-4 mr-2&quot; /&gt;
            Disconnect
          &lt;/DropdownMenuItem&gt;
        &lt;/DropdownMenuContent&gt;
      &lt;/DropdownMenu&gt;
    );
  }

  return null;
}</content>
    </document>

    <document>
      <source>src/components/mode-toggle.tsx</source>
      <tags></tags>
      <metadata>
        <size>1207</size>
        <lastModified>2025-05-29T00:32:40.806Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>import { Moon, Sun } from &quot;lucide-react&quot;

import { Button } from &quot;@/components/ui/button&quot;
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from &quot;@/components/ui/dropdown-menu&quot;
import { useTheme } from &quot;@/components/theme-provider&quot;

export function ModeToggle() {
  const { setTheme } = useTheme()

  return (
    &lt;DropdownMenu&gt;
      &lt;DropdownMenuTrigger asChild&gt;
        &lt;Button variant=&quot;outline&quot; size=&quot;icon&quot;&gt;
          &lt;Sun className=&quot;h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0&quot; /&gt;
          &lt;Moon className=&quot;absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100&quot; /&gt;
          &lt;span className=&quot;sr-only&quot;&gt;Toggle theme&lt;/span&gt;
        &lt;/Button&gt;
      &lt;/DropdownMenuTrigger&gt;
      &lt;DropdownMenuContent align=&quot;end&quot;&gt;
        &lt;DropdownMenuItem onClick={() =&gt; setTheme(&quot;light&quot;)}&gt;
          Light
        &lt;/DropdownMenuItem&gt;
        &lt;DropdownMenuItem onClick={() =&gt; setTheme(&quot;dark&quot;)}&gt;
          Dark
        &lt;/DropdownMenuItem&gt;
        &lt;DropdownMenuItem onClick={() =&gt; setTheme(&quot;system&quot;)}&gt;
          System
        &lt;/DropdownMenuItem&gt;
      &lt;/DropdownMenuContent&gt;
    &lt;/DropdownMenu&gt;
  )
}
</content>
    </document>

    <document>
      <source>src/components/wallet-provider.tsx</source>
      <tags></tags>
      <metadata>
        <size>1225</size>
        <lastModified>2025-05-29T08:13:24.629Z</lastModified>
        <extension>tsx</extension>
        <directory>src/components</directory>
      </metadata>
      <content>&quot;use client&quot;;

import React, { useMemo } from &#39;react&#39;;
import { ConnectionProvider, WalletProvider } from &#39;@solana/wallet-adapter-react&#39;;
import { clusterApiUrl } from &#39;@solana/web3.js&#39;;
import { WalletAdapterNetwork } from &#39;@solana/wallet-adapter-base&#39;;
import {
  PhantomWalletAdapter,
  SolflareWalletAdapter,
  BackpackWalletAdapter,
  GlowWalletAdapter,
} from &#39;@solana/wallet-adapter-wallets&#39;;

interface SolanaWalletProviderProps {
  children: React.ReactNode;
  network?: WalletAdapterNetwork;
  endpoint?: string;
  autoConnect?: boolean;
}

export function SolanaWalletProvider({
  children,
  network = WalletAdapterNetwork.Devnet,
  endpoint,
  autoConnect = true,
}: SolanaWalletProviderProps) {
  const wallets = useMemo(
    () =&gt; [
      new PhantomWalletAdapter(),
      new SolflareWalletAdapter(),
      new BackpackWalletAdapter(),
      new GlowWalletAdapter(),
    ],
    []
  );

  const connectionEndpoint = useMemo(
    () =&gt; endpoint || clusterApiUrl(network),
    [network, endpoint]
  );

  return (
    &lt;ConnectionProvider endpoint={connectionEndpoint}&gt;
      &lt;WalletProvider wallets={wallets} autoConnect={autoConnect}&gt;
        {children}
      &lt;/WalletProvider&gt;
    &lt;/ConnectionProvider&gt;
  );
}</content>
    </document>

    <document>
      <source>src/lib/utils.ts</source>
      <tags></tags>
      <metadata>
        <size>166</size>
        <lastModified>2025-05-28T21:46:49.754Z</lastModified>
        <extension>ts</extension>
        <directory>src/lib</directory>
      </metadata>
      <content>import { clsx, type ClassValue } from &quot;clsx&quot;
import { twMerge } from &quot;tailwind-merge&quot;

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</content>
    </document>

    <document>
      <source>src/lib/layerResolver.ts</source>
      <tags></tags>
      <metadata>
        <size>8697</size>
        <lastModified>2025-05-29T02:27:27.011Z</lastModified>
        <extension>ts</extension>
        <directory>src/lib</directory>
      </metadata>
      <content>// src/utils/layerResolver.ts
export interface LayerConfig {
  type: &#39;background&#39; | &#39;base&#39; | &#39;clothing&#39; | &#39;accessory&#39; | &#39;overlay&#39;
  name: string
  zIndex: number
  visible: boolean
}

export interface VisibilityRules {
  [key: string]: {
    blocks?: string[] // What this layer blocks
    blockedBy?: string[] // What blocks this layer
    requires?: string[] // What this layer requires to be visible
  }
}

// Asset URL resolver
export function getAssetUrl(type: string, name: string): string {
  return `https://earth.ndao.computer/layers/${type}s/${name}.png`
}

// Layer visibility rules - customize based on your game logic
export const LAYER_VISIBILITY_RULES: VisibilityRules = {
  // Clothing rules
  &#39;cyber-jacket&#39;: {
    blocks: [&#39;parka-yellow&#39;, &#39;miners-jacket&#39;], // Can&#39;t wear multiple jackets
    blockedBy: [],
  },
  &#39;parka-yellow&#39;: {
    blocks: [&#39;cyber-jacket&#39;, &#39;miners-jacket&#39;],
    blockedBy: [],
  },
  &#39;miners-jacket&#39;: {
    blocks: [&#39;cyber-jacket&#39;, &#39;parka-yellow&#39;],
    blockedBy: [],
  },

  // Accessory rules
  sunglasses: {
    blocks: [], // Sunglasses don&#39;t block other accessories
    blockedBy: [],
  },
  &#39;gold-chain&#39;: {
    blocks: [],
    blockedBy: [],
  },
  &#39;lucky-charm&#39;: {
    blocks: [],
    blockedBy: [],
  },

  // Overlay rules
  &#39;glow-red&#39;: {
    blocks: [&#39;rain-fog&#39;], // Glow effects might override weather
    blockedBy: [],
  },
  &#39;rain-fog&#39;: {
    blocks: [],
    blockedBy: [&#39;glow-red&#39;],
  },
  &#39;glitch-vibe&#39;: {
    blocks: [],
    blockedBy: [],
  },
}

// Resolve which layers should be visible based on equipped items and rules
export function resolveVisibleLayers(character: {
  gender: string
  characterType: string
  currentLocation: { biome?: string; name: string }
  inventory: Array&lt;{
    item: {
      name: string
      category: string
      layerType?: string
    }
    isEquipped: boolean
  }&gt;
}): LayerConfig[] {
  const layers: LayerConfig[] = []

  // 1. Add background based on location
  const backgroundName = getBackgroundForLocation(character.currentLocation)
  if (backgroundName) {
    layers.push({
      type: &#39;background&#39;,
      name: backgroundName,
      zIndex: 0,
      visible: true,
    })
  }

  // 2. Add base layer based on character type and gender
  const baseName = getBaseForCharacter(character)
  layers.push({
    type: &#39;base&#39;,
    name: baseName,
    zIndex: 1,
    visible: true,
  })

  // 3. Add equipped items as layers
  const equippedItems = character.inventory.filter((inv) =&gt; inv.isEquipped)

  equippedItems.forEach((inv) =&gt; {
    const layerType = mapCategoryToLayerType(inv.item.category)
    const layerName = kebabCase(inv.item.name)

    if (layerType) {
      layers.push({
        type: layerType,
        name: layerName,
        zIndex: getZIndexForLayerType(layerType),
        visible: true, // Will be resolved in visibility step
      })
    }
  })

  // 4. Add contextual overlays (weather, effects, etc.)
  const overlays = getContextualOverlays(character)
  overlays.forEach((overlay) =&gt; {
    layers.push({
      type: &#39;overlay&#39;,
      name: overlay,
      zIndex: 10,
      visible: true,
    })
  })

  // 5. Apply visibility rules
  return applyVisibilityRules(layers)
}

// Helper functions
function getBackgroundForLocation(location: {
  biome?: string
  name: string
}): string | null {
  // Map location biomes to background images
  const biomeMap: { [key: string]: string } = {
    plains: &#39;mining-plains&#39;,
    desert: &#39;desert-outpost&#39;,
    urban: &#39;cyber-city&#39;,
  }

  return location.biome ? biomeMap[location.biome] || null : null
}

function getBaseForCharacter(character: {
  gender: string
  characterType: string
}): string {
  if (character.characterType === &#39;CREATURE&#39;) {
    return &#39;creature&#39;
  }
  return character.gender.toLowerCase() // &#39;male&#39; or &#39;female&#39;
}

function mapCategoryToLayerType(category: string): LayerConfig[&#39;type&#39;] | null {
  const categoryMap: { [key: string]: LayerConfig[&#39;type&#39;] } = {
    CLOTHING: &#39;clothing&#39;,
    HAT: &#39;clothing&#39;, // Hats go in clothing layer
    ACCESSORY: &#39;accessory&#39;,
    TOOL: &#39;accessory&#39;, // Tools as accessories for now
  }

  return categoryMap[category] || null
}

function getZIndexForLayerType(type: LayerConfig[&#39;type&#39;]): number {
  const zIndexMap = {
    background: 0,
    base: 1,
    clothing: 2,
    accessory: 3,
    overlay: 10,
  }
  return zIndexMap[type]
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getContextualOverlays(character: any): string[] {
  const overlays: string[] = []

  // Add overlays based on game state, time, events, etc.
  // Example: if character has low health, add a red glow
  if (character.health &amp;&amp; character.health &lt; 30) {
    overlays.push(&#39;glow-red&#39;)
  }

  // Add weather effects based on location
  if (character.currentLocation?.biome === &#39;desert&#39; &amp;&amp; Math.random() &gt; 0.7) {
    // Sometimes add heat shimmer effect in desert
    // overlays.push(&#39;heat-shimmer&#39;)
  }

  return overlays
}

function applyVisibilityRules(layers: LayerConfig[]): LayerConfig[] {
  const visibleLayers = [...layers]

  // Apply blocking rules
  layers.forEach((layer) =&gt; {
    const rules = LAYER_VISIBILITY_RULES[layer.name]
    if (rules?.blocks) {
      rules.blocks.forEach((blockedName) =&gt; {
        const blockedLayer = visibleLayers.find((l) =&gt; l.name === blockedName)
        if (blockedLayer) {
          blockedLayer.visible = false
        }
      })
    }
  })

  // Sort by z-index and filter visible layers
  return visibleLayers
    .filter((layer) =&gt; layer.visible)
    .sort((a, b) =&gt; a.zIndex - b.zIndex)
}

// Utility function to convert item names to kebab-case for file names
function kebabCase(str: string): string {
  return str
    .toLowerCase()
    .replace(/[^a-z0-9]/g, &#39;-&#39;)
    .replace(/-+/g, &#39;-&#39;)
    .replace(/^-|-$/g, &#39;&#39;)
}

// Generate metadata for NFT
export interface NFTMetadata {
  name: string
  description: string
  image: string
  attributes: Array&lt;{
    trait_type: string
    value: string
  }&gt;
  assets: {
    layers: string[]
  }
}

export function generateNFTMetadata(character: {
  id: string
  name: string
  gender: string
  characterType: string
  currentLocation: { name: string; biome?: string }
  inventory: Array&lt;{
    item: {
      name: string
      category: string
      rarity: string
      layerType?: string
    }
    isEquipped: boolean
  }&gt;
  energy: number
  health: number
}): NFTMetadata {
  const visibleLayers = resolveVisibleLayers(character)

  // Generate attributes from visible layers and character stats
  const attributes = [
    { trait_type: &#39;Gender&#39;, value: character.gender },
    { trait_type: &#39;Type&#39;, value: character.characterType },
    { trait_type: &#39;Location&#39;, value: character.currentLocation.name },
  ]

  // Add background attribute
  const background = visibleLayers.find((l) =&gt; l.type === &#39;background&#39;)
  if (background) {
    attributes.push({
      trait_type: &#39;Background&#39;,
      value: background.name
        .split(&#39;-&#39;)
        .map((w) =&gt; w.charAt(0).toUpperCase() + w.slice(1))
        .join(&#39; &#39;),
    })
  }

  // Add equipped item attributes
  const equippedItems = character.inventory.filter((inv) =&gt; inv.isEquipped)
  equippedItems.forEach((inv) =&gt; {
    attributes.push({
      trait_type:
        inv.item.category.charAt(0) + inv.item.category.slice(1).toLowerCase(),
      value: inv.item.name,
    })
  })

  // Add status attributes
  if (character.energy &lt; 30) {
    attributes.push({ trait_type: &#39;Status&#39;, value: &#39;Exhausted&#39; })
  } else if (character.energy &gt; 90) {
    attributes.push({ trait_type: &#39;Status&#39;, value: &#39;Energetic&#39; })
  }

  // Generate description
  const description = generateDescription(character, equippedItems)

  return {
    name: character.name,
    description,
    image: `https://earth.ndao.computer/api/render/${character.id}.png`,
    attributes,
    assets: {
      layers: visibleLayers.map((layer) =&gt; getAssetUrl(layer.type, layer.name)),
    },
  }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function generateDescription(character: any, equippedItems: any[]): string {
  const locationDesc = `wandering ${character.currentLocation.name}`
  const itemDesc =
    equippedItems.length &gt; 0
      ? `equipped with ${equippedItems.map((i) =&gt; i.item.name).join(&#39;, &#39;)}`
      : &#39;traveling light&#39;

  const statusDesc =
    character.energy &lt; 30
      ? &#39;looking weary from their adventures&#39;
      : character.energy &gt; 90
      ? &#39;full of energy and ready for action&#39;
      : &#39;continuing their journey&#39;

  return `A ${character.characterType.toLowerCase()} ${locationDesc}, ${itemDesc}, ${statusDesc}.`
}

// Export layer resolution for use in image rendering
export { resolveVisibleLayers as default }
</content>
    </document>

    <document>
      <source>src/vite-env.d.ts</source>
      <tags></tags>
      <metadata>
        <size>38</size>
        <lastModified>2025-05-28T21:44:35.044Z</lastModified>
        <extension>ts</extension>
        <directory>src</directory>
      </metadata>
      <content>/// &lt;reference types=&quot;vite/client&quot; /&gt;
</content>
    </document>

    <document>
      <source>src/App.tsx</source>
      <tags></tags>
      <metadata>
        <size>42262</size>
        <lastModified>2025-05-29T12:22:54.002Z</lastModified>
        <extension>tsx</extension>
        <directory>src</directory>
      </metadata>
      <content>import { useState, useEffect } from &#39;react&#39;
import { Button } from &#39;@/components/ui/button&#39;
import { MapPin, Pickaxe, Store, Backpack, ArrowLeft, Zap, Heart, Users, Map, MessageCircle, Send, Earth } from &#39;lucide-react&#39;
import &#39;./App.css&#39;
import { ModeToggle } from &#39;./components/mode-toggle&#39;
// import { resolveVisibleLayers, generateCharacterLayers, generateNFTMetadata } from &#39;@/lib/layerResolver&#39;
import { toast, Toaster } from &#39;sonner&#39;
import { InventoryView, MarketView, MiningView, WorldMapView } from &#39;@/components/views&#39;

import { Tabs, TabsList, TabsTrigger, TabsContent } from &quot;@/components/ui/tabs&quot;

// API base URL - will be your Netlify functions URL
const API_BASE = &#39;/.netlify/functions&#39;

import type {
  GameView,
  Character,
  Location,
  MarketItem,
  ChatMessage,
  Player
} from &#39;@/types&#39;

function App() {
  const [currentView, setCurrentView] = useState&lt;GameView&gt;(&#39;main&#39;)
  const [selectedLocation, setSelectedLocation] = useState&lt;Location | null&gt;(null)
  const [gameLog, setGameLog] = useState&lt;string[]&gt;([])
  const [chatInput, setChatInput] = useState(&#39;&#39;)
  const [loadingItems, setLoadingItems] = useState&lt;Set&lt;string&gt;&gt;(new Set())

  // State for API data
  const [character, setCharacter] = useState&lt;Character | null&gt;(null)
  const [locations, setLocations] = useState&lt;Location[]&gt;([])
  const [marketItems, setMarketItems] = useState&lt;MarketItem[]&gt;([])
  const [chatMessages, setChatMessages] = useState&lt;ChatMessage[]&gt;([])
  const [playersAtLocation, setPlayersAtLocation] = useState&lt;Player[]&gt;([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState&lt;string | null&gt;(null)
  const [travelingTo, setTravelingTo] = useState&lt;Location | null&gt;(null)

  // Load initial data
  useEffect(() =&gt; {
    loadGameData()
  }, [])

  // Load chat when location changes
  useEffect(() =&gt; {
    if (character &amp;&amp; currentView === &#39;chat&#39;) {
      loadChatMessages(selectedLocation?.id || character.currentLocation.id)
    }
  }, [currentView, selectedLocation?.id, character?.currentLocation.id, character])

  // Load players when viewing location
  useEffect(() =&gt; {
    if (selectedLocation &amp;&amp; currentView === &#39;location&#39;) {
      loadPlayersAtLocation(selectedLocation.id)
    }
  }, [selectedLocation?.id, currentView, selectedLocation])

  // Load market when opening market view
  useEffect(() =&gt; {
    if (character &amp;&amp; currentView === &#39;market&#39;) {
      loadMarketItems(selectedLocation?.id || character.currentLocation.id)
    }
  }, [currentView, selectedLocation?.id, character?.currentLocation.id, character])

  const loadGameData = async () =&gt; {
    try {
      setLoading(true)

      // Load character data
      const characterResponse = await fetch(`${API_BASE}/get-character?characterId=hardcoded-demo`)
      if (!characterResponse.ok) throw new Error(&#39;Failed to load character&#39;)
      const characterData = await characterResponse.json()
      setCharacter(characterData)

      // Load locations data
      const locationsResponse = await fetch(`${API_BASE}/get-locations`)
      if (!locationsResponse.ok) throw new Error(&#39;Failed to load locations&#39;)
      const locationsData = await locationsResponse.json()
      setLocations(locationsData.locations)

      // Set initial game log
      setGameLog([
        `Welcome to Earth, ${characterData.name}!`,
        `You find yourself in ${characterData.currentLocation.name}.`,
        ...characterData.recentActivity.slice(0, 3).map((activity: Character[&#39;recentActivity&#39;][0]) =&gt;
          `${activity.description}${activity.item ? ` - ${activity.item.name}` : &#39;&#39;}`
        )
      ])

      setError(null)
    } catch (err) {
      console.error(&#39;Failed to load game data:&#39;, err)
      setError(&#39;Failed to load game data. Please refresh the page.&#39;)
    } finally {
      setLoading(false)
    }
  }

  const loadMarketItems = async (locationId: string) =&gt; {
    try {
      const response = await fetch(`${API_BASE}/get-market?locationId=${locationId}`)
      if (response.ok) {
        const data = await response.json()
        setMarketItems(data.items || [])
      }
    } catch (error) {
      console.error(&#39;Failed to load market items:&#39;, error)
      // Fallback to mock data if API not implemented
      setMarketItems([
        {
          id: &#39;1&#39;,
          price: 50,
          quantity: 1,
          isSystemItem: true,
          item: {
            id: &#39;1&#39;,
            name: &#39;Miners Hat&#39;,
            description: &#39;Worn leather hat with a dim headlamp&#39;,
            category: &#39;HAT&#39;,
            rarity: &#39;COMMON&#39;,
            imageUrl: &#39;/items/miners-hat.png&#39;
          }
        },
        {
          id: &#39;2&#39;,
          price: 25,
          quantity: 1,
          isSystemItem: true,
          item: {
            id: &#39;2&#39;,
            name: &#39;Work Gloves&#39;,
            description: &#39;Tough gloves for manual labor&#39;,
            category: &#39;CLOTHING&#39;,
            rarity: &#39;COMMON&#39;
          }
        },
        {
          id: &#39;3&#39;,
          price: 10,
          quantity: 5,
          isSystemItem: true,
          item: {
            id: &#39;3&#39;,
            name: &#39;Energy Drink&#39;,
            description: &#39;Restores energy and keeps you alert&#39;,
            category: &#39;CONSUMABLE&#39;,
            rarity: &#39;COMMON&#39;
          }
        }
      ])
    }
  }

  const loadChatMessages = async (locationId: string) =&gt; {
    try {
      const response = await fetch(`${API_BASE}/get-chat?locationId=${locationId}&amp;limit=50`)
      if (response.ok) {
        const data = await response.json()
        setChatMessages(data.messages || [])
      }
    } catch (error) {
      console.error(&#39;Failed to load chat messages:&#39;, error)
      // Fallback to mock data
      setChatMessages([
        {
          id: &#39;1&#39;,
          message: &#39;Anyone know where the best iron deposits are?&#39;,
          messageType: &#39;CHAT&#39;,
          isSystem: false,
          timeAgo: &#39;3m ago&#39;,
          createdAt: new Date(Date.now() - 3 * 60 * 1000).toISOString(),
          character: {
            id: &#39;1&#39;,
            name: &#39;Wojak #420&#39;,
            characterType: &#39;HUMAN&#39;,
            imageUrl: &#39;/wojak-420.png&#39;
          },
          location: {
            id: locationId,
            name: &#39;Mining Plains&#39;,
            locationType: &#39;REGION&#39;
          }
        },
        {
          id: &#39;2&#39;,
          message: &#39;Try the eastern slopes, found some good scraps there yesterday&#39;,
          messageType: &#39;CHAT&#39;,
          isSystem: false,
          timeAgo: &#39;2m ago&#39;,
          createdAt: new Date(Date.now() - 2 * 60 * 1000).toISOString(),
          character: {
            id: &#39;2&#39;,
            name: &#39;Wojak #1337&#39;,
            characterType: &#39;HUMAN&#39;
          },
          location: {
            id: locationId,
            name: &#39;Mining Plains&#39;,
            locationType: &#39;REGION&#39;
          }
        }
      ])
    }
  }

  const loadPlayersAtLocation = async (locationId: string) =&gt; {
    try {
      const response = await fetch(`${API_BASE}/get-players-at-location?locationId=${locationId}`)
      if (response.ok) {
        const data = await response.json()
        setPlayersAtLocation(data.players || [])
      }
    } catch (error) {
      console.error(&#39;Failed to load players:&#39;, error)
      // Mock data fallback
      setPlayersAtLocation([
        {
          id: &#39;1&#39;,
          name: &#39;Wojak #420&#39;,
          gender: &#39;MALE&#39;,
          characterType: &#39;HUMAN&#39;,
          level: 5,
          energy: 95,
          health: 100,
          status: &#39;Mining&#39;,
          currentImageUrl: &#39;/wojak-420.png&#39;,
          equippedItems: [
            { name: &#39;Miners Hat&#39;, category: &#39;HAT&#39;, rarity: &#39;COMMON&#39; }
          ]
        },
        {
          id: &#39;2&#39;,
          name: &#39;Wojak #69&#39;,
          gender: &#39;FEMALE&#39;,
          characterType: &#39;HUMAN&#39;,
          level: 3,
          energy: 70,
          health: 100,
          status: &#39;Chatting&#39;,
          equippedItems: []
        }
      ])
    }
  }

  const addToLog = (message: string) =&gt; {
    setGameLog(prev =&gt; [...prev.slice(-4), message]) // Keep last 5 messages
  }

  const handleMining = async () =&gt; {
    if (!character) return

    // Set loading state for mining button
    setLoadingItems(prev =&gt; new Set(prev).add(&#39;mining-action&#39;))

    try {
      const response = await fetch(`${API_BASE}/mine-action`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          locationId: selectedLocation?.id || character.currentLocation.id
        })
      })

      const result = await response.json()

      if (!response.ok) {
        // Show error toast
        toast.error(result.message || result.error)
        return
      }

      // Update character energy immediately (optimistic update)
      setCharacter(prev =&gt; prev ? ({
        ...prev,
        energy: result.newEnergyLevel
      }) : null)

      // Show appropriate toast based on what was found
      if (result.foundItem) {
        // Success toast with item details
        const rarityEmoji = {
          &#39;COMMON&#39;: &#39;‚ö™&#39;,
          &#39;UNCOMMON&#39;: &#39;üü¢&#39;,
          &#39;RARE&#39;: &#39;üîµ&#39;,
          &#39;EPIC&#39;: &#39;üü£&#39;,
          &#39;LEGENDARY&#39;: &#39;üü°&#39;
        }[result.foundItem.rarity] || &#39;‚ö™&#39;

        toast.success(
          `Found ${result.foundItem.name}! ${rarityEmoji}`,
          {
            description: `${result.foundItem.description} ‚Ä¢ Energy: ${result.newEnergyLevel}/100`,
            duration: 4000
          }
        )

        // Add to game log
        addToLog(`‚õèÔ∏è ${result.message}`)
      } else {
        // Nothing found toast
        toast.info(
          &quot;Nothing found this time...&quot;,
          {
            description: `Keep trying! Energy: ${result.newEnergyLevel}/100`,
            duration: 2000
          }
        )

        // Add to game log  
        addToLog(`‚õèÔ∏è ${result.message}`)
      }

      // Only refresh character data (not full page reload)
      // This updates inventory with new items
      const characterResponse = await fetch(`${API_BASE}/get-character?characterId=hardcoded-demo`)
      if (characterResponse.ok) {
        const characterData = await characterResponse.json()
        setCharacter(characterData)
      }

    } catch (error) {
      console.error(&#39;Mining failed:&#39;, error)
      toast.error(&#39;Mining attempt failed. Please try again.&#39;)
      addToLog(&#39;‚õèÔ∏è Mining attempt failed due to connection issues.&#39;)
    } finally {
      // Remove loading state
      setLoadingItems(prev =&gt; {
        const newSet = new Set(prev)
        newSet.delete(&#39;mining-action&#39;)
        return newSet
      })
    }
  }

  const handleTravel = async (locationId: string) =&gt; {
    if (!character) return

    // Find the destination location for the travel animation
    const destination = locations.find(loc =&gt; loc.id === locationId) ||
      locations.find(loc =&gt; loc.subLocations?.some(sub =&gt; sub.id === locationId))?.subLocations?.find(sub =&gt; sub.id === locationId)

    if (destination) {
      setTravelingTo(destination)
    }

    try {
      const response = await fetch(`${API_BASE}/travel-action`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          destinationId: locationId
        })
      })

      const result = await response.json()

      if (!response.ok) {
        addToLog(result.message || result.error)
        setTravelingTo(null)
        return
      }

      // Show travel completion after a brief delay for the animation
      setTimeout(async () =&gt; {
        // Update character location
        setCharacter(prev =&gt; prev ? ({
          ...prev,
          currentLocation: {
            id: result.newLocation.id,
            name: result.newLocation.name,
            description: result.newLocation.description,
            locationType: result.newLocation.locationType,
            biome: result.newLocation.biome,
            welcomeMessage: result.newLocation.welcomeMessage
          }
        }) : null)

        // Show result in log
        addToLog(result.message)
        if (result.newLocation.welcomeMessage) {
          addToLog(`&quot;${result.newLocation.welcomeMessage}&quot;`)
        }

        // Refresh locations data in background without loading state
        try {
          const locationsResponse = await fetch(`${API_BASE}/get-locations`)
          if (locationsResponse.ok) {
            const locationsData = await locationsResponse.json()
            setLocations(locationsData.locations)
          }
        } catch (err) {
          console.error(&#39;Failed to refresh locations:&#39;, err)
        }

        // Clear traveling state and go to main view
        setTravelingTo(null)
        setCurrentView(&#39;main&#39;)
      }, 1500) // 1.5 second travel animation

    } catch (error) {
      console.error(&#39;Travel failed:&#39;, error)
      addToLog(&#39;Travel failed. Please try again.&#39;)
      setTravelingTo(null)
    }
  }

  const handleLocationSelect = (location: Location) =&gt; {
    setSelectedLocation(location)
    setCurrentView(&#39;location&#39;)
  }

  const handlePurchase = async (marketListingId: string, price: number, itemName: string) =&gt; {
    if (!character) return

    // Set loading state
    setLoadingItems(prev =&gt; new Set(prev).add(marketListingId))

    try {
      const response = await fetch(`${API_BASE}/buy-item`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          marketListingId: marketListingId,
          locationId: selectedLocation?.id || character.currentLocation.id
        })
      })

      const result = await response.json()

      if (!response.ok) {
        toast.error(result.message || result.error)
        return
      }

      toast.success(`Bought ${itemName} for ${price} coins!`)

      // Optimistic update for market items
      setMarketItems(prev =&gt; prev.map(item =&gt; {
        if (item.id === marketListingId) {
          const newQuantity = item.quantity - 1
          return newQuantity &gt; 0 ? { ...item, quantity: newQuantity } : null
        }
        return item
      }).filter(Boolean) as MarketItem[])

      // Only refresh character data (not everything)
      const characterResponse = await fetch(`${API_BASE}/get-character?characterId=hardcoded-demo`)
      if (characterResponse.ok) {
        const characterData = await characterResponse.json()
        setCharacter(characterData)
      }

    } catch (error) {
      console.error(&#39;Purchase failed:&#39;, error)
      toast.error(&#39;Purchase failed&#39;)
    } finally {
      // Remove loading state
      setLoadingItems(prev =&gt; {
        const newSet = new Set(prev)
        newSet.delete(marketListingId)
        return newSet
      })
    }
  }

  const handleSendMessage = async () =&gt; {
    if (!chatInput.trim() || !character) return

    try {
      const response = await fetch(`${API_BASE}/send-message`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          locationId: selectedLocation?.id || character.currentLocation.id,
          message: chatInput,
          messageType: &#39;CHAT&#39;
        })
      })

      if (response.ok) {
        setChatInput(&#39;&#39;)
        // Reload chat messages
        loadChatMessages(selectedLocation?.id || character.currentLocation.id)
      } else {
        // Fallback for demo - add message locally
        const newMessage: ChatMessage = {
          id: Date.now().toString(),
          message: chatInput,
          messageType: &#39;CHAT&#39;,
          isSystem: false,
          timeAgo: &#39;now&#39;,
          createdAt: new Date().toISOString(),
          character: {
            id: character.id,
            name: character.name,
            characterType: &#39;HUMAN&#39;
          },
          location: {
            id: selectedLocation?.id || character.currentLocation.id,
            name: selectedLocation?.name || character.currentLocation.name,
            locationType: selectedLocation?.locationType || character.currentLocation.locationType
          }
        }
        setChatMessages(prev =&gt; [...prev, newMessage])
        setChatInput(&#39;&#39;)
      }
    } catch (error) {
      console.error(&#39;Failed to send message:&#39;, error)
    }
  }

  const handleEquipItem = async (inventoryId: string, isEquipped: boolean) =&gt; {
    if (!character) return

    // Set loading state
    setLoadingItems(prev =&gt; new Set(prev).add(inventoryId))

    try {
      const response = await fetch(`${API_BASE}/equip-item`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          inventoryId: inventoryId,
          equip: !isEquipped
        })
      })

      const result = await response.json()

      if (!response.ok) {
        toast.error(result.message || result.error)
        return
      }

      // Optimistic update for ALL inventory items in the same category
      setCharacter(prev =&gt; prev ? ({
        ...prev,
        inventory: prev.inventory.map(inv =&gt; {
          // Unequip items in the same category (auto-replace logic)
          if (inv.item.category === prev.inventory.find(i =&gt; i.id === inventoryId)?.item.category &amp;&amp;
            inv.id !== inventoryId &amp;&amp;
            !isEquipped) {
            return { ...inv, isEquipped: false }
          }
          // Update the target item
          if (inv.id === inventoryId) {
            return { ...inv, isEquipped: !isEquipped }
          }
          return inv
        })
      }) : null)

      // Enhanced toast with replacement info
      if (result.replacedItems &amp;&amp; result.replacedItems.length &gt; 0) {
        toast.success(
          `${result.item.name} equipped!`,
          {
            description: `Replaced ${result.replacedItems.join(&#39;, &#39;)}`,
            duration: 4000
          }
        )
      } else {
        toast.success(
          isEquipped ? `${result.item.name} unequipped` : `${result.item.name} equipped!`,
          {
            description: `${result.item.category.toLowerCase()} ‚Ä¢ ${result.item.rarity.toLowerCase()}`,
            duration: 3000
          }
        )
      }

    } catch (error) {
      console.error(&#39;Failed to equip item:&#39;, error)
      toast.error(&#39;Failed to update equipment&#39;)
    } finally {
      // Remove loading state
      setLoadingItems(prev =&gt; {
        const newSet = new Set(prev)
        newSet.delete(inventoryId)
        return newSet
      })
    }
  }

  const handleUseItem = async (inventoryId: string, itemName: string, energyEffect?: number, healthEffect?: number) =&gt; {
    if (!character) return

    // Calculate actual effects (capped at 100)
    const actualEnergyGain = energyEffect ? Math.min(energyEffect, 100 - character.energy) : 0
    const actualHealthGain = healthEffect ? Math.min(healthEffect, 100 - character.health) : 0

    // Warn if effects would be wasted
    if ((energyEffect &amp;&amp; actualEnergyGain === 0) || (healthEffect &amp;&amp; actualHealthGain === 0)) {
      toast.warning(`You&#39;re already at full ${energyEffect &amp;&amp; actualEnergyGain === 0 ? &#39;energy&#39; : &#39;health&#39;}!`)
      return
    }

    // Set loading state for this specific item
    setLoadingItems(prev =&gt; new Set(prev).add(inventoryId))

    try {
      const response = await fetch(`${API_BASE}/use-item`, {
        method: &#39;POST&#39;,
        headers: {
          &#39;Content-Type&#39;: &#39;application/json&#39;
        },
        body: JSON.stringify({
          characterId: &#39;hardcoded-demo&#39;,
          inventoryId: inventoryId
        })
      })

      const result = await response.json()

      if (!response.ok) {
        toast.error(result.message || result.error)
        return
      }

      // Update character stats immediately (optimistic update)
      setCharacter(prev =&gt; prev ? ({
        ...prev,
        energy: Math.min(100, prev.energy + (result.effects?.energy || 0)),
        health: Math.min(100, prev.health + (result.effects?.health || 0)),
        // Update inventory optimistically
        inventory: prev.inventory.map(inv =&gt; {
          if (inv.id === inventoryId) {
            const newQuantity = inv.quantity - 1
            return newQuantity &gt; 0 ? { ...inv, quantity: newQuantity } : null
          }
          return inv
        }).filter(Boolean) as typeof prev.inventory
      }) : null)

      // Show success toast with effects
      const effects = []
      if (result.effects?.energy &gt; 0) effects.push(`+${result.effects.energy} energy`)
      if (result.effects?.health &gt; 0) effects.push(`+${result.effects.health} health`)

      toast.success(`Used ${itemName}${effects.length &gt; 0 ? ` (${effects.join(&#39;, &#39;)})` : &#39;&#39;}`)

      // Don&#39;t reload everything - just let the optimistic update handle it

    } catch (error) {
      console.error(&#39;Use item failed:&#39;, error)
      toast.error(`Failed to use ${itemName}`)
    } finally {
      // Remove loading state
      setLoadingItems(prev =&gt; {
        const newSet = new Set(prev)
        newSet.delete(inventoryId)
        return newSet
      })
    }
  }

  // Initial loading state (only for app startup)
  if (loading &amp;&amp; !travelingTo) {
    return (
      &lt;div className=&quot;min-h-screen bg-background p-4 flex items-center justify-center&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          {/* &lt;div className=&quot;text-2xl mb-4&quot;&gt;üåç&lt;/div&gt; */}
          &lt;Earth className=&quot;w-12 h-12 mb-4 animate-spin&quot; /&gt;
          &lt;div&gt;Loading Wojak Earth...&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }

  // Travel animation state
  if (travelingTo) {
    return (
      &lt;div className=&quot;min-h-screen bg-background p-4 flex items-center justify-center&quot;&gt;
        &lt;div className=&quot;text-center max-w-md mx-auto&quot;&gt;
          &lt;div className=&quot;mb-6&quot;&gt;
            &lt;div className=&quot;text-4xl mb-4 animate-bounce&quot;&gt;
              {travelingTo.biome === &#39;desert&#39; ? &#39;üèúÔ∏è&#39; :
                travelingTo.biome === &#39;urban&#39; ? &#39;üèôÔ∏è&#39; :
                  travelingTo.biome === &#39;plains&#39; ? &#39;üåæ&#39; :
                    travelingTo.locationType === &#39;BUILDING&#39; ? &#39;üè†&#39; : &#39;üó∫Ô∏è&#39;}
            &lt;/div&gt;
            &lt;div className=&quot;text-xl font-bold mb-2&quot;&gt;Traveling to...&lt;/div&gt;
            &lt;div className=&quot;text-2xl font-bold text-primary mb-2&quot;&gt;{travelingTo.name}&lt;/div&gt;
            &lt;div className=&quot;text-muted-foreground mb-4&quot;&gt;{travelingTo.description}&lt;/div&gt;

            {/* Animated progress bar */}
            &lt;div className=&quot;w-full bg-muted rounded-full h-2 mb-4 overflow-hidden&quot;&gt;
              &lt;div className=&quot;bg-primary h-2 rounded-full animate-pulse&quot;
                style={{
                  animation: &#39;travel-progress 1.5s ease-in-out forwards&#39;,
                  width: &#39;0%&#39;
                }}&gt;&lt;/div&gt;
            &lt;/div&gt;

            &lt;div className=&quot;text-sm text-muted-foreground animate-pulse&quot;&gt;
              Preparing for arrival...
            &lt;/div&gt;
          &lt;/div&gt;

          {/* Add custom CSS for the travel progress animation */}
          &lt;style&gt;{`
            @keyframes travel-progress {
              0% { width: 0%; }
              100% { width: 100%; }
            }
          `}&lt;/style&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }

  // Error state
  if (error) {
    return (
      &lt;div className=&quot;min-h-screen bg-background p-4 flex items-center justify-center&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          &lt;div className=&quot;text-2xl mb-4&quot;&gt;‚ùå&lt;/div&gt;
          &lt;div className=&quot;text-red-500 mb-4&quot;&gt;{error}&lt;/div&gt;
          &lt;Button onClick={loadGameData}&gt;Retry&lt;/Button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }

  // No character data
  if (!character) {
    return (
      &lt;div className=&quot;min-h-screen bg-background p-4 flex items-center justify-center&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          &lt;div className=&quot;text-2xl mb-4&quot;&gt;ü§î&lt;/div&gt;
          &lt;div&gt;No character data found&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }


  // Add this new component for the character display
  const CharacterRenderer: React.FC&lt;{ character: Character }&gt; = ({ character }) =&gt; {
    const [imageError, setImageError] = useState(false)
    const [imageLoading, setImageLoading] = useState(true)

    // Generate the rendered character URL
    const characterImageUrl = `/.netlify/functions/render-character/${character.id}.png`

    const handleImageLoad = () =&gt; {
      setImageLoading(false)
      setImageError(false)
    }

    const handleImageError = () =&gt; {
      setImageLoading(false)
      setImageError(true)
    }

    return (
      &lt;div className=&quot;w-32 h-32 mx-auto bg-gray-200 rounded-lg flex items-center justify-center mb-4 overflow-hidden relative&quot;&gt;
        {imageLoading &amp;&amp; (
          &lt;div className=&quot;absolute inset-0 flex items-center justify-center&quot;&gt;
            &lt;div className=&quot;animate-spin rounded-full h-8 w-8 border-b-2 border-primary&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;
        )}

        {!imageError ? (
          &lt;img
            src=&quot;/wojak.png&quot;
            // src={characterImageUrl}
            alt={character.name}
            className=&quot;w-full h-full object-cover&quot;
            onLoad={handleImageLoad}
            onError={handleImageError}
            style={{ display: imageLoading ? &#39;none&#39; : &#39;block&#39; }}
          /&gt;
        ) : (
          // Fallback to default wojak image
          &lt;img
            src={character.currentImageUrl || &quot;/wojak.png&quot;}
            alt={character.name}
            className=&quot;w-full h-full object-cover&quot;
            onLoad={() =&gt; setImageLoading(false)}
            onError={() =&gt; {
              setImageLoading(false)
              // Ultimate fallback
              const target = event?.target as HTMLImageElement
              if (target) {
                target.style.display = &#39;none&#39;
                if (target.parentElement) {
                  target.parentElement.innerHTML = &#39;&lt;div class=&quot;text-4xl&quot;&gt;ü•∫&lt;/div&gt;&#39;
                }
              }
            }}
          /&gt;
        )}
      &lt;/div&gt;
    )
  }

  // Add this function to show layer information (useful for debugging)
  // const LayerDebugPanel: React.FC&lt;{ character: Character }&gt; = ({ character }) =&gt; {
  //   const characterLayers = generateCharacterLayers(character)
  //   const visibleLayers = resolveVisibleLayers(
  //     characterLayers,
  //     character.currentLocation.biome
  //   )

  //   return (
  //     &lt;div className=&quot;mt-4 p-3 bg-muted/30 rounded-lg&quot;&gt;
  //       &lt;h4 className=&quot;font-medium mb-2 text-sm&quot;&gt;Character Layers (Debug)&lt;/h4&gt;
  //       &lt;div className=&quot;space-y-1 text-xs&quot;&gt;
  //         {visibleLayers.map((layer, i) =&gt; (
  //           &lt;div key={i} className=&quot;flex justify-between items-center&quot;&gt;
  //             &lt;span className={layer.visible ? &#39;text-green-600&#39; : &#39;text-red-500&#39;}&gt;
  //               {layer.type}/{layer.name}
  //             &lt;/span&gt;
  //             &lt;span className=&quot;text-muted-foreground&quot;&gt;
  //               z:{layer.zIndex} {layer.visible ? &#39;‚úì&#39; : &#39;‚úó&#39;}
  //             &lt;/span&gt;
  //           &lt;/div&gt;
  //         ))}
  //       &lt;/div&gt;

  //       &lt;div className=&quot;mt-2 pt-2 border-t&quot;&gt;
  //         &lt;a
  //           href={`/.netlify/functions/metadata/${character.tokenId || character.id}`}
  //           target=&quot;_blank&quot;
  //           rel=&quot;noopener noreferrer&quot;
  //           className=&quot;text-xs text-blue-500 hover:underline&quot;
  //         &gt;
  //           View NFT Metadata ‚Üí
  //         &lt;/a&gt;
  //       &lt;/div&gt;
  //     &lt;/div&gt;
  //   )
  // }



  const renderMainView = () =&gt; (
    &lt;div className=&quot;space-y-6&quot;&gt;
      &lt;ModeToggle /&gt;
      &lt;div className=&quot;text-center&quot;&gt;
        &lt;CharacterRenderer character={character} /&gt;
        &lt;h2 className=&quot;text-xl font-bold&quot;&gt;{character.name}&lt;/h2&gt;
        &lt;p className=&quot;text-muted-foreground&quot;&gt;Currently in {character.currentLocation.name}&lt;/p&gt;
        &lt;div className=&quot;flex justify-center gap-4 mt-2&quot;&gt;
          &lt;span className=&quot;text-sm flex items-center gap-1&quot;&gt;
            &lt;Zap className=&quot;w-3 h-3&quot; /&gt; {character.energy}/100
          &lt;/span&gt;
          &lt;span className=&quot;text-sm flex items-center gap-1&quot;&gt;
            &lt;Heart className=&quot;w-3 h-3&quot; /&gt; {character.health}/100
          &lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div className=&quot;grid grid-cols-2 gap-3&quot;&gt;
        &lt;Button onClick={() =&gt; setCurrentView(&#39;map&#39;)} variant=&quot;outline&quot;&gt;
          &lt;Map className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Map
        &lt;/Button&gt;
        &lt;Button onClick={() =&gt; setCurrentView(&#39;mine&#39;)} variant=&quot;outline&quot;&gt;
          &lt;Pickaxe className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Mine
        &lt;/Button&gt;
        &lt;Button onClick={() =&gt; setCurrentView(&#39;market&#39;)} variant=&quot;outline&quot;&gt;
          &lt;Store className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Market
        &lt;/Button&gt;
        &lt;Button onClick={() =&gt; setCurrentView(&#39;inventory&#39;)} variant=&quot;outline&quot;&gt;
          &lt;Backpack className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Inventory
        &lt;/Button&gt;
      &lt;/div&gt;

      &lt;div className=&quot;mt-4&quot;&gt;
        &lt;Button onClick={() =&gt; setCurrentView(&#39;chat&#39;)} variant=&quot;ghost&quot; className=&quot;w-full&quot;&gt;
          &lt;MessageCircle className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Local Chat ({playersAtLocation.length} online)
        &lt;/Button&gt;
      &lt;/div&gt;

      {/* Add debug panel in development */}
      {/* {process.env.NODE_ENV === &#39;development&#39; &amp;&amp; character &amp;&amp; (
        &lt;LayerDebugPanel character={character} /&gt;
      )} */}
    &lt;/div&gt;
  )

  const renderMapView = () =&gt; (
    &lt;div className=&quot;space-y-4&quot;&gt;
      &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;World Map&lt;/h3&gt;
      &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;
        Explore different locations across Wojak Earth
      &lt;/p&gt;

      &lt;Tabs defaultValue=&quot;list&quot; className=&quot;w-full&quot;&gt;
        &lt;TabsList className=&quot;mb-4&quot;&gt;
          &lt;TabsTrigger value=&quot;list&quot;&gt;List&lt;/TabsTrigger&gt;
          &lt;TabsTrigger value=&quot;map&quot;&gt;Map&lt;/TabsTrigger&gt;
        &lt;/TabsList&gt;

        &lt;TabsContent value=&quot;list&quot;&gt;
          &lt;div className=&quot;space-y-3&quot;&gt;
            {locations.map(location =&gt; (
              &lt;div
                key={location.id}
                className=&quot;border rounded-lg p-4 hover:bg-muted/50 transition-colors cursor-pointer&quot;
                onClick={() =&gt; handleLocationSelect(location)}
              &gt;
                &lt;div className=&quot;flex items-start justify-between mb-2&quot;&gt;
                  &lt;div&gt;
                    &lt;h4 className=&quot;font-medium&quot;&gt;{location.name}&lt;/h4&gt;
                    &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;{location.description}&lt;/p&gt;
                  &lt;/div&gt;
                  &lt;div className=&quot;flex items-center gap-1 text-sm text-muted-foreground&quot;&gt;
                    &lt;Users className=&quot;w-3 h-3&quot; /&gt;
                    {location.playerCount}
                  &lt;/div&gt;
                &lt;/div&gt;

                &lt;div className=&quot;flex items-center justify-between text-xs&quot;&gt;
                  &lt;div className=&quot;flex gap-3&quot;&gt;
                    &lt;span className=&quot;flex items-center gap-1&quot;&gt;
                      &lt;span className={`w-2 h-2 rounded-full ${location.difficulty &lt;= 2
                        ? &#39;bg-green-500&#39;
                        : location.difficulty &lt;= 4
                          ? &#39;bg-yellow-500&#39;
                          : &#39;bg-red-500&#39;
                        }`} /&gt;
                      Level {location.difficulty}
                    &lt;/span&gt;
                    &lt;span className=&quot;capitalize&quot;&gt;{location.biome}&lt;/span&gt;
                  &lt;/div&gt;
                  &lt;span className=&quot;text-muted-foreground&quot;&gt;
                    {location.lastActive
                      ? new Date(location.lastActive).toLocaleString()
                      : &#39;Active recently&#39;}
                  &lt;/span&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            ))}
          &lt;/div&gt;
        &lt;/TabsContent&gt;

        &lt;TabsContent value=&quot;map&quot;&gt;
          &lt;WorldMapView locations={locations} /&gt;
        &lt;/TabsContent&gt;
      &lt;/Tabs&gt;

      &lt;Button onClick={() =&gt; setCurrentView(&quot;main&quot;)} variant=&quot;ghost&quot;&gt;
        &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
        Back
      &lt;/Button&gt;
    &lt;/div&gt;
  )


  const renderLocationView = () =&gt; {
    if (!selectedLocation) return null

    return (
      &lt;div className=&quot;space-y-4&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          &lt;h3 className=&quot;text-lg font-semibold&quot;&gt;{selectedLocation.name}&lt;/h3&gt;
          &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;{selectedLocation.description}&lt;/p&gt;
          {selectedLocation.locationType &amp;&amp; (
            &lt;span className=&quot;inline-block mt-1 px-2 py-1 text-xs bg-muted rounded-full capitalize&quot;&gt;
              {selectedLocation.locationType.toLowerCase()}
            &lt;/span&gt;
          )}
        &lt;/div&gt;

        {selectedLocation.welcomeMessage &amp;&amp; (
          &lt;div className=&quot;bg-muted/50 p-3 rounded-lg text-sm italic text-center&quot;&gt;
            &quot;{selectedLocation.welcomeMessage}&quot;
          &lt;/div&gt;
        )}

        &lt;div className=&quot;grid grid-cols-3 gap-2 text-center text-sm&quot;&gt;
          &lt;div&gt;
            &lt;div className=&quot;font-medium&quot;&gt;{selectedLocation.playerCount}&lt;/div&gt;
            &lt;div className=&quot;text-muted-foreground&quot;&gt;Players&lt;/div&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;div className=&quot;font-medium&quot;&gt;
              {selectedLocation.difficulty ? `Level ${selectedLocation.difficulty}` : &#39;N/A&#39;}
            &lt;/div&gt;
            &lt;div className=&quot;text-muted-foreground&quot;&gt;Difficulty&lt;/div&gt;
          &lt;/div&gt;
          &lt;div&gt;
            &lt;div className=&quot;font-medium capitalize&quot;&gt;
              {selectedLocation.biome || selectedLocation.locationType?.toLowerCase()}
            &lt;/div&gt;
            &lt;div className=&quot;text-muted-foreground&quot;&gt;Type&lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;

        {/* Sub-locations */}
        {selectedLocation.subLocations &amp;&amp; selectedLocation.subLocations.length &gt; 0 &amp;&amp; (
          &lt;div&gt;
            &lt;h4 className=&quot;font-medium mb-2&quot;&gt;Places to Visit&lt;/h4&gt;
            &lt;div className=&quot;space-y-2&quot;&gt;
              {selectedLocation.subLocations.map((subLocation) =&gt; (
                &lt;div
                  key={subLocation.id}
                  className=&quot;flex items-center justify-between p-2 bg-muted/30 rounded cursor-pointer hover:bg-muted/50 transition-colors&quot;
                  onClick={() =&gt; handleLocationSelect(subLocation)}
                &gt;
                  &lt;div&gt;
                    &lt;div className=&quot;font-medium text-sm&quot;&gt;{subLocation.name}&lt;/div&gt;
                    &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;{subLocation.description}&lt;/div&gt;
                  &lt;/div&gt;
                  &lt;div className=&quot;flex items-center gap-2 text-xs text-muted-foreground&quot;&gt;
                    &lt;Users className=&quot;w-3 h-3&quot; /&gt;
                    {subLocation.playerCount}
                  &lt;/div&gt;
                &lt;/div&gt;
              ))}
            &lt;/div&gt;
          &lt;/div&gt;
        )}

        &lt;div&gt;
          &lt;h4 className=&quot;font-medium mb-2 flex items-center gap-2&quot;&gt;
            &lt;Users className=&quot;w-4 h-4&quot; /&gt;
            Players Here ({playersAtLocation.length})
          &lt;/h4&gt;
          &lt;div className=&quot;space-y-2 max-h-32 overflow-y-auto&quot;&gt;
            {playersAtLocation.map(player =&gt; (
              &lt;div key={player.id} className=&quot;flex items-center justify-between p-2 bg-muted/30 rounded text-sm&quot;&gt;
                &lt;div className=&quot;flex items-center gap-2&quot;&gt;
                  &lt;div className=&quot;w-6 h-6 bg-gray-300 rounded-full flex items-center justify-center text-xs&quot;&gt;
                    {player.characterType === &#39;HUMAN&#39; ? &#39;üôÇ&#39; : &#39;üëπ&#39;}
                  &lt;/div&gt;
                  &lt;div&gt;
                    &lt;div className=&quot;font-medium&quot;&gt;{player.name}&lt;/div&gt;
                    &lt;div className=&quot;text-xs text-muted-foreground&quot;&gt;Level {player.level} ‚Ä¢ {player.status}&lt;/div&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
                &lt;div className=&quot;text-xs text-right&quot;&gt;
                  &lt;div className=&quot;flex items-center gap-1&quot;&gt;
                    &lt;Zap className=&quot;w-2 h-2&quot; /&gt; {player.energy}
                  &lt;/div&gt;
                  &lt;div className=&quot;flex items-center gap-1&quot;&gt;
                    &lt;Heart className=&quot;w-2 h-2&quot; /&gt; {player.health}
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/div&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div className=&quot;grid grid-cols-2 gap-2&quot;&gt;
          {selectedLocation.name !== character.currentLocation.name &amp;&amp; (
            &lt;Button onClick={() =&gt; handleTravel(selectedLocation.id)} variant=&quot;outline&quot;&gt;
              &lt;MapPin className=&quot;w-4 h-4 mr-2&quot; /&gt;
              Travel Here
            &lt;/Button&gt;
          )}
          &lt;Button onClick={() =&gt; setCurrentView(&#39;chat&#39;)} variant=&quot;outline&quot;&gt;
            &lt;MessageCircle className=&quot;w-4 h-4 mr-2&quot; /&gt;
            Local Chat
          &lt;/Button&gt;
        &lt;/div&gt;

        {selectedLocation.lore &amp;&amp; (
          &lt;div className=&quot;border-t pt-3&quot;&gt;
            &lt;h4 className=&quot;font-medium mb-2&quot;&gt;Lore&lt;/h4&gt;
            &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;{selectedLocation.lore}&lt;/p&gt;
          &lt;/div&gt;
        )}

        &lt;Button onClick={() =&gt; setCurrentView(&#39;map&#39;)} variant=&quot;ghost&quot;&gt;
          &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Back to Map
        &lt;/Button&gt;
      &lt;/div&gt;
    )
  }

  const renderMineView = () =&gt; (
    &lt;MiningView
      character={character}
      loadingItems={loadingItems}
      onBack={() =&gt; setCurrentView(&#39;main&#39;)}
      onMine={handleMining}
    /&gt;
  )

  const renderMarketView = () =&gt; (
    &lt;MarketView
      character={character}
      selectedLocation={selectedLocation}
      locations={locations}
      marketItems={marketItems}
      loadingItems={loadingItems}
      onBack={() =&gt; setCurrentView(&#39;main&#39;)}
      onPurchase={handlePurchase}
    /&gt;
  )

  const renderInventoryView = () =&gt; (
    &lt;InventoryView
      character={character}
      loadingItems={loadingItems}
      onBack={() =&gt; setCurrentView(&#39;main&#39;)}
      onUseItem={handleUseItem}
      onEquipItem={handleEquipItem}
    /&gt;
  )

  const renderChatView = () =&gt; {
    return (
      &lt;div className=&quot;space-y-4&quot;&gt;
        &lt;div className=&quot;text-center&quot;&gt;
          &lt;h3 className=&quot;text-lg font-semibold flex items-center justify-center gap-2&quot;&gt;
            &lt;MessageCircle className=&quot;w-5 h-5&quot; /&gt;
            {selectedLocation ? selectedLocation.name : character.currentLocation.name}
          &lt;/h3&gt;
          &lt;p className=&quot;text-sm text-muted-foreground&quot;&gt;
            Local chat ‚Ä¢ {chatMessages.length} messages
          &lt;/p&gt;
        &lt;/div&gt;

        &lt;div className=&quot;bg-muted/30 rounded-lg p-3 h-64 overflow-y-auto space-y-2&quot;&gt;
          {chatMessages.length &gt; 0 ? (
            chatMessages.map(message =&gt; (
              &lt;div key={message.id} className=&quot;space-y-1&quot;&gt;
                {message.isSystem ? (
                  &lt;div className=&quot;text-xs text-center text-muted-foreground italic&quot;&gt;
                    {message.message}
                  &lt;/div&gt;
                ) : (
                  &lt;div className=&quot;space-y-1&quot;&gt;
                    &lt;div className=&quot;flex items-center gap-2 text-xs&quot;&gt;
                      &lt;div className=&quot;w-4 h-4 bg-gray-300 rounded-full flex items-center justify-center&quot;&gt;
                        {message.character?.characterType === &#39;HUMAN&#39; ? &#39;üôÇ&#39; : &#39;üëπ&#39;}
                      &lt;/div&gt;
                      &lt;span className=&quot;font-medium&quot;&gt;{message.character?.name}&lt;/span&gt;
                      &lt;span className=&quot;text-muted-foreground&quot;&gt;{message.timeAgo}&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;div className=&quot;text-sm pl-6&quot;&gt;
                      {message.messageType === &#39;EMOTE&#39; ? (
                        &lt;span className=&quot;italic&quot;&gt;*{message.message}*&lt;/span&gt;
                      ) : (
                        message.message
                      )}
                    &lt;/div&gt;
                  &lt;/div&gt;
                )}
              &lt;/div&gt;
            ))
          ) : (
            &lt;div className=&quot;text-sm text-muted-foreground text-center&quot;&gt;
              No messages yet. Be the first to say something!
            &lt;/div&gt;
          )}
        &lt;/div&gt;

        &lt;div className=&quot;flex gap-2&quot;&gt;
          &lt;input
            type=&quot;text&quot;
            placeholder=&quot;Type your message...&quot;
            value={chatInput}
            onChange={(e) =&gt; setChatInput(e.target.value)}
            onKeyPress={(e) =&gt; e.key === &#39;Enter&#39; &amp;&amp; handleSendMessage()}
            className=&quot;flex-1 px-3 py-2 border rounded-md text-sm&quot;
          /&gt;
          &lt;Button size=&quot;sm&quot; onClick={handleSendMessage} disabled={!chatInput.trim()}&gt;
            &lt;Send className=&quot;w-4 h-4&quot; /&gt;
          &lt;/Button&gt;
        &lt;/div&gt;

        &lt;Button onClick={() =&gt; setCurrentView(selectedLocation ? &#39;location&#39; : &#39;main&#39;)} variant=&quot;ghost&quot;&gt;
          &lt;ArrowLeft className=&quot;w-4 h-4 mr-2&quot; /&gt;
          Back
        &lt;/Button&gt;
      &lt;/div&gt;
    )
  }

  return (
    &lt;&gt;
      &lt;Toaster
        position=&quot;top-right&quot;
        expand={false}
        richColors={true}
        closeButton={false}
        offset={16}
        toastOptions={{
          duration: 7000,
          style: {
            background: &#39;hsl(var(--card))&#39;,
            color: &#39;hsl(var(--card-foreground))&#39;,
            border: &#39;1px solid hsl(var(--border))&#39;,
            borderRadius: &#39;8px&#39;,
            fontSize: &#39;14px&#39;,
            padding: &#39;12px 16px&#39;,
            zIndex: 99999,
            position: &#39;relative&#39;,
          },
          className: &#39;&#39;,
        }}
      /&gt;
      &lt;div className=&quot;min-h-screen bg-background p-4&quot;&gt;
        &lt;div className=&quot;max-w-md mx-auto&quot;&gt;
          &lt;div className=&quot;bg-card border rounded-lg p-6 shadow-sm&quot;&gt;
            &lt;h1 className=&quot;text-2xl font-bold text-center mb-6 flex items-center justify-center gap-2&quot;&gt;
              &lt;MapPin className=&quot;w-6 h-6&quot; /&gt;
              Wojak Earth
            &lt;/h1&gt;

            {currentView === &#39;main&#39; &amp;&amp; renderMainView()}
            {currentView === &#39;map&#39; &amp;&amp; renderMapView()}
            {currentView === &#39;location&#39; &amp;&amp; renderLocationView()}
            {currentView === &#39;mine&#39; &amp;&amp; renderMineView()}
            {currentView === &#39;market&#39; &amp;&amp; renderMarketView()}
            {currentView === &#39;inventory&#39; &amp;&amp; renderInventoryView()}
            {currentView === &#39;chat&#39; &amp;&amp; renderChatView()}
          &lt;/div&gt;

          {/* Game Log */}
          &lt;div className=&quot;mt-4 bg-card border rounded-lg p-4&quot;&gt;
            &lt;h4 className=&quot;font-medium mb-2&quot;&gt;Recent Activity&lt;/h4&gt;
            &lt;div className=&quot;space-y-1 text-sm&quot;&gt;
              {gameLog.map((log, i) =&gt; (
                &lt;div key={i} className=&quot;text-muted-foreground&quot;&gt;
                  {log}
                &lt;/div&gt;
              ))}
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/&gt;
  )
}

export default App
</content>
    </document>

    <document>
      <source>src/main.tsx</source>
      <tags></tags>
      <metadata>
        <size>384</size>
        <lastModified>2025-05-29T07:59:24.953Z</lastModified>
        <extension>tsx</extension>
        <directory>src</directory>
      </metadata>
      <content>import { StrictMode } from &#39;react&#39;
import { createRoot } from &#39;react-dom/client&#39;
import &#39;./index.css&#39;
import App from &#39;./App.tsx&#39;
import { ThemeProvider } from &#39;./components/theme-provider.tsx&#39;

createRoot(document.getElementById(&#39;root&#39;)!).render(
  &lt;StrictMode&gt;
    &lt;ThemeProvider defaultTheme=&quot;dark&quot; storageKey=&quot;vite-ui-theme&quot;&gt;
      &lt;App /&gt;
    &lt;/ThemeProvider&gt;
  &lt;/StrictMode&gt;,
)
</content>
    </document>

    <document>
      <source>src/App.css</source>
      <tags></tags>
      <metadata>
        <size>606</size>
        <lastModified>2025-05-28T21:44:35.041Z</lastModified>
        <extension>css</extension>
        <directory>src</directory>
      </metadata>
      <content>#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</content>
    </document>

    <document>
      <source>src/index.css</source>
      <tags></tags>
      <metadata>
        <size>4484</size>
        <lastModified>2025-05-28T21:46:42.653Z</lastModified>
        <extension>css</extension>
        <directory>src</directory>
      </metadata>
      <content>@import &quot;tailwindcss&quot;;
@import &quot;tw-animate-css&quot;;

@custom-variant dark (&amp;:is(.dark *));

@theme inline {
  --radius-sm: calc(var(--radius) - 4px);
  --radius-md: calc(var(--radius) - 2px);
  --radius-lg: var(--radius);
  --radius-xl: calc(var(--radius) + 4px);
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --color-card: var(--card);
  --color-card-foreground: var(--card-foreground);
  --color-popover: var(--popover);
  --color-popover-foreground: var(--popover-foreground);
  --color-primary: var(--primary);
  --color-primary-foreground: var(--primary-foreground);
  --color-secondary: var(--secondary);
  --color-secondary-foreground: var(--secondary-foreground);
  --color-muted: var(--muted);
  --color-muted-foreground: var(--muted-foreground);
  --color-accent: var(--accent);
  --color-accent-foreground: var(--accent-foreground);
  --color-destructive: var(--destructive);
  --color-border: var(--border);
  --color-input: var(--input);
  --color-ring: var(--ring);
  --color-chart-1: var(--chart-1);
  --color-chart-2: var(--chart-2);
  --color-chart-3: var(--chart-3);
  --color-chart-4: var(--chart-4);
  --color-chart-5: var(--chart-5);
  --color-sidebar: var(--sidebar);
  --color-sidebar-foreground: var(--sidebar-foreground);
  --color-sidebar-primary: var(--sidebar-primary);
  --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
  --color-sidebar-accent: var(--sidebar-accent);
  --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
  --color-sidebar-border: var(--sidebar-border);
  --color-sidebar-ring: var(--sidebar-ring);
}

:root {
  --radius: 0.625rem;
  --background: oklch(1 0 0);
  --foreground: oklch(0.147 0.004 49.25);
  --card: oklch(1 0 0);
  --card-foreground: oklch(0.147 0.004 49.25);
  --popover: oklch(1 0 0);
  --popover-foreground: oklch(0.147 0.004 49.25);
  --primary: oklch(0.216 0.006 56.043);
  --primary-foreground: oklch(0.985 0.001 106.423);
  --secondary: oklch(0.97 0.001 106.424);
  --secondary-foreground: oklch(0.216 0.006 56.043);
  --muted: oklch(0.97 0.001 106.424);
  --muted-foreground: oklch(0.553 0.013 58.071);
  --accent: oklch(0.97 0.001 106.424);
  --accent-foreground: oklch(0.216 0.006 56.043);
  --destructive: oklch(0.577 0.245 27.325);
  --border: oklch(0.923 0.003 48.717);
  --input: oklch(0.923 0.003 48.717);
  --ring: oklch(0.709 0.01 56.259);
  --chart-1: oklch(0.646 0.222 41.116);
  --chart-2: oklch(0.6 0.118 184.704);
  --chart-3: oklch(0.398 0.07 227.392);
  --chart-4: oklch(0.828 0.189 84.429);
  --chart-5: oklch(0.769 0.188 70.08);
  --sidebar: oklch(0.985 0.001 106.423);
  --sidebar-foreground: oklch(0.147 0.004 49.25);
  --sidebar-primary: oklch(0.216 0.006 56.043);
  --sidebar-primary-foreground: oklch(0.985 0.001 106.423);
  --sidebar-accent: oklch(0.97 0.001 106.424);
  --sidebar-accent-foreground: oklch(0.216 0.006 56.043);
  --sidebar-border: oklch(0.923 0.003 48.717);
  --sidebar-ring: oklch(0.709 0.01 56.259);
}

.dark {
  --background: oklch(0.147 0.004 49.25);
  --foreground: oklch(0.985 0.001 106.423);
  --card: oklch(0.216 0.006 56.043);
  --card-foreground: oklch(0.985 0.001 106.423);
  --popover: oklch(0.216 0.006 56.043);
  --popover-foreground: oklch(0.985 0.001 106.423);
  --primary: oklch(0.923 0.003 48.717);
  --primary-foreground: oklch(0.216 0.006 56.043);
  --secondary: oklch(0.268 0.007 34.298);
  --secondary-foreground: oklch(0.985 0.001 106.423);
  --muted: oklch(0.268 0.007 34.298);
  --muted-foreground: oklch(0.709 0.01 56.259);
  --accent: oklch(0.268 0.007 34.298);
  --accent-foreground: oklch(0.985 0.001 106.423);
  --destructive: oklch(0.704 0.191 22.216);
  --border: oklch(1 0 0 / 10%);
  --input: oklch(1 0 0 / 15%);
  --ring: oklch(0.553 0.013 58.071);
  --chart-1: oklch(0.488 0.243 264.376);
  --chart-2: oklch(0.696 0.17 162.48);
  --chart-3: oklch(0.769 0.188 70.08);
  --chart-4: oklch(0.627 0.265 303.9);
  --chart-5: oklch(0.645 0.246 16.439);
  --sidebar: oklch(0.216 0.006 56.043);
  --sidebar-foreground: oklch(0.985 0.001 106.423);
  --sidebar-primary: oklch(0.488 0.243 264.376);
  --sidebar-primary-foreground: oklch(0.985 0.001 106.423);
  --sidebar-accent: oklch(0.268 0.007 34.298);
  --sidebar-accent-foreground: oklch(0.985 0.001 106.423);
  --sidebar-border: oklch(1 0 0 / 10%);
  --sidebar-ring: oklch(0.553 0.013 58.071);
}

@layer base {
  * {
    @apply border-border outline-ring/50;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</content>
    </document>

    <document>
      <source>tsconfig.app.json</source>
      <tags></tags>
      <metadata>
        <size>755</size>
        <lastModified>2025-05-28T21:48:18.933Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;compilerOptions&quot;: {
      &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [
        &quot;./src/*&quot;
      ]
    },
    &quot;tsBuildInfoFile&quot;: &quot;./node_modules/.tmp/tsconfig.app.tsbuildinfo&quot;,
    &quot;target&quot;: &quot;ES2020&quot;,
    &quot;useDefineForClassFields&quot;: true,
    &quot;lib&quot;: [&quot;ES2020&quot;, &quot;DOM&quot;, &quot;DOM.Iterable&quot;],
    &quot;module&quot;: &quot;ESNext&quot;,
    &quot;skipLibCheck&quot;: true,

    /* Bundler mode */
    &quot;moduleResolution&quot;: &quot;bundler&quot;,
    &quot;allowImportingTsExtensions&quot;: true,
    &quot;verbatimModuleSyntax&quot;: true,
    &quot;moduleDetection&quot;: &quot;force&quot;,
    &quot;noEmit&quot;: true,
    &quot;jsx&quot;: &quot;react-jsx&quot;,

    /* Linting */
    &quot;strict&quot;: true,
    &quot;noUnusedLocals&quot;: true,
    &quot;noUnusedParameters&quot;: true,
    &quot;noFallthroughCasesInSwitch&quot;: true,
    &quot;noUncheckedSideEffectImports&quot;: true
  },
  &quot;include&quot;: [&quot;src&quot;]
}
</content>
    </document>

    <document>
      <source>TODO.md</source>
      <tags></tags>
      <metadata>
        <size>4300</size>
        <lastModified>2025-05-29T12:58:43.062Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content>## TODO.md

# üåç Wojak Earth - Development Status

_Updated: May 29, 2025_

## üéØ **Current Focus: Community &amp; Engagement**

We&#39;re building the most engaging MMO experience possible, with economic infrastructure ready to activate when player engagement warrants it.

## ‚úÖ **Proof of Concept - Complete**

### Core Game Systems

- ‚úÖ **Character Management** - Rich character display with real-time stats
- ‚úÖ **World Exploration** - 12+ interconnected locations with unique themes
- ‚úÖ **Mining System** - Location-based resource spawning with energy costs
- ‚úÖ **Trading Economy** - Multi-tier markets with local specialties
- ‚úÖ **Equipment System** - Visual equipment slots with auto-replacement
- ‚úÖ **Social Features** - Regional/local chat with community building
- ‚úÖ **Inventory Management** - Categories, consumables, materials organization

### Technical Infrastructure

- ‚úÖ **Database Architecture** - Complete Prisma schema with 13+ models
- ‚úÖ **API Layer** - 13 production-ready Netlify functions
- ‚úÖ **Content Management** - Game master tools for world building
- ‚úÖ **Real-time Systems** - Optimistic updates, toast notifications
- ‚úÖ **Crypto-ready Backend** - Infrastructure prepared for tokenized features

### World Content

- ‚úÖ **Rich Locations** - 7 unique regions with distinct personalities
- ‚úÖ **Diverse Items** - 50+ items from common materials to legendary artifacts
- ‚úÖ **Balanced Economy** - Location-based pricing and resource distribution
- ‚úÖ **Community Features** - Player tracking, social interactions

## üéØ **Stage 1: Community Building (Current)**

**Goal:** Prove engagement and community formation through pure gameplay

**Status:**

- Free gameplay to test community dynamics
- Focus on social interaction and player retention
- Community feedback driving feature priorities
- Engagement metrics informing next stage timing

**Metrics We&#39;re Watching:**

- Daily active players and session length
- Community-driven content creation
- Player-to-player interaction frequency
- Organic social media and word-of-mouth growth

## üöÄ **Stage 2: Soft Launch (Community Dependent)**

**Activates When:** Sustained player engagement and community requests for ownership

**Planned Features:**

- Character NFT minting (pay-to-create)
- Off-chain $EARTH economy (USDC ‚Üí game currency)
- Premium cosmetics and character customization
- Community governance experiment

**Infrastructure Ready:**

- ‚úÖ NFT metadata generation system
- ‚úÖ Payment processing architecture
- ‚úÖ Token balance management
- ‚úÖ Marketplace fee structure

## üåâ **Stage 3: Value Bridge (Stability Dependent)**

**Activates When:** Stable player base demonstrates long-term engagement

**Planned Features:**

- Mainnet $EARTH bridge (off-chain ‚Üî on-chain)
- Player-owned economy with real value
- DAO governance for game features
- Cross-game asset interoperability

**Infrastructure Ready:**

- ‚úÖ Bridge contract architecture planned
- ‚úÖ Token economics modeling complete
- ‚úÖ Governance framework designed

## üõ† **Game Master Capabilities (Private)**

_Demonstrating technical readiness for scaling_

- ‚úÖ **Content Management** - Real-time world building and economy balancing
- ‚úÖ **Community Health Monitoring** - Player behavior and engagement analytics
- ‚úÖ **Economic Controls** - Market manipulation prevention and balance tools
- ‚úÖ **Scalable Infrastructure** - Proven ability to handle feature deployment

## üéÆ **What Makes This Different**

1. **Community-Driven Economics** - Features activate based on player demand, not roadmaps
2. **Fun-First Design** - Game quality drives adoption, not token speculation
3. **Organic Growth** - Social features encourage genuine community building
4. **Technical Excellence** - Production-ready infrastructure with zero compromise on gameplay
5. **Patient Capital** - No rush to monetize; economics follow engagement

## üìä **Success Definition**

**Stage 1 Success:** Daily active community with organic social interactions
**Stage 2 Success:** Players actively requesting ownership and premium features  
**Stage 3 Success:** Sustainable player-owned economy with real-world value creation

---

_We&#39;re not building a crypto game with some gameplay attached. We&#39;re building the best possible game with crypto infrastructure ready when the community wants it._
</content>
    </document>

    <document>
      <source>.gitignore</source>
      <tags></tags>
      <metadata>
        <size>292</size>
        <lastModified>2025-05-28T23:07:21.376Z</lastModified>
        <extension>gitignore</extension>
        <directory>Root</directory>
      </metadata>
      <content># Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

.env

# Local Netlify folder
.netlify
</content>
    </document>

    <document>
      <source>package.json</source>
      <tags></tags>
      <metadata>
        <size>2778</size>
        <lastModified>2025-05-29T11:14:27.449Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;name&quot;: &quot;wojak-earth&quot;,
  &quot;private&quot;: true,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;vite&quot;,
    &quot;build&quot;: &quot;prisma generate &amp;&amp; tsc -b &amp;&amp; vite build&quot;,
    &quot;lint&quot;: &quot;eslint .&quot;,
    &quot;preview&quot;: &quot;vite preview&quot;,
    &quot;db:seed&quot;: &quot;tsx prisma/seed.ts&quot;,
    &quot;setup:world&quot;: &quot;tsx scripts/ultimate-world-setup.ts&quot;,
    &quot;setup:clean&quot;: &quot;tsx scripts/ultimate-world-setup.ts&quot;,
    &quot;add:new-regions&quot;: &quot;tsx scripts/add-new-regions.ts&quot;,
    &quot;setup:new-regions&quot;: &quot;tsx scripts/setup-new-regions-content.ts&quot;,
    &quot;expand:world&quot;: &quot;npm run add:new-regions &amp;&amp; npm run setup:new-regions&quot;,
    &quot;add:items&quot;: &quot;tsx scripts/add-themed-items.ts&quot;,
    &quot;add:tools&quot;: &quot;tsx scripts/add-proper-tools.ts&quot;,
    &quot;seed:mining&quot;: &quot;tsx scripts/seed-mining-resources.ts&quot;,
    &quot;seed:mining-tools&quot;: &quot;tsx scripts/update-mining-with-tools.ts&quot;,
    &quot;seed:markets&quot;: &quot;tsx scripts/seed-enhanced-markets.ts&quot;,
    &quot;debug:markets&quot;: &quot;tsx scripts/debug-market-locations.ts&quot;,
    &quot;fix:markets&quot;: &quot;tsx scripts/fix-market-locations.ts&quot;,
    &quot;setup:unified&quot;: &quot;tsx scripts/setup-complete-game.ts&quot;,
    &quot;setup:complete&quot;: &quot;npm run add:items &amp;&amp; npm run add:tools &amp;&amp; npm run seed:mining &amp;&amp; npm run seed:mining-tools &amp;&amp; npm run fix:markets &amp;&amp; npm run seed:markets&quot;,
    &quot;setup:quick&quot;: &quot;npm run fix:markets &amp;&amp; npm run seed:markets&quot;,
    &quot;functions:dev&quot;: &quot;netlify dev&quot;,
    &quot;functions:build&quot;: &quot;netlify build&quot;,
    &quot;postinstall&quot;: &quot;prisma generate&quot;
  },
  &quot;prisma&quot;: {
    &quot;seed&quot;: &quot;tsx prisma/seed.ts&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@prisma/client&quot;: &quot;^6.8.2&quot;,
    &quot;@radix-ui/react-avatar&quot;: &quot;^1.1.10&quot;,
    &quot;@radix-ui/react-dialog&quot;: &quot;^1.1.14&quot;,
    &quot;@radix-ui/react-dropdown-menu&quot;: &quot;^2.1.15&quot;,
    &quot;@radix-ui/react-scroll-area&quot;: &quot;^1.2.9&quot;,
    &quot;@radix-ui/react-slot&quot;: &quot;^1.2.3&quot;,
    &quot;@radix-ui/react-tabs&quot;: &quot;^1.1.12&quot;,
    &quot;@radix-ui/react-tooltip&quot;: &quot;^1.2.7&quot;,
    &quot;@solana/wallet-adapter-base&quot;: &quot;^0.9.26&quot;,
    &quot;@solana/wallet-adapter-react&quot;: &quot;^0.15.38&quot;,
    &quot;@solana/wallet-adapter-wallets&quot;: &quot;^0.19.36&quot;,
    &quot;@solana/web3.js&quot;: &quot;^1.98.2&quot;,
    &quot;@tailwindcss/vite&quot;: &quot;^4.1.8&quot;,
    &quot;class-variance-authority&quot;: &quot;^0.7.1&quot;,
    &quot;clsx&quot;: &quot;^2.1.1&quot;,
    &quot;lucide-react&quot;: &quot;^0.511.0&quot;,
    &quot;next-themes&quot;: &quot;^0.4.6&quot;,
    &quot;prisma&quot;: &quot;^6.8.2&quot;,
    &quot;react&quot;: &quot;^19.1.0&quot;,
    &quot;react-dom&quot;: &quot;^19.1.0&quot;,
    &quot;sonner&quot;: &quot;^2.0.3&quot;,
    &quot;tailwind-merge&quot;: &quot;^3.3.0&quot;,
    &quot;tailwindcss&quot;: &quot;^4.1.8&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;@eslint/js&quot;: &quot;^9.25.0&quot;,
    &quot;@types/node&quot;: &quot;^22.15.24&quot;,
    &quot;@types/react&quot;: &quot;^19.1.2&quot;,
    &quot;@types/react-dom&quot;: &quot;^19.1.2&quot;,
    &quot;@vitejs/plugin-react&quot;: &quot;^4.4.1&quot;,
    &quot;eslint&quot;: &quot;^9.25.0&quot;,
    &quot;eslint-plugin-react-hooks&quot;: &quot;^5.2.0&quot;,
    &quot;eslint-plugin-react-refresh&quot;: &quot;^0.4.19&quot;,
    &quot;globals&quot;: &quot;^16.0.0&quot;,
    &quot;tsx&quot;: &quot;^4.19.4&quot;,
    &quot;tw-animate-css&quot;: &quot;^1.3.0&quot;,
    &quot;typescript&quot;: &quot;~5.8.3&quot;,
    &quot;typescript-eslint&quot;: &quot;^8.30.1&quot;,
    &quot;vite&quot;: &quot;^6.3.5&quot;
  }
}
</content>
    </document>

    <document>
      <source>.env</source>
      <tags></tags>
      <metadata>
        <size>135</size>
        <lastModified>2025-05-28T21:52:13.504Z</lastModified>
        <extension>env</extension>
        <directory>Root</directory>
      </metadata>
      <content>DATABASE_URL=postgresql://neondb_owner:npg_su0rywczKEv9@ep-lively-river-a6lm0x4f-pooler.us-west-2.aws.neon.tech/neondb?sslmode=require
</content>
    </document>

    <document>
      <source>components.json</source>
      <tags></tags>
      <metadata>
        <size>423</size>
        <lastModified>2025-05-28T21:46:42.115Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;$schema&quot;: &quot;https://ui.shadcn.com/schema.json&quot;,
  &quot;style&quot;: &quot;new-york&quot;,
  &quot;rsc&quot;: false,
  &quot;tsx&quot;: true,
  &quot;tailwind&quot;: {
    &quot;config&quot;: &quot;&quot;,
    &quot;css&quot;: &quot;src/index.css&quot;,
    &quot;baseColor&quot;: &quot;stone&quot;,
    &quot;cssVariables&quot;: true,
    &quot;prefix&quot;: &quot;&quot;
  },
  &quot;aliases&quot;: {
    &quot;components&quot;: &quot;@/components&quot;,
    &quot;utils&quot;: &quot;@/lib/utils&quot;,
    &quot;ui&quot;: &quot;@/components/ui&quot;,
    &quot;lib&quot;: &quot;@/lib&quot;,
    &quot;hooks&quot;: &quot;@/hooks&quot;
  },
  &quot;iconLibrary&quot;: &quot;lucide&quot;
}</content>
    </document>

    <document>
      <source>tsconfig.json</source>
      <tags></tags>
      <metadata>
        <size>233</size>
        <lastModified>2025-05-28T21:45:45.831Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;files&quot;: [],
  &quot;references&quot;: [
    {
      &quot;path&quot;: &quot;./tsconfig.app.json&quot;
    },
    {
      &quot;path&quot;: &quot;./tsconfig.node.json&quot;
    }
  ],
  &quot;compilerOptions&quot;: {
    &quot;baseUrl&quot;: &quot;.&quot;,
    &quot;paths&quot;: {
      &quot;@/*&quot;: [&quot;./src/*&quot;]
    }
  }
}
</content>
    </document>

    <document>
      <source>vite.config.ts</source>
      <tags></tags>
      <metadata>
        <size>327</size>
        <lastModified>2025-05-28T21:46:16.230Z</lastModified>
        <extension>ts</extension>
        <directory>Root</directory>
      </metadata>
      <content>import path from &#39;path&#39;
import tailwindcss from &#39;@tailwindcss/vite&#39;
import react from &#39;@vitejs/plugin-react&#39;
import { defineConfig } from &#39;vite&#39;

// https://vite.dev/config/
export default defineConfig({
  plugins: [react(), tailwindcss()],
  resolve: {
    alias: {
      &#39;@&#39;: path.resolve(__dirname, &#39;./src&#39;),
    },
  },
})
</content>
    </document>

    <document>
      <source>eslint.config.js</source>
      <tags></tags>
      <metadata>
        <size>734</size>
        <lastModified>2025-05-28T21:44:35.037Z</lastModified>
        <extension>js</extension>
        <directory>Root</directory>
      </metadata>
      <content>import js from &#39;@eslint/js&#39;
import globals from &#39;globals&#39;
import reactHooks from &#39;eslint-plugin-react-hooks&#39;
import reactRefresh from &#39;eslint-plugin-react-refresh&#39;
import tseslint from &#39;typescript-eslint&#39;

export default tseslint.config(
  { ignores: [&#39;dist&#39;] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: [&#39;**/*.{ts,tsx}&#39;],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      &#39;react-hooks&#39;: reactHooks,
      &#39;react-refresh&#39;: reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      &#39;react-refresh/only-export-components&#39;: [
        &#39;warn&#39;,
        { allowConstantExport: true },
      ],
    },
  },
)
</content>
    </document>

    <document>
      <source>WHITEPAPER.md</source>
      <tags></tags>
      <metadata>
        <size>8174</size>
        <lastModified>2025-05-29T13:03:30.347Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content># üåç $EARTH Token Infrastructure

_Economic Foundation for Community-Driven Gaming_

---

## Executive Summary

$EARTH is the **planned economic infrastructure** for Wojak Earth, a social exploration MMO that prioritizes community engagement over premature monetization.

Unlike traditional crypto games that launch with tokenomics first, $EARTH is designed as **staged economic infrastructure** that activates only when the community demonstrates sustained engagement and explicitly requests ownership features.

---

## Design Philosophy

### Community-First Economics

- **Engagement drives activation** - Features deploy based on player demand, not roadmaps
- **Fun before finance** - Game quality must prove itself before introducing economic complexity
- **Organic growth** - Social interactions and community building create sustainable foundation
- **Patient capital** - No rush to monetize; let genuine economies emerge naturally

### Technical Readiness Without Premature Activation

- Complete token infrastructure built and tested
- Economic models proven in off-chain environment
- Bridge contracts designed but not deployed
- **Capability demonstrated, timeline community-driven**

---

## Staged Activation Model

### Stage 1: Community Building _(Current)_

**Status:** Proof of concept with free gameplay
**Focus:** Social interaction, player retention, community formation
**Economics:** None - pure gameplay engagement
**Success Metrics:** Daily active players, session length, organic social growth

### Stage 2: Soft Launch _(Community-Driven)_

**Activates When:** Players actively request ownership and premium features
**Features:**

- Character NFT minting (pay-to-create with USDC/SOL)
- Off-chain $EARTH economy (1 USDC ‚Üí 1,000 $EARTH, configurable)
- Premium cosmetics and character customization options
- Community governance experiments

**Economic Structure:**

- **Sources:** SPL token purchases, in-game rewards for sustained engagement
- **Sinks:** Premium features, cosmetics, marketplace fees, travel costs
- **Balance:** Designed for sustainability, not speculation

### Stage 3: Value Bridge _(Stability-Dependent)_

**Activates When:** Stable player base with proven economic sustainability
**Features:**

- Off-chain ‚Üî On-chain $EARTH bridge
- Real SPL token with DEX liquidity
- Player-owned marketplace with actual asset ownership
- DAO governance for game feature development

**Bridge Mechanics:**

- **Withdraw:** Burn off-chain $EARTH ‚Üí Mint on-chain SPL tokens
- **Deposit:** Send SPL $EARTH ‚Üí Credit off-chain balance
- **Rate Limits:** Prevent economic manipulation and ensure stability

---

## Token Distribution _(When On-Chain)_

| Allocation         | Percentage | Purpose                               |
| ------------------ | ---------- | ------------------------------------- |
| Player Bridge      | 50%        | On-demand minting via withdrawals     |
| Community Treasury | 25%        | Events, liquidity, governance         |
| Development Fund   | 15%        | Team alignment, long-term development |
| Ecosystem Growth   | 10%        | Partnerships, community incentives    |

**Supply Model:** Dynamic based on actual bridge demand, not speculative allocation

---

## Economic Sustainability

### Balanced Sink/Source Design

**Token Sources:**

- SPL token purchases (primary revenue)
- In-game achievements and community participation
- Marketplace transaction rewards
- Seasonal events and community challenges

**Token Sinks:**

- Premium character features and cosmetics
- Marketplace listing fees and transaction costs
- Travel to premium locations
- Crafting and equipment enhancement
- Community event participation costs

### Anti-Speculation Measures

- **Utility-first design** - Tokens valuable for gameplay, not just trading
- **Community governance** - Players control economic parameters
- **Gradual activation** - No sudden economic shocks or massive token unlocks
- **Sustainable revenue** - Multiple income streams beyond token appreciation

---

## Revenue Model

### Stage 2 Revenue Streams

- Direct SPL token ‚Üí $EARTH purchases
- Character NFT minting fees
- Premium feature subscriptions
- Marketplace transaction fees

### Stage 3 Additional Revenue

- Bridge transaction fees (minimal, sustainability-focused)
- Liquidity provision rewards
- Governance token mechanisms
- Cross-game interoperability partnerships

**Focus:** Sustainable revenue from engaged players, not speculative trading

---

## Risk Management

### Community Protection

- **No premature monetization** - Economics activate only when community is ready
- **Transparent governance** - Community controls economic parameters
- **Fair launch principles** - No insider advantages or hidden allocations
- **Sustainable design** - Long-term player value over short-term speculation

### Technical Safeguards

- **Battle-tested infrastructure** - All systems proven in off-chain environment
- **Gradual rollout** - Staged activation allows for adjustment and learning
- **Emergency controls** - Ability to pause or adjust economic features if needed
- **Community override** - Players can vote to modify or disable features

---

## Success Metrics

### Stage 1 (Current)

- Daily active users and session duration
- Community-generated content and social interactions
- Organic growth and word-of-mouth adoption
- Player feedback quality and engagement depth

### Stage 2 (Soft Launch)

- Premium feature adoption rates
- Community satisfaction with economic features
- Sustainable revenue generation
- Maintained gameplay quality despite monetization

### Stage 3 (Value Bridge)

- Healthy on-chain token economics
- Active player-owned marketplace
- Community governance participation
- Cross-ecosystem interoperability success

---

## Governance Framework

### Community Decision Making

- **Economic Parameters** - Community votes on token distribution rates, fees, and economic rules
- **Feature Activation** - Players decide when and how new economic features are introduced
- **Revenue Allocation** - Community determines how generated revenue is reinvested
- **Emergency Measures** - Collective decision-making for economic adjustments

### Developer Responsibilities

- **Technical Infrastructure** - Maintain and improve game systems and economic tools
- **Community Support** - Facilitate governance processes and implement community decisions
- **Transparency** - Regular reporting on economic health and development progress
- **Long-term Vision** - Balance community requests with sustainable development

---

## Conclusion

$EARTH represents a **fundamental shift in crypto gaming economics** - from speculation-driven token launches to community-driven value creation.

By building exceptional gameplay first and introducing economics only when the community demonstrates readiness, we create sustainable foundations for player-owned economies that enhance rather than replace the core gaming experience.

**This is patient capital applied to community building - the future of sustainable crypto gaming.**

---

## Technical Appendix

### Infrastructure Readiness Checklist

- ‚úÖ Complete off-chain token management system
- ‚úÖ NFT metadata generation and character rendering
- ‚úÖ Marketplace infrastructure with fee structures
- ‚úÖ Bridge contract architecture (designed, not deployed)
- ‚úÖ Governance voting mechanisms (ready to activate)
- ‚úÖ Economic monitoring and adjustment tools
- ‚úÖ Community feedback and decision-making systems

### Integration Points

- **Payment Processing:** USDC/SOL ‚Üí $EARTH conversion ready
- **NFT Minting:** Character and item tokenization infrastructure complete
- **Bridge Contracts:** Off-chain ‚Üî On-chain conversion mechanisms designed
- **Governance Tools:** Community voting and parameter adjustment systems built
- **Analytics:** Economic health monitoring and community sentiment tracking

**Status:** All technical infrastructure complete and tested. Activation timeline dependent entirely on community engagement and explicit request for these features.

---

_Building the economic infrastructure that communities deserve - ready when they are, not before._
</content>
    </document>

    <document>
      <source>PITCHDECK.md</source>
      <tags></tags>
      <metadata>
        <size>4487</size>
        <lastModified>2025-05-29T13:01:27.667Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content># üéØ Wojak Earth - Community-Driven MMO

_Investor Pitch: Building Engagement Before Economics_

---

## üåç **Slide 1: Vision**

**Wojak Earth**
_The MMO that activates tokenomics when the community is ready_

&gt; **We&#39;re proving that great games build great economies, not the other way around.**

---

## üéÆ **Slide 2: What We&#39;re Building**

**A Social Exploration MMO with Crypto-Ready Infrastructure**

- Rich multiplayer world with mining, trading, and crafting
- Real-time social features and community building
- Economic infrastructure ready for staged activation
- **Fun-first design** with tokenomics that activate based on engagement

---

## üìä **Slide 3: Staged Development Model**

**Stage 1: Proof of Engagement** _(Current)_

- Free gameplay focused on community building
- Measuring player retention and social interaction
- **Success Metric:** Sustained daily active community

**Stage 2: Soft Launch** _(Community-Driven)_

- Character NFT minting and off-chain $EARTH economy
- Premium features for engaged community members
- **Success Metric:** Players actively requesting ownership features

**Stage 3: Value Bridge** _(Stability-Dependent)_

- Mainnet $EARTH with real-world value extraction
- Player-owned economy and governance
- **Success Metric:** Sustainable economic ecosystem

---

## üõ† **Slide 4: Technical Readiness**

**Complete Game Infrastructure** _(Ready Today)_

- 13 production-grade API endpoints
- Real-time multiplayer systems
- Comprehensive content management tools
- **Crypto infrastructure built but not activated**

**Why This Approach Works:**

- Prove product-market fit before monetization
- Build genuine community before introducing economics
- Technical capability demonstrated, timeline driven by engagement

---

## üí∞ **Slide 5: Economics When Ready**

**$EARTH Token - Infrastructure Complete**

**Off-Chain Phase:**

- USDC/SOL ‚Üí $EARTH purchases for premium features
- In-game economy with sustainable sink/source balance
- Community governance experiments

**Bridge Phase:**

- Off-chain ‚Üî On-chain $EARTH conversion
- Real value extraction for engaged players
- Player-owned marketplace with actual ownership

---

## üìà **Slide 6: Market Opportunity**

**The Problem with Crypto Gaming:**

- Token-first approach creates unsustainable economies
- Players abandon games when speculation ends
- Community building takes backseat to financialization

**Our Solution:**

- **Community-first approach** builds lasting engagement
- **Technical readiness** without premature monetization
- **Organic economics** that emerge from genuine player demand

---

## üéØ **Slide 7: Competitive Advantage**

**What Makes Us Different:**

1. **Patience** - We don&#39;t monetize until community demands it
2. **Technical Excellence** - Production-ready infrastructure proves capability
3. **Community Focus** - Social features drive retention, not token rewards
4. **Flexible Monetization** - Multiple revenue streams ready when appropriate
5. **Sustainable Design** - Economics support gameplay, not replace it

---

## üìä **Slide 8: Current Traction**

**Proof of Concept Metrics:**

- Complete MMO systems with 50+ items and 12+ locations
- Rich social features and community tools
- Production-ready infrastructure handling all game systems
- **Zero player acquisition cost** during community building phase

**Development Stage Advantages:**

- Iterate based on player feedback, not token price
- Build sustainable engagement before introducing economics
- Prove technical capability to investors and community

---

## üíº **Slide 9: Investment Opportunity**

**We&#39;re Seeking Strategic Partners For:**

- Community building and player acquisition
- Technical infrastructure scaling
- Economic activation when community demonstrates readiness
- **Long-term vision alignment** over quick monetization

**Not Seeking:**

- Pressure for premature token launch
- Rush to monetize before community is ready
- Compromise on game quality for economic features

---

## üöÄ **Slide 10: The Vision**

**Wojak Earth represents the future of sustainable gaming economies**

- **Stage 1:** Prove we can build engaging communities
- **Stage 2:** Show we can monetize without destroying fun
- **Stage 3:** Demonstrate sustainable player-owned economies

**This isn&#39;t just a game or just a token - it&#39;s a new model for community-driven entertainment.**

---

_Join us in building the first MMO where economics serve the community, not the other way around._
</content>
    </document>

    <document>
      <source>NFT.md</source>
      <tags></tags>
      <metadata>
        <size>10292</size>
        <lastModified>2025-05-29T13:22:36.411Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content># üé® Wojak Earth - Dynamic Character NFT System

_Living NFTs That Evolve With Your Journey_

---

## The Innovation

**Your character NFT isn&#39;t just a static image - it&#39;s a living visual representation of your entire gaming journey.**

Every action you take, every item you equip, every location you visit, and every achievement you unlock dynamically updates your NFT&#39;s appearance in real-time. Your character becomes a visual autobiography of your adventures in Wojak Earth.

---

## How It Works

### **Dynamic Layer Composition**

Your character NFT is built from multiple visual layers that change based on your game state:

**Base Layers:**

- Character type (Human, Creature, etc.)
- Gender and core appearance
- Current location background

**Equipment Layers:**

- Head slot (hats, helmets, headwear)
- Body slot (clothing, armor, jackets)
- Accessory slot (jewelry, charms, tools)
- Tool slot (weapons, mining equipment)

**Status Layers:**

- Health/energy visual effects (glows, auras)
- Achievement badges and rank indicators
- Environmental effects (weather, biome-specific)
- Temporary status effects (potions, buffs)

### **Real-Time Rendering Pipeline**

```
Game Action ‚Üí Layer Update ‚Üí NFT Recomposition ‚Üí Metadata Refresh ‚Üí Visual Update
```

1. **Player Action** - Equip item, visit location, achieve milestone
2. **Layer Resolution** - System determines which visual layers to show/hide
3. **Dynamic Rendering** - Layers composited into final character image
4. **Metadata Update** - NFT traits and attributes automatically updated
5. **Live Refresh** - Character image updates across all platforms instantly

---

## Visual Evolution Examples

### **Equipment Changes**

```
Base Wojak ‚Üí Equips Miner&#39;s Hat ‚Üí NFT shows character wearing hat
             Adds Cyber Jacket ‚Üí NFT updates with jacket layer
             Finds Lucky Charm ‚Üí Charm appears as accessory
```

### **Location-Based Backgrounds**

```
Mining Plains ‚Üí Desert sand and heat shimmer background
Cyber City ‚Üí Neon lights and urban skyline
Crystal Caves ‚Üí Glowing crystal formations
Glitch Wastes ‚Üí Corrupted digital artifacts
```

### **Achievement Overlays**

```
First Epic Item Found ‚Üí Golden aura effect
Mining Milestone ‚Üí Specialized tool glow
Community Leader ‚Üí Leadership badge
Legendary Discovery ‚Üí Unique particle effects
```

### **Status Effects**

```
Low Health ‚Üí Red warning glow
High Energy ‚Üí Vibrant energy aura
Potion Active ‚Üí Swirling magical effects
Weather Events ‚Üí Environmental overlays
```

---

## Technical Architecture

### **Layer Management System**

- **Layer Types:** Background, Base, Clothing, Accessories, Overlays, Effects
- **Z-Index Ordering:** Automatic depth management for proper visual stacking
- **Conflict Resolution:** Smart handling of incompatible items (can&#39;t wear two hats)
- **Performance Optimization:** Efficient layer caching and delta updates

### **Rendering Engine**

- **Canvas Compositing:** HTML5 Canvas for real-time layer combination
- **Asset Pipeline:** Optimized PNG layers with transparency support
- **Quality Scaling:** Multiple resolution outputs (thumbnail, standard, high-res)
- **Format Support:** PNG for viewing, SVG for scalability, WebP for optimization

### **Metadata Integration**

```json
{
  &quot;name&quot;: &quot;Wojak #1337&quot;,
  &quot;description&quot;: &quot;A legendary miner currently exploring Crystal Caves...&quot;,
  &quot;image&quot;: &quot;https://wojak-earth.com/nft/1337.png&quot;,
  &quot;attributes&quot;: [
    { &quot;trait_type&quot;: &quot;Location&quot;, &quot;value&quot;: &quot;Crystal Caves&quot; },
    { &quot;trait_type&quot;: &quot;Hat&quot;, &quot;value&quot;: &quot;Miner&#39;s Helmet&quot; },
    { &quot;trait_type&quot;: &quot;Tool&quot;, &quot;value&quot;: &quot;Crystal Pickaxe&quot; },
    { &quot;trait_type&quot;: &quot;Status&quot;, &quot;value&quot;: &quot;Legendary Finder&quot; },
    { &quot;trait_type&quot;: &quot;Energy&quot;, &quot;value&quot;: 85, &quot;max_value&quot;: 100 }
  ],
  &quot;properties&quot;: {
    &quot;layers&quot;: [
      &quot;background-crystal-caves&quot;,
      &quot;base-male&quot;,
      &quot;hat-miners-helmet&quot;,
      &quot;tool-crystal-pickaxe&quot;
    ],
    &quot;last_updated&quot;: &quot;2025-05-29T12:00:00Z&quot;,
    &quot;game_version&quot;: &quot;1.2.3&quot;
  }
}
```

---

## NFT Features

### **Dynamic Traits**

Your NFT traits update automatically based on game state:

- **Current Location** - Always shows where you are
- **Equipped Items** - Displays all visible gear
- **Stats** - Real-time health, energy, level display
- **Achievements** - Permanent record of accomplishments
- **Activity Status** - Online/offline, current action

### **Historical Preservation**

While your NFT shows current state, we preserve your journey:

- **Version History** - Every significant change saved
- **Achievement Gallery** - Permanent record of all accomplishments
- **Equipment Archive** - Gallery of all items you&#39;ve owned
- **Location Log** - Travel history across all regions

### **Rarity Evolution**

Your character&#39;s rarity can increase through gameplay:

- **Base Rarity** - Determined at mint (Common, Uncommon, Rare)
- **Achievement Bonuses** - Legendary actions increase effective rarity
- **Equipment Influence** - Rare gear affects overall character rarity
- **Community Recognition** - Player voting can elevate status

---

## Use Cases &amp; Benefits

### **For Players**

- **Visual Progression** - See your journey reflected in your character&#39;s appearance
- **Social Status** - Rare equipment and achievements visible to others
- **Personal Investment** - Your NFT becomes more unique through your actions
- **Bragging Rights** - Legendary items and locations permanently displayed

### **For Communities**

- **Guild Recognition** - Team achievements shown on individual characters
- **Event Participation** - Special events leave permanent visual marks
- **Social Proof** - Active players stand out visually from inactive accounts
- **Community Building** - Shared visual elements create group identity

### **For Collectors**

- **Living Investment** - NFT value increases with player achievement
- **Unique Combinations** - Impossible to fake rare equipment/location combinations
- **Provable Scarcity** - Achievement-based rarity is verifiable and meaningful
- **Market Dynamics** - Active characters command premium over static ones

---

## Implementation Stages

### **Stage 1: Infrastructure** ‚úÖ

- Layer composition system built and tested
- Metadata generation pipeline complete
- Real-time rendering engine operational
- Basic equipment visualization working

### **Stage 2: Enhancement** üéØ

- Advanced status effects and overlays
- Location-specific environmental effects
- Achievement badge and milestone markers
- Social recognition visual elements

### **Stage 3: Advanced Features** üöÄ

- Community-driven layer creation
- Custom cosmetic options
- Cross-game interoperability
- AR/VR character display

---

## Economic Impact

### **NFT Value Drivers**

- **Activity Premium** - Active characters worth more than inactive
- **Achievement Rarity** - Legendary accomplishments increase value
- **Equipment Display** - Rare gear visible in NFT increases desirability
- **Historical Significance** - First-to-achieve status creates collectible value

### **Market Dynamics**

- **Engagement Rewards** - Playing the game literally increases NFT value
- **Social Proof** - Visual achievements create status and demand
- **Collector Appeal** - Dynamic evolution creates ongoing interest
- **Utility Value** - NFT serves functional purpose beyond speculation

---

## Technical Specifications

### **Layer Assets**

- **Resolution:** 512x512 base, scalable to 2048x2048
- **Format:** PNG with alpha transparency
- **Optimization:** WebP for web, PNG for permanent storage
- **Naming Convention:** `{type}-{category}-{item-name}.png`

### **Rendering Performance**

- **Composition Time:** &lt;200ms for standard character
- **Cache Strategy:** Layer combinations cached for 24 hours
- **Update Frequency:** Real-time for equipment, hourly for status
- **Fallback System:** Static images if rendering fails

### **API Endpoints**

```
GET /nft/{characterId}.png        - Current character image
GET /nft/{characterId}/metadata   - Full NFT metadata
GET /nft/{characterId}/layers     - Layer composition details
GET /nft/{characterId}/history    - Visual evolution timeline
```

---

## Privacy &amp; Control

### **Player Control**

- **Visibility Settings** - Choose what aspects are publicly visible
- **Historical Opt-out** - Remove specific achievements from display
- **Equipment Privacy** - Hide valuable items if desired
- **Status Broadcasting** - Control real-time activity sharing

### **Data Security**

- **On-chain Metadata** - Core traits stored on blockchain
- **Decentralized Images** - Visual assets on IPFS/Arweave
- **Player Ownership** - Complete control over NFT and associated data
- **Privacy by Design** - Only publicly opt-in information displayed

---

## Future Vision

**Your Wojak Earth character NFT becomes the ultimate gaming passport:**

- **Cross-Game Identity** - Visual representation carries across different games
- **Achievement Portfolio** - Permanent record of all gaming accomplishments
- **Social Credential** - Proof of skill, dedication, and community contribution
- **Investment Asset** - Value that grows with your gaming journey
- **Digital Legacy** - Permanent artifact of your virtual adventures

---

## Getting Started

### **Minting Your Character** _(Stage 2 Feature)_

1. **Play First** - Build your character through gameplay
2. **Mint When Ready** - Convert your character to NFT when desired
3. **Visual History** - All your progress becomes part of the NFT
4. **Ongoing Evolution** - Continue playing, keep evolving your NFT

### **Viewing Your NFT**

- **In-Game Display** - See your character in all its dynamic glory
- **Wallet Integration** - Standard NFT display in any compatible wallet
- **Social Sharing** - Export high-res images for social media
- **Marketplace Display** - Full visual presentation on NFT platforms

---

_Your journey creates your NFT. Your NFT tells your story._

---

## Technical Deep Dive

For developers and technical stakeholders interested in implementation details, see our [Layer Resolution System Documentation](./src/lib/layerResolver.ts) and [NFT Metadata Generation](./netlify/functions/metadata.js) source code.

---

_This represents the future of gaming NFTs - not static pictures, but living, breathing visual representations of player achievement and community participation._
</content>
    </document>

    <document>
      <source>README.md</source>
      <tags></tags>
      <metadata>
        <size>1111</size>
        <lastModified>2025-05-29T13:12:00.912Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content># üåç Wojak Earth

A social exploration MMO where players mine, trade, craft, and build communities across interconnected worlds.

## Current Status

**Proof of Concept** - Fully functional game systems with crypto-ready infrastructure

## What We&#39;re Building

- **Community-first MMO** with rich social interactions
- **Engaging gameplay** across mining, trading, crafting, and exploration
- **Crypto-ready architecture** that activates based on player engagement
- **Organic economy** that grows with the community

## Key Features

- ‚úÖ Complete inventory and equipment system
- ‚úÖ Multi-location world with unique biomes
- ‚úÖ Real-time chat and social features
- ‚úÖ Resource mining and crafting mechanics
- ‚úÖ Player-driven marketplace
- ‚úÖ Infrastructure ready for tokenized features

## Development Philosophy

**Fun-first, crypto-ready** - We build the best possible game experience, with economic features that activate when the community demonstrates sustained engagement.

## Getting Started

```bash
npm install
npm run setup:world  # Complete game setup
npm run dev          # Start development server
```
</content>
    </document>

    <document>
      <source>LITEPAPER.md</source>
      <tags></tags>
      <metadata>
        <size>6107</size>
        <lastModified>2025-05-29T13:15:03.925Z</lastModified>
        <extension>md</extension>
        <directory>Root</directory>
      </metadata>
      <content># üåç Wojak Earth - Litepaper

_Community-First MMO with Crypto-Ready Infrastructure_

---

## The Problem

**Crypto games launch backwards.** They start with tokenomics, add gameplay as an afterthought, and wonder why communities abandon them when speculation ends.

Players don&#39;t want to &quot;play to earn&quot; - they want to **play to enjoy**, with earning as an organic possibility that emerges from genuine engagement.

---

## Our Approach

**Build the best possible game first. Add economics when the community asks for them.**

Wojak Earth is a social exploration MMO where players mine, trade, craft, and build communities across interconnected worlds. We&#39;ve built complete crypto infrastructure - NFT systems, token economics, bridge contracts - but **none of it is active.**

Instead, we&#39;re focused entirely on what matters: **creating engaging social experiences that make players want to log in every day.**

---

## Why This Works

### 1. **Sustainable Community Building**

Free gameplay removes financial pressure and speculation. Players join for fun, stay for community, and create organic social bonds that last beyond market cycles.

### 2. **Proven Technical Capability**

We&#39;ve built production-ready crypto infrastructure alongside exceptional gameplay systems. Investors can see we&#39;re technically capable without the risk of premature monetization.

### 3. **Market Timing Control**

We activate economic features when the community demonstrates sustained engagement, not when we need revenue. This creates sustainable growth rather than speculative bubbles.

### 4. **Authentic Player Demand**

When players start asking &quot;Can I own my character?&quot; and &quot;Can I trade items for real value?&quot;, we know they&#39;re genuinely engaged, not just speculating.

---

## Current Status

**Proof of Concept Complete** - Full MMO systems with crypto infrastructure ready

### Game Systems ‚úÖ

- Multi-region world with unique biomes and communities
- Complete inventory, equipment, and crafting systems
- Real-time chat and social features
- Resource mining and player-driven marketplace
- Rich character progression and customization

### Crypto Infrastructure ‚úÖ (Built, Not Active)

- NFT metadata and character rendering systems
- Token economics modeling and balance testing
- Payment processing and wallet integration
- Bridge contracts designed for future deployment
- Community governance frameworks

---

## Staged Activation Model

### **Stage 1: Community Building** _(Current)_

- **Focus:** Social engagement, player retention, organic growth
- **Economics:** None - completely free gameplay
- **Success Metric:** Daily active community with genuine social interactions

### **Stage 2: Soft Launch** _(Community-Driven)_

- **Activates When:** Players actively request ownership features
- **Features:** Character NFT minting, off-chain $EARTH economy, premium cosmetics
- **Success Metric:** Sustained revenue from engaged players, not speculators

### **Stage 3: Value Bridge** _(Stability-Dependent)_

- **Activates When:** Stable player base with proven economic sustainability
- **Features:** Mainnet $EARTH bridge, player-owned marketplace, DAO governance
- **Success Metric:** Thriving player-owned economy with real-world value creation

---

## What Makes This Different

### **Patient Capital Approach**

We&#39;re not rushing to monetize. We&#39;re building sustainable foundations that can support tokenized features when the community genuinely wants them.

### **Technical Excellence First**

Our crypto infrastructure is production-ready, but we&#39;re proving game quality and community engagement before activating economic features.

### **Community-Driven Timeline**

Features activate based on player demand and engagement metrics, not arbitrary roadmap dates or funding pressure.

### **Sustainable by Design**

When economics do activate, they&#39;re designed to enhance gameplay and community building, not replace them with financial speculation.

---

## The Vision

**Wojak Earth represents the future of crypto gaming:**

- Communities built on shared experiences, not shared investments
- Economic features that emerge organically from player engagement
- Technical capability demonstrated through exceptional gameplay
- Patient development that prioritizes long-term sustainability

We&#39;re proving that the best crypto games are first and foremost **great games** - with tokenomics that activate when they can genuinely enhance the player experience.

---

## For Investors

We&#39;re seeking partners who understand that **sustainable crypto gaming requires patience and community-first thinking.**

**What we offer:**

- Proven technical capability across both gaming and crypto systems
- Clear community-driven activation model with measurable milestones
- Sustainable revenue potential without speculative risk
- Long-term vision for player-owned economies built on genuine engagement

**What we&#39;re not:**

- A quick token flip opportunity
- A game disguised as DeFi yield farming
- A project that prioritizes tokenomics over player experience
- A team that will compromise game quality for faster monetization

---

## Next Steps

**Join our community** and see what community-first gaming looks like. Experience the gameplay, participate in the social systems, and help us build the foundation for sustainable crypto gaming.

When you&#39;re ready to own your character, trade items for real value, and participate in governing the game&#39;s future - those features will be ready too.

**But first, let&#39;s build something worth owning.**

---

_Wojak Earth - Where community builds the economy, not the other way around._

---

## Quick Links

- **Play the Game:** [earth.ndao.computer](https://earth.ndao.computer)
- **Community:** Join our community channels for updates
- **Documentation:** [Full Technical Details](./WHITEPAPER.md)
- **Investment Deck:** [Detailed Investor Presentation](./PITCHDECK.md)

---

_This litepaper serves as an introduction to our approach. For detailed tokenomics, technical specifications, and investment opportunities, see our complete documentation suite._
</content>
    </document>

    <document>
      <source>tsconfig.node.json</source>
      <tags></tags>
      <metadata>
        <size>598</size>
        <lastModified>2025-05-28T21:46:21.462Z</lastModified>
        <extension>json</extension>
        <directory>Root</directory>
      </metadata>
      <content>{
  &quot;compilerOptions&quot;: {
    &quot;tsBuildInfoFile&quot;: &quot;./node_modules/.tmp/tsconfig.node.tsbuildinfo&quot;,
    &quot;target&quot;: &quot;ES2022&quot;,
    &quot;lib&quot;: [&quot;ES2023&quot;],
    &quot;module&quot;: &quot;ESNext&quot;,
    &quot;skipLibCheck&quot;: true,

    /* Bundler mode */
    &quot;moduleResolution&quot;: &quot;bundler&quot;,
    &quot;allowImportingTsExtensions&quot;: true,
    &quot;verbatimModuleSyntax&quot;: true,
    &quot;moduleDetection&quot;: &quot;force&quot;,
    &quot;noEmit&quot;: true,

    /* Linting */
    &quot;strict&quot;: true,
    &quot;noUnusedLocals&quot;: true,
    &quot;noUnusedParameters&quot;: true,
    &quot;noFallthroughCasesInSwitch&quot;: true,
    &quot;noUncheckedSideEffectImports&quot;: true
  },
  &quot;include&quot;: [&quot;vite.config.ts&quot;]
}
</content>
    </document>

    <document>
      <source>index.html</source>
      <tags></tags>
      <metadata>
        <size>367</size>
        <lastModified>2025-05-28T21:48:47.451Z</lastModified>
        <extension>html</extension>
        <directory>Root</directory>
      </metadata>
      <content>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/wojak-earth.svg&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;
    &lt;title&gt;wojak-earth&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;module&quot; src=&quot;/src/main.tsx&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</content>
    </document>
    
  </documents>

</bundle>